Reports:
  - ReportName: Device_Missing_CVEs_Summary
    ReportPurpose: This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report Purpose
        // This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
        
        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 1  Build asset list and attach metadata used later in joins and scoring
        // Only endpoints are included
        // Excluded endpoints are removed
        // Customer facing flag is normalized from rawData or raw
        // Existing criticality fields are kept exactly as-is
        // Asset tags are collected from multiple rawData locations and combined into one list
        // AssetTags is the semicolon separated tag string
        // AssetTierByTag is extracted from AssetTags using regex and sorted for stable output
        // LegacyEndOfSupport is derived from AssetProps rawData OS platform and version fields when present
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))
            | where EG_IsExcluded == false
            | extend CriticalityLevel = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
            , CriticalityRuleBased = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
            , CriticalityRuleNames = coalesce(
                strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
            , AadDeviceId = tostring(coalesce(
                NodeProperties.rawData.aadDeviceId,
                NodeProperties.raw.aadDeviceId,
                NodeProperties.aadDeviceId
            ))
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend
                deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
                deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
                tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
            | extend AssetTags = strcat_array(_AllTags, ";")
            | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
            | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
            | extend NodeAssetTags = _AllTags
            | extend AssetOSPlatform = tostring(coalesce(NoderawData.osPlatform, NoderawData.OSPlatform, NoderawData.platform, NoderawData.operatingSystem, NoderawData.os))
            | extend AssetOSVersion  = tostring(coalesce(NoderawData.osVersion,  NoderawData.OSVersion,  NoderawData.version,  NoderawData.operatingSystemVersion))
            | extend AssetOSDistribution = tostring(coalesce(NoderawData.osDistribution, NoderawData.OSDistribution, NoderawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))
            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux = iff(
                tolower(AssetOSPlatform) has "linux"
                and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                1, 0
              )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                AadDeviceId,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                NodeAssetTags,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport;


        // Step 2  Build finding list
        // Each node can have multiple categories so Categories is expanded to one row per category
        // Only nodes with a category containing finding are included
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges whose label contains affecting are included
        // Edge properties are included when present otherwise an empty object is used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges
        // Edges can point in either direction so both directions are joined and then unioned
        // The result is summarized per AssetName AssetLabel FindingName to de-duplicate
        let AF_edges_oneway =
            Edges
            | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges_otherway =
            Edges
            | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges = union AF_edges_oneway, AF_edges_otherway;

        AF_edges
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAll         = make_bag(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            AadDeviceId          = any(AadDeviceId),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            NodeAssetTags        = any(NodeAssetTags),
            AssetTags            = any(AssetTags),
            AssetTierByTag       = any(AssetTierByTag),
            LegacyEndOfSupport   = any(LegacyEndOfSupport)
          by AssetName, AssetLabel, FindingName


        // Step 5  Build a unified Properties bag for simpler lookups
        // finding holds the full finding node properties
        // raw holds rawData if present otherwise an empty object
        // edge holds combined edge properties from all related edges
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAll)
            )


        // Step 6  Extract scoring and filter to CVE findings
        // Impact is derived from multiple possible cvss locations
        // Severity comes from raw severity
        // Only findings where FindingLabel contains CVE are kept
        | extend Impact = todouble(coalesce(
                Properties.raw.cvssScore,
                Properties.finding.raw.cvssScore,
                Properties.raw.cvss.cvssScore
            ))
        | extend SecuritySeverity = tostring(Properties.raw.severity)
        | where FindingLabel contains "CVE"


        // Step 7  Extract exploit related booleans from multiple locations
        | extend HasExploit = tobool(coalesce(
            Properties.finding.rawData.hasExploit,
            Properties.raw.hasExploit,
            Properties.finding.raw.hasExploit
        ))
        | extend IsExploitVerified = tobool(coalesce(
            Properties.finding.rawData.isExploitVerified,
            Properties.raw.isExploitVerified,
            Properties.finding.raw.isExploitVerified
        ))
        | extend IsInExploitKit = tobool(coalesce(
            Properties.finding.rawData.isInExploitKit,
            Properties.raw.isInExploitKit,
            Properties.finding.raw.isInExploitKit
        ))
        | extend IsZeroDay = tobool(coalesce(
            Properties.finding.rawData.isZeroDay,
            Properties.raw.isZeroDay,
            Properties.finding.raw.isZeroDay
        ))


        // Step 8  Compute risk factor scores at row level and build detailed strings
        // RiskFactor_Consequence is defaulted to 0 for compatibility
        // RiskFactor_Probability is a 0 to 3 score
        // Add 1 if any exploit signal is true
        // Add 1 if the asset is customer facing
        // Add 1 if the asset is legacy end-of-support
        // RiskFactor_Probability_Detailed is a semicolon separated list of factor names
        // RiskFactor_Probability_DetailedScore is a semicolon separated key value string of sub scores
        | extend RiskFactor_Consequence = 0
        | extend RF_P_ExploitSignals =
            iff(HasExploit == true or IsExploitVerified == true or IsInExploitKit == true or IsZeroDay == true, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_ExploitSignals + RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_ExploitSignals == 1,   dynamic(["ExploitSignals"]), dynamic([])),
                    iff(RF_P_InternetExposed == 1,  dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,        dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "ExploitSignals=", tostring(RF_P_ExploitSignals), ";",
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )


        // Step 9  Compute criticality tier with fallback to tags
        // CriticalityTierFromTag maps tier tags to a numeric tier
        // CriticalityTier prefers CriticalityLevel
        // If CriticalityLevel is missing then tier tags are used
        // If both are missing then default is 3
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - unmapped"
            )


        // Step 10  Set fixed classification fields for the report output
        | extend SecurityDomain = "Endpoint"
        | extend ConfigurationName = "Update vulnerable software"
        | extend ConfigurationId = "CVE"
        | extend Category    = "Vulnerabilities"
        | extend Subcategory = "CVEs (Missing Updates)"


        // Step 11  Filter out recently updated CVEs
        // last modified is extracted from two possible locations
        | extend CVELastModified = todatetime(coalesce(Properties.finding.raw.lastModifiedDate, Properties.raw.lastModifiedDate))
        | where CVELastModified < ago(40d)


        // Step 12  Build device key used for distinct counting
        // Prefer AadDeviceId when present otherwise fall back to AssetName
        | extend DeviceKey = iif(isnotempty(AadDeviceId), AadDeviceId, AssetName)


        // Step 13  Aggregate to report level
        // Risk factors use max so the group reflects the highest score observed
        // Detailed columns use any to keep string output compatible with CSV and Excel
        | summarize
            AssetCount      = dcount(DeviceKey),
            TotalIssues     = count(),
            AvgImpact       = avg(Impact),
            MaxImpact       = max(Impact),
            ImpactedAssets  = make_set(AssetName),
            SampleCVEs      = make_set(FindingLabel),
            RiskFactor_Consequence = max(RiskFactor_Consequence),
            RiskFactor_Probability = max(RiskFactor_Probability),
            RiskFactor_Probability_Detailed = any(RiskFactor_Probability_Detailed),
            RiskFactor_Probability_DetailedScore = any(RiskFactor_Probability_DetailedScore)
          by SecurityDomain, Category, Subcategory, ConfigurationName, ConfigurationId, CriticalityTier, CriticalityTierLevel, SecuritySeverity


        // Step 14  Final shape and sorting
        | project
            SecurityDomain,
            Category,
            Subcategory,
            ConfigurationName,
            ConfigurationId,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            AvgImpact = round(AvgImpact, 1),
            MaxImpact = toint(ceiling(MaxImpact)),
            ImpactedAssets,
            SampleCVEs
        | order by CriticalityTier asc, MaxImpact desc, AvgImpact desc, AssetCount desc, TotalIssues desc
                
  - ReportName: Device_Missing_CVEs_Detailed
    ReportPurpose: This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AadDeviceId"
      - "CVELastModified"
      - "CVSSDesc"
      - "CVE_ID"
      - "CriticalityRuleBased"
      - "CriticalityRuleNames"
      - "CriticalityLevel"
      - "AssetTierByTag"
      - "AssetTags"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report Purpose
        // This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.

        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 1  Build asset list for endpoints and keep existing risk flags
        // Only Endpoint assets are included
        // Customer facing and excluded flags are normalized from rawData or raw
        // Excluded assets are filtered out early
        // Existing criticality fields are kept as-is
        // Asset tags are collected from multiple rawData locations and combined into one list
        // AssetTags is a semicolon separated string of all tags
        // AssetTierByTag is extracted from AssetTags using regex and sorted for stable output
        // LegacyEndOfSupport is derived from AssetProps rawData OS fields when present
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))
            | where EG_IsExcluded == false
            | extend CriticalityLevel = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
            , CriticalityRuleBased = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
            , CriticalityRuleNames = coalesce(
                strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
            , AadDeviceId = tostring(coalesce(
                NodeProperties.rawData.aadDeviceId,
                NodeProperties.raw.aadDeviceId,
                NodeProperties.aadDeviceId
            ))
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend
                deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
                deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
                tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
            | extend AssetTags = strcat_array(_AllTags, ";")
            | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
            | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
            | extend NodeAssetTags = _AllTags
            | extend AssetOSPlatform = tostring(coalesce(NoderawData.osPlatform, NoderawData.OSPlatform, NoderawData.platform, NoderawData.operatingSystem, NoderawData.os))
            | extend AssetOSVersion  = tostring(coalesce(NoderawData.osVersion,  NoderawData.OSVersion,  NoderawData.version,  NoderawData.operatingSystemVersion))
            | extend AssetOSDistribution = tostring(coalesce(NoderawData.osDistribution, NoderawData.OSDistribution, NoderawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))
            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux = iff(
                tolower(AssetOSPlatform) has "linux"
                and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                1, 0
              )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                AadDeviceId,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                NodeAssetTags,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport;


        // Step 2  Build finding list
        // Categories is expanded to allow filtering on any category value
        // Only nodes with a category containing finding are included
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges with labels containing affecting are used
        // Edge properties are included when present otherwise an empty object is used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        // Both directions are needed because source and target can be swapped
        // The union is later de-duplicated using summarize by asset and finding identifiers
        let AF_edges_oneway =
            Edges
            | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges_otherway =
            Edges
            | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges = union AF_edges_oneway, AF_edges_otherway;


        // Step 5  De-duplicate and merge edge properties
        AF_edges
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAll         = make_bag(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            AadDeviceId          = any(AadDeviceId),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            NodeAssetTags        = any(NodeAssetTags),
            AssetTags            = any(AssetTags),
            AssetTierByTag       = any(AssetTierByTag),
            LegacyEndOfSupport   = any(LegacyEndOfSupport)
          by AssetName, AssetLabel, FindingName


        // Step 6  Build a unified Properties bag used for extraction
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAll)
            )


        // Step 7  Extract CVSS impact and severity and keep only CVEs
        | extend Impact = todouble(coalesce(
                Properties.raw.cvssScore,
                Properties.finding.raw.cvssScore,
                Properties.raw.cvss.cvssScore
            ))
        | extend SecuritySeverity = tostring(Properties.raw.severity)
        | where FindingLabel contains "CVE"


        // Step 8  Set fixed domain and category values for this dataset
        | extend SecurityDomain = "Endpoint"
        | extend ConfigurationId = "CVE"
        | extend Category    = "Vulnerabilities"
        | extend Subcategory = "CVEs (Missing Updates)"


        // Step 9  Filter by CVE last modified date
        | extend CVELastModified = todatetime(coalesce(Properties.finding.raw.lastModifiedDate, Properties.raw.lastModifiedDate))
        | where CVELastModified < ago(40d)


        // Step 10  Extract exploit related flags from multiple possible locations
        | extend HasExploit = tobool(coalesce(
            Properties.finding.rawData.hasExploit,
            Properties.raw.hasExploit,
            Properties.finding.raw.hasExploit
        ))
        | extend IsExploitVerified = tobool(coalesce(
            Properties.finding.rawData.isExploitVerified,
            Properties.raw.isExploitVerified,
            Properties.finding.raw.isExploitVerified
        ))
        | extend IsInExploitKit = tobool(coalesce(
            Properties.finding.rawData.isInExploitKit,
            Properties.raw.isInExploitKit,
            Properties.finding.raw.isInExploitKit
        ))
        | extend IsZeroDay = tobool(coalesce(
            Properties.finding.rawData.isZeroDay,
            Properties.raw.isZeroDay,
            Properties.finding.raw.isZeroDay
        ))


        // Step 11  Compute risk factor fields and detailed strings
        // RiskFactor_Consequence is defaulted to 0
        // RiskFactor_Probability is a 0 to 3 score
        // Add 1 when any exploit signal is present
        // Add 1 when the asset is customer facing
        // Add 1 when the asset is legacy end-of-support
        | extend RiskFactor_Consequence = 0
        | extend RF_P_ExploitSignals =
            iff(HasExploit == true or IsExploitVerified == true or IsInExploitKit == true or IsZeroDay == true, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_ExploitSignals + RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_ExploitSignals == 1,   dynamic(["ExploitSignals"]), dynamic([])),
                    iff(RF_P_InternetExposed == 1,  dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,        dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "ExploitSignals=", tostring(RF_P_ExploitSignals), ";",
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )


        // Step 12  Compute criticality tier with fallback to tier tags
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - unmapped"
            )


        // Step 13  Extra safety filter to ensure excluded assets do not appear
        | where EG_IsExcluded == false


        // Step 14  Final projection and ordering for detailed output
        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName,
            AssetLabel,
            AadDeviceId,
            EG_IsCustomerFacing,
            EG_IsExcluded,

            ConfigurationName = FindingName,
            CVE_ID = FindingLabel,
            ConfigurationId,

            CriticalityLevel,
            CriticalityRuleBased,
            CriticalityRuleNames,
            CriticalityTier,
            CriticalityTierLevel,

            AssetTierByTag,
            AssetTags,
            LegacyEndOfSupport,

            Impact,
            SecuritySeverity,
            CVELastModified,

            HasExploit,
            IsExploitVerified,
            IsInExploitKit,
            IsZeroDay,

            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,

            CVSSDesc = tostring(coalesce(
                Properties.finding.rawData.description,
                Properties.raw.description,
                Properties.finding.raw.description
            )),
            AssetProps,
            Properties
        | order by CriticalityTier asc, Impact desc, AssetName asc, CVE_ID asc

  - ReportName: Device_Missing_CVEs_Detailed_BucketFilter
    ReportPurpose: This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AadDeviceId"
      - "CVELastModified"
      - "CVSSDesc"
      - "CVE_ID"
      - "CriticalityRuleBased"
      - "CriticalityRuleNames"
      - "CriticalityLevel"
      - "AssetTierByTag"
      - "AssetTags"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report Purpose
        // This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.

        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 1  Build asset list for endpoints and attach fields used later
        // Only Endpoint assets are included
        // Customer facing and excluded flags are normalized from rawData or raw
        // Excluded assets are filtered out early
        // Existing criticality fields are kept exactly as-is
        // Tags are collected from multiple rawData locations and combined into one list
        // AssetTags is a semicolon separated string of all tags
        // AssetTierByTag is extracted from AssetTags using regex and stable sorting
        // LegacyEndOfSupport is derived from AssetProps rawData OS fields when present
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))
            | where EG_IsExcluded == false
            | extend CriticalityLevel = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
            , CriticalityRuleBased = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
            , CriticalityRuleNames = coalesce(
                strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
            , AadDeviceId = tostring(coalesce(
                NodeProperties.rawData.aadDeviceId,
                NodeProperties.raw.aadDeviceId,
                NodeProperties.aadDeviceId
            ))
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend
                deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
                deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
                tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
            | extend AssetTags = strcat_array(_AllTags, ";")
            | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
            | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
            | extend NodeAssetTags = _AllTags
            | extend AssetOSPlatform = tostring(coalesce(NoderawData.osPlatform, NoderawData.OSPlatform, NoderawData.platform, NoderawData.operatingSystem, NoderawData.os))
            | extend AssetOSVersion  = tostring(coalesce(NoderawData.osVersion,  NoderawData.OSVersion,  NoderawData.version,  NoderawData.operatingSystemVersion))
            | extend AssetOSDistribution = tostring(coalesce(NoderawData.osDistribution, NoderawData.OSDistribution, NoderawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))
            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux = iff(
                tolower(AssetOSPlatform) has "linux"
                and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                1, 0
              )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                AadDeviceId,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                NodeAssetTags,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport;


        // Step 2  Build finding list
        // Categories is expanded to allow filtering on any category value
        // Only nodes with a category containing finding are included
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges with labels containing affecting are used
        // Edge properties are included when present otherwise an empty object is used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        // Both directions are needed because source and target can be swapped
        // The union is later de-duplicated using summarize by asset and finding identifiers
        let AF_edges_oneway =
            Edges
            | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges_otherway =
            Edges
            | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges = union AF_edges_oneway, AF_edges_otherway;


        // Step 5  De-duplicate asset to finding rows and merge edge properties
        // One row per AssetName AssetLabel FindingName is kept
        // Edge labels and edge properties across duplicates are combined
        AF_edges
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAll         = make_bag(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            AadDeviceId          = any(AadDeviceId),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            NodeAssetTags        = any(NodeAssetTags),
            AssetTags            = any(AssetTags),
            AssetTierByTag       = any(AssetTierByTag),
            LegacyEndOfSupport   = any(LegacyEndOfSupport)
          by AssetName, AssetLabel, FindingName


        // Step 6  Build a unified Properties bag for simpler lookups
        // finding holds the full finding node properties
        // raw holds rawData if present otherwise an empty object
        // edge holds combined edge properties from all related edges
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAll)
            )


        // Step 7  Extract scoring fields and filter to CVE findings
        // Impact is derived from multiple possible cvss locations
        // Severity comes from raw severity
        // Only findings where FindingLabel contains CVE are kept
        | extend Impact = todouble(coalesce(
                Properties.raw.cvssScore,
                Properties.finding.raw.cvssScore,
                Properties.raw.cvss.cvssScore
            ))
        | extend SecuritySeverity = tostring(Properties.raw.severity)
        | where FindingLabel contains "CVE"


        // Step 8  Compute criticality tier with fallback to tier tags
        // CriticalityLevel is preferred when present
        // When CriticalityLevel is missing tier tags are mapped to a numeric tier
        // When both are missing tier 3 is used as default
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - unmapped"
            )


        // Step 9  Set fixed domain and category values for this dataset
        | extend SecurityDomain = "Endpoint"
        | extend ConfigurationId = "CVE"
        | extend Category    = "Vulnerabilities"
        | extend Subcategory = "CVEs (Missing Updates)"


        // Step 10  Filter by CVE last modified date
        | extend CVELastModified = todatetime(coalesce(Properties.finding.raw.lastModifiedDate, Properties.raw.lastModifiedDate))
        | where CVELastModified < ago(40d)


        // Step 11  Extract exploit related flags from finding rawData and raw
        | extend HasExploit = tobool(coalesce(
            Properties.finding.rawData.hasExploit,
            Properties.raw.hasExploit,
            Properties.finding.raw.hasExploit
        ))
        | extend IsExploitVerified = tobool(coalesce(
            Properties.finding.rawData.isExploitVerified,
            Properties.raw.isExploitVerified,
            Properties.finding.raw.isExploitVerified
        ))
        | extend IsInExploitKit = tobool(coalesce(
            Properties.finding.rawData.isInExploitKit,
            Properties.raw.isInExploitKit,
            Properties.finding.raw.isInExploitKit
        ))
        | extend IsZeroDay = tobool(coalesce(
            Properties.finding.rawData.isZeroDay,
            Properties.raw.isZeroDay,
            Properties.finding.raw.isZeroDay
        ))


        // Step 12  Compute risk factor fields at row level and provide detailed strings
        // RiskFactor_Consequence is defaulted to 0
        // RiskFactor_Probability is a 0 to 3 score
        // Add 1 when any exploit signal is present
        // Add 1 when the asset is customer facing
        // Add 1 when the asset is legacy end-of-support
        // RiskFactor_Probability_Detailed and RiskFactor_Probability_DetailedScore are semicolon separated strings
        | extend RiskFactor_Consequence = 0
        | extend RF_P_ExploitSignals =
            iff(HasExploit == true or IsExploitVerified == true or IsInExploitKit == true or IsZeroDay == true, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_ExploitSignals + RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_ExploitSignals == 1,   dynamic(["ExploitSignals"]), dynamic([])),
                    iff(RF_P_InternetExposed == 1,  dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,        dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "ExploitSignals=", tostring(RF_P_ExploitSignals), ";",
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )


        // Step 13  Extra safety filter to ensure excluded assets do not appear
        | where EG_IsExcluded == false


        // Step 14  Bucket filter support
        // DeviceKey is used for bucket filtering and distinct counting
        | extend DeviceKey = iif(isnotempty(AadDeviceId), AadDeviceId, AssetName)
        __BUCKET_FILTER__


        // Step 15  Final projection and ordering for detailed output
        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName,
            AssetLabel,
            AadDeviceId,
            EG_IsCustomerFacing,
            EG_IsExcluded,

            ConfigurationName = FindingName,
            CVE_ID = FindingLabel,
            ConfigurationId,

            CriticalityLevel,
            CriticalityRuleBased,
            CriticalityRuleNames,
            CriticalityTier,
            CriticalityTierLevel,

            AssetTierByTag,
            AssetTags,
            LegacyEndOfSupport,

            Impact,
            SecuritySeverity,
            CVELastModified,

            HasExploit,
            IsExploitVerified,
            IsInExploitKit,
            IsZeroDay,

            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,

            CVSSDesc = tostring(coalesce(
                Properties.finding.rawData.description,
                Properties.raw.description,
                Properties.finding.raw.description
            )),
            AssetProps,
            Properties
        | order by CriticalityTier asc, Impact desc, AssetName asc, CVE_ID asc
       
  - ReportName: Device_Recommendations_Summary
    ReportPurpose: Identify non-compliant TVM secure configuration controls on endpoints, enriched with Exposure Graph criticality and risk context, and scored with a probability model that includes Internet-Exposed (from EG CustomerFacing) and LegacyEndOfSupport based on OS platform
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Identify non-compliant TVM secure configuration controls on endpoints, enriched with Exposure Graph criticality and risk context, and scored with a probability model that includes Internet-Exposed (from EG CustomerFacing) and LegacyEndOfSupport based on OS platform

        // Step 0  Define configuration IDs removed from the Windows Server scope
        // These controls do not make sense for Windows Server devices (in my opinion!)
        // They are excluded only when OSPlatform indicates Windows Server
        let excludeForWindowsServer = dynamic([
          "scid-2090",
          "scid-22"
        ]);

        // Step 1  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        // Step 2  Define legacy macOS major versions
        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        // Step 3  Define legacy Linux matchers
        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 4  Define lookup tables for short standard texts
        // If a category or subcategory is not present in these lookups, the output keeps the name and leaves description empty
        let CategoryLookup = datatable(Category:string, CategoryDescription:string)
        [
          "Security controls", "Endpoint protection and attack-surface policies that block common malware and attacker techniques.",
          "Network",           "Network security policies that limit attack surface and lateral movement.",
          "BitLocker",         "Full-disk encryption to prevent data exposure on lost or stolen devices.",
          "OS",                "Operating system baseline hardening and core protections.",
          "Credentials",       "Controls that prevent credential theft and reuse.",
          "Browser",           "Safe browsing and web threat protections.",
          "Application",       "Application control and exploit protection to restrict unauthorized code execution.",
          "Device",            "General endpoint configuration and health requirements.",
          "Audit",             "Monitoring-focused baselines to validate configuration posture."
        ];

        let SubCategoryLookup = datatable(Subcategory:string, SubCategoryDescription:string)
        [
          "EDR",                        "Defender for Endpoint sensor presence and reporting health.",
          "Attack Surface Reduction",   "Blocks common malware execution paths from email, web and Office content.",
          "Firewall",                   "Enforces inbound/outbound traffic policy and host firewall state.",
          "Antivirus",                  "Ensures Microsoft Defender Antivirus is active and properly configured.",
          "BitLocker",                  "Enforces full-disk encryption and key escrow.",
          "Exploit Guard",              "Hardens OS/apps against memory corruption and exploit chains.",
          "Authentication",             "Strengthens sign-in security and protects credential boundaries.",
          "Remote Access",              "Restricts remote shell/administrative entry points.",
          "TLS/Communication",          "Requires secure protocols and prevents crypto downgrade.",
          "Removable Storage",          "Controls external media to reduce malware risk and data exfiltration."
        ];

        // Step 5  Define query parameters
        let lookback         = 30d;
        let onlyApplicable   = true;
        let osFilter         = dynamic([]);
        let categoryFilter   = dynamic([]);
        let idFilter         = dynamic([]);
        let nameSearch       = "";
        let sortByImpactDesc = true;
        let SecurityDomain   = "Endpoint";

        // Step 6  Get latest DeviceInfo per device for enrichment
        // OSVersion and OSDistribution are included for macOS and Linux legacy detection
        let DeviceInfoLatest =
          DeviceInfo
          | where TimeGenerated >= ago(lookback)
          | summarize arg_max(TimeGenerated, *) by DeviceId
          | project
              DeviceId,
              DI_DeviceName      = DeviceName,
              DI_OSPlatform      = tostring(OSPlatform),
              DI_OSVersion       = tostring(OSVersion),
              DI_OSDistribution  = tostring(OSDistribution),
              DI_MachineGroup    = MachineGroup,
              DI_AssetValue      = tostring(AssetValue),
              DI_ExposureLevel   = tostring(ExposureLevel),
              DI_AzureResourceId = tostring(AzureResourceId),
              DI_AadDeviceId     = tostring(AadDeviceId);

        // Step 7  Build exposure graph asset table and join key
        // Tier tags are extracted from AssetTags and used as a fallback for criticality when EG criticality is missing
        let EG_Assets =
          ExposureGraphNodes
          | extend CriticalityLevel = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
              tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
          | extend EG_AadDeviceId = tostring(coalesce(
              NodeProperties.rawData.aadDeviceId,
              NodeProperties.raw.aadDeviceId,
              NodeProperties.aadDeviceId
            ))
          | extend EG_IsCustomerFacing = tobool(coalesce(
              NodeProperties.rawData.isCustomerFacing,
              NodeProperties.raw.isCustomerFacing
            ))
          | extend EG_IsExcluded = tobool(coalesce(
              NodeProperties.rawData.isExcluded,
              NodeProperties.raw.isExcluded
            ))
          | extend NoderawData = todynamic(NodeProperties).rawData
          | extend
              deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
              deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
              tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
          | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
          | extend AssetTags = strcat_array(_AllTags, ";")
          | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
          | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
          | project
              EG_AadDeviceId,
              EG_AssetName    = NodeName,
              EG_AssetLabel   = NodeLabel,
              EG_AssetProps   = NodeProperties,
              EG_CriticalityLevel = CriticalityLevel,
              EG_IsCustomerFacing,
              EG_IsExcluded,
              AssetTags,
              AssetTierByTag;

        // Step 8  Load TVM secure configuration data and KB enrichment
        // Controls listed in excludeForWindowsServer are excluded only for Windows Server devices
        let TVM_Base =
          DeviceTvmSecureConfigurationAssessment
          | where TimeGenerated >= ago(lookback)
          | where (array_length(osFilter) == 0 or OSPlatform in~ (osFilter))
          | where (array_length(idFilter) == 0 or ConfigurationId in~ (idFilter))
          | where (nameSearch == "" or tostring(DeviceName) contains nameSearch)
          | where not (OSPlatform contains "WindowsServer" and ConfigurationId in~ (excludeForWindowsServer))
          | where iff(onlyApplicable, IsApplicable == 1, true)
          | join kind=leftouter (
              DeviceTvmSecureConfigurationAssessmentKB
              | project
                  ConfigurationId,
                  KB_ConfigurationName        = ConfigurationName,
                  KB_ConfigurationCategory    = ConfigurationCategory,
                  KB_ConfigurationSubcategory = ConfigurationSubcategory,
                  KB_Impact                   = toint(ConfigurationImpact),
                  KB_RiskDescription          = tostring(RiskDescription),
                  KB_Description              = tostring(ConfigurationDescription),
                  KB_Remediation              = tostring(RemediationOptions),
                  KB_Benchmarks               = ConfigurationBenchmarks
            ) on ConfigurationId
          | where (array_length(categoryFilter) == 0 or KB_ConfigurationCategory in~ (categoryFilter))
          | extend ImpactInt = toint(coalesce(KB_Impact, toint(ConfigurationImpact)))
          | extend
              Category          = coalesce(KB_ConfigurationCategory, ConfigurationCategory),
              Subcategory       = KB_ConfigurationSubcategory,
              ConfigurationName = coalesce(KB_ConfigurationName, tostring(ConfigurationId)),
              IsCompliant       = tobool(IsCompliant),
              IsApplicable      = tobool(IsApplicable)
          | extend
              SecuritySeverity =
                  case(
                      ImpactInt == 10, "Very High",
                      ImpactInt == 9,  "High",
                      ImpactInt == 8,  "Medium-High",
                      ImpactInt >= 5,  "Medium",
                      "Low Risk"
                  ),
              SortKey = iff(sortByImpactDesc, todouble(ImpactInt), 0.0)
          | summarize arg_max(TimeGenerated, *) by DeviceId, ConfigurationId
          | where IsCompliant == false
          // Category and Subcategory descriptions are optional
          // Unknown categories keep the name and return an empty description
          | lookup CategoryLookup on Category
          | lookup SubCategoryLookup on Subcategory
          | extend
              CategoryDescription    = coalesce(CategoryDescription, ""),
              SubCategoryDescription = coalesce(SubCategoryDescription, "");

        // Step 9  Enrich TVM findings with DeviceInfo and Exposure Graph metadata
        // Excluded exposure graph assets are filtered out
        // CriticalityTier prefers EG criticality and falls back to tier tags if missing
        TVM_Base
        | join kind=leftouter (DeviceInfoLatest) on DeviceId
        | join kind=leftouter (
            EG_Assets
            | where isnotempty(EG_AadDeviceId)
        ) on $left.DI_AadDeviceId == $right.EG_AadDeviceId
        | where EG_IsExcluded == false

        | extend CriticalityTierFromTag =
            case(
              AssetTierByTag has "--tier0--SI", 0,
              AssetTierByTag has "--tier1--SI", 1,
              AssetTierByTag has "--tier2--SI", 2,
              AssetTierByTag has "--tier3--SI", 3,
              int(null)
            )
        | extend Criticality = toint(coalesce(EG_CriticalityLevel, CriticalityTierFromTag))
        | where isnotempty(Criticality)

        | extend SecurityDomain = SecurityDomain
        | extend CriticalityTier = toint(Criticality)
        | extend CriticalityTierLevel =
            case(
              CriticalityTier == 3, "Low - tier 3",
              CriticalityTier == 2, "Medium - tier 2",
              CriticalityTier == 1, "High - tier 1",
              CriticalityTier == 0, "Critical - tier 0",
              "Unknown - unmapped"
            )

        // Step 10  Detect legacy end-of-support operating systems
        // Windows legacy uses DI_OSPlatform list
        // macOS legacy uses major version from DI_OSVersion
        // Linux legacy uses substring matching against DI_OSDistribution and DI_OSVersion
        | extend MacMajor = toint(extract(@"^(\d+)", 1, DI_OSVersion))
        | extend IsLegacyWindows = iff(DI_OSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
        | extend IsLegacyMacOS = iff(tolower(DI_OSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
        | extend IsLegacyLinux = iff(
              tolower(DI_OSPlatform) has "linux"
              and (DI_OSDistribution has_any (LegacyLinuxMatchers) or DI_OSVersion has_any (LegacyLinuxMatchers)),
              1, 0
          )
        | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

        // Step 11  Compute risk factor fields and detailed explanation columns
        // RiskFactor_Probability is additive
        // +1 Internet-Exposed based on graph customer facing signal
        // +1 LegacyEndOfSupport when OS is treated as legacy
        // Detailed columns are exported as strings with semicolon separators
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = LegacyEndOfSupport
        | extend RiskFactor_Consequence = 0
        | extend RiskFactor_Probability = RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,       dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )

        // Step 12  Summarize to report level by configuration and tier
        // RiskFactor_Probability uses max so the group reflects the highest score observed
        // Detailed columns use any to keep string output compatible with CSV and Excel exports
        | summarize
            AssetCount     = dcount(DeviceId),
            TotalIssues    = count(),
            ImpactedAssets = make_set(coalesce(DI_DeviceName, DeviceName)),
            RiskFactor_Probability = toint(max(RiskFactor_Probability)),
            RiskFactor_Consequence = toint(max(RiskFactor_Consequence)),
            LegacyEndOfSupport = max(LegacyEndOfSupport),
            RiskFactor_Probability_Detailed = any(RiskFactor_Probability_Detailed),
            RiskFactor_Probability_DetailedScore = any(RiskFactor_Probability_DetailedScore)
          by
            SecurityDomain,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            CriticalityTier,
            CriticalityTierLevel,
            Impact = ImpactInt,
            SecuritySeverity,
            ConfigurationName,
            ConfigurationId

        // Step 13  Final projection and sorting
        | project
            SecurityDomain,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            ConfigurationName,
            ConfigurationId,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity,
            Impact,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            LegacyEndOfSupport,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by CriticalityTier asc, Impact desc, TotalIssues desc, AssetCount desc, ConfigurationId asc
        

  - ReportName: Device_Recommendations_Detailed
    ReportPurpose: Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tags, and add a probability score based on Internet-Exposed (EG CustomerFacing) and LegacyEndOfSupport OS detection
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tags, and add a probability score based on Internet-Exposed (EG CustomerFacing) and LegacyEndOfSupport OS detection

        // Step 0  Define configuration IDs removed from the Windows Server scope
        // These controls do not make sense for Windows Server devices (in my opinion!)
        // They are excluded only when OSPlatform indicates Windows Server
        let excludeForWindowsServer = dynamic([
          "scid-2090",
          "scid-22"
        ]);

        // Step 1  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 2  Lookup tables (short standard texts)
        // If a new Category or Subcategory appears, it is kept but the description is blank
        let CategoryLookup = datatable(Category:string, CategoryDescription:string)
        [
          "Security controls", "Endpoint protection and attack-surface policies that block common malware and attacker techniques.",
          "Network",           "Network security policies that limit attack surface and lateral movement.",
          "BitLocker",         "Full-disk encryption to prevent data exposure on lost or stolen devices.",
          "OS",                "Operating system baseline hardening and core protections.",
          "Credentials",       "Controls that prevent credential theft and reuse.",
          "Browser",           "Safe browsing and web threat protections.",
          "Application",       "Application control and exploit protection to restrict unauthorized code execution.",
          "Device",            "General endpoint configuration and health requirements.",
          "Audit",             "Monitoring-focused baselines to validate configuration posture."
        ];

        let SubCategoryLookup = datatable(Subcategory:string, SubCategoryDescription:string)
        [
          "EDR",                        "Defender for Endpoint sensor presence and reporting health.",
          "Attack Surface Reduction",   "Blocks common malware execution paths from email, web and Office content.",
          "Firewall",                   "Enforces inbound/outbound traffic policy and host firewall state.",
          "Antivirus",                  "Ensures Microsoft Defender Antivirus is active and properly configured.",
          "BitLocker",                  "Enforces full-disk encryption and key escrow.",
          "Exploit Guard",              "Hardens OS/apps against memory corruption and exploit chains.",
          "Authentication",             "Strengthens sign-in security and protects credential boundaries.",
          "Remote Access",              "Restricts remote shell/administrative entry points.",
          "TLS/Communication",          "Requires secure protocols and prevents crypto downgrade.",
          "Removable Storage",          "Controls external media to reduce malware risk and data exfiltration."
        ];

        // Step 3  Parameters
        let lookback         = 30d;
        let onlyApplicable   = true;
        let osFilter         = dynamic([]);
        let categoryFilter   = dynamic([]);
        let idFilter         = dynamic([]);
        let nameSearch       = "";
        let sortByImpactDesc = true;
        let SecurityDomain   = "Endpoint";

        // Step 4  DeviceInfo (latest)
        // OSVersion is optional in some schemas so it is pulled using column_ifexists
        let DeviceInfoLatest =
          DeviceInfo
          | where TimeGenerated >= ago(lookback)
          | summarize arg_max(TimeGenerated, *) by DeviceId
          | project
              DeviceId,
              DI_DeviceName      = DeviceName,
              DI_OSPlatform      = OSPlatform,
              DI_OSVersion       = tostring(column_ifexists("OSVersion", "")),
              DI_MachineGroup    = MachineGroup,
              DI_AssetValue      = tostring(AssetValue),
              DI_ExposureLevel   = tostring(ExposureLevel),
              DI_AzureResourceId = tostring(AzureResourceId),
              DI_AadDeviceId     = tostring(AadDeviceId);

        // Step 5  Exposure Graph assets (endpoints) joined via aadDeviceId
        // Asset tags are normalized from multiple rawData locations
        // AssetTierByTag lists tags containing --tier and --SI, separated with ;
        // Criticality tier prefers EG_CriticalityLevel and falls back to tier tags when missing
        let EG_Assets =
          ExposureGraphNodes
          | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
          | extend EG_CriticalityLevel = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
              tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
          , EG_CriticalityRuleBased = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
              tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
          , EG_CriticalityRuleNames = coalesce(
              strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
              strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
          | extend EG_AadDeviceId = tostring(coalesce(
              NodeProperties.rawData.aadDeviceId,
              NodeProperties.raw.aadDeviceId,
              NodeProperties.aadDeviceId
            ))
          | extend EG_IsCustomerFacing = tobool(coalesce(
              NodeProperties.rawData.isCustomerFacing,
              NodeProperties.raw.isCustomerFacing
            ))
          | extend EG_IsExcluded = tobool(coalesce(
              NodeProperties.rawData.isExcluded,
              NodeProperties.raw.isExcluded
            ))
          | extend NoderawData = todynamic(NodeProperties).rawData
          | extend
              deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
              deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
              tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
          | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
          | extend AssetTags = strcat_array(_AllTags, ";")
          | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
          | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
          | extend CriticalityTierFromTag =
              case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
              )
          | extend EG_CriticalityTier = toint(coalesce(EG_CriticalityLevel, CriticalityTierFromTag, int(null)))
          | project
              EG_AadDeviceId,
              EG_AssetName    = NodeName,
              EG_AssetLabel   = NodeLabel,
              EG_AssetProps   = NodeProperties,
              EG_CriticalityLevel,
              EG_CriticalityRuleBased,
              EG_CriticalityRuleNames,
              EG_CriticalityTier,
              EG_IsCustomerFacing,
              EG_IsExcluded,
              AssetTags,
              AssetTierByTag;

        // Step 6  TVM secure configuration assessment core dataset
        let TVM_Base =
          DeviceTvmSecureConfigurationAssessment
          | where TimeGenerated >= ago(lookback)
          | where (array_length(osFilter) == 0 or OSPlatform in~ (osFilter))
          | where (array_length(idFilter) == 0 or ConfigurationId in~ (idFilter))
          | where (nameSearch == "" or tostring(DeviceName) contains nameSearch)
          | where not (OSPlatform contains "WindowsServer" and ConfigurationId in~ (excludeForWindowsServer))
          | where iff(onlyApplicable, IsApplicable == 1, true)
          | join kind=leftouter (
              DeviceTvmSecureConfigurationAssessmentKB
              | project
                  ConfigurationId,
                  KB_ConfigurationName        = ConfigurationName,
                  KB_ConfigurationCategory    = ConfigurationCategory,
                  KB_ConfigurationSubcategory = ConfigurationSubcategory,
                  KB_Impact                   = toint(ConfigurationImpact),
                  KB_RiskDescription          = tostring(RiskDescription),
                  KB_Description              = tostring(ConfigurationDescription),
                  KB_Remediation              = tostring(RemediationOptions),
                  KB_Benchmarks               = ConfigurationBenchmarks
            ) on ConfigurationId
          | where (array_length(categoryFilter) == 0 or KB_ConfigurationCategory in~ (categoryFilter))
          | extend ImpactInt = toint(coalesce(KB_Impact, toint(ConfigurationImpact)))
          | extend
              Category          = coalesce(KB_ConfigurationCategory, ConfigurationCategory),
              Subcategory       = KB_ConfigurationSubcategory,
              ConfigurationName = coalesce(KB_ConfigurationName, tostring(ConfigurationId)),
              IsCompliant       = tobool(IsCompliant),
              IsApplicable      = tobool(IsApplicable)
          | extend
              RecommendedAction =
                  case(
                      ImpactInt >= 9, "Fix immediately - Security Change Queue / Intune / GPO rollout",
                      ImpactInt == 8, "Schedule within quarterly hardening cycle",
                      ImpactInt >= 5 and ImpactInt < 8, "Fix opportunistically (during upgrades / refresh)",
                      "Monitor, document as baseline exceptions"
                  ),
              SecuritySeverity =
                  case(
                      ImpactInt == 10, "Very High",
                      ImpactInt == 9,  "High",
                      ImpactInt == 8,  "Medium-High",
                      ImpactInt >= 5,  "Medium",
                      "Low Risk"
                  ),
              SecuritySeverityDescription =
                  case(
                      ImpactInt == 10, "If this configuration is not applied, attackers gain a major foothold or common attack vector remains wide open.",
                      ImpactInt == 9,  "Strongly recommended to fix ASAP; commonly exploited by real-world malware and ransomware.",
                      ImpactInt == 8,  "Important baseline security hardening; reduces attack surface and lateral movement.",
                      ImpactInt >= 5,  "Security best practice; helps reduce exposure but less frequently exploited.",
                      "Hardening / hygiene controls; helps, but attackers less likely to target."
                  ),
              SortKey = iff(sortByImpactDesc, todouble(ImpactInt), 0.0)
          | summarize arg_max(TimeGenerated, *) by DeviceId, ConfigurationId
          | where IsCompliant == false
          | lookup CategoryLookup on Category
          | lookup SubCategoryLookup on Subcategory
          | extend
              CategoryDescription    = iff(isnotempty(CategoryDescription), CategoryDescription, ""),
              SubCategoryDescription = iff(isnotempty(SubCategoryDescription), SubCategoryDescription, "");

        // Step 7  Enrich with DeviceInfo and Exposure Graph, compute tier and risk factors
        // RiskFactor_Probability increments for Internet-Exposed and LegacyEndOfSupport
        // RiskFactor_Probability_Detailed and RiskFactor_Probability_DetailedScore are semicolon separated strings
        TVM_Base
        | join kind=leftouter (DeviceInfoLatest) on DeviceId
        | join kind=leftouter (
            EG_Assets
            | where isnotempty(EG_AadDeviceId)
          ) on $left.DI_AadDeviceId == $right.EG_AadDeviceId
        | where EG_IsExcluded == false
        | extend CriticalityTier = toint(EG_CriticalityTier)
        | where isnotempty(CriticalityTier)
        | extend CriticalityTierLevel =
            case(
              CriticalityTier == 3, "Low - tier 3",
              CriticalityTier == 2, "Medium - tier 2",
              CriticalityTier == 1, "High - tier 1",
              CriticalityTier == 0, "Critical - tier 0",
              "Unknown - unmapped"
            )
        | extend OSPlatformNorm = coalesce(DI_OSPlatform, OSPlatform)
        | extend OSVersionNorm  = coalesce(DI_OSVersion, "")
        | extend MacMajor = toint(extract(@"^(\d+)", 1, OSVersionNorm))
        | extend IsLegacyWindows = iff(OSPlatformNorm in~ (LegacyWindowsOSPlatforms), 1, 0)
        | extend IsLegacyMacOS = iff(tolower(OSPlatformNorm) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
        | extend IsLegacyLinux = iff(
            tolower(OSPlatformNorm) has "linux"
            and (OSPlatformNorm has_any (LegacyLinuxMatchers) or OSVersionNorm has_any (LegacyLinuxMatchers)),
            1, 0
          )
        | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
              array_concat(
                iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
              ),
              ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
              "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
              "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )
        | extend RiskFactor_Consequence = 0
        | extend SecurityDomain = SecurityDomain
        | extend
            AssetName  = coalesce(DI_DeviceName, DeviceName),
            AssetLabel = EG_AssetLabel
        | project
            TimeGenerated,
            SecurityDomain,
            AssetName,
            AssetLabel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            LegacyEndOfSupport,
            DeviceId,
            DeviceName           = coalesce(DI_DeviceName, DeviceName),
            OSPlatform           = OSPlatformNorm,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            ConfigurationId,
            ConfigurationName,
            CriticalityTier,
            CriticalityTierLevel,
            Impact               = ImpactInt,
            SecuritySeverity,
            SecuritySeverityDescription,
            RecommendedAction,
            RiskDescription      = KB_RiskDescription,
            ConfigurationDescription = KB_Description,
            RemediationOptions   = KB_Remediation,
            Benchmarks           = KB_Benchmarks,
            EG_IsCustomerFacing,
            EG_IsExcluded,
            IsApplicable,
            IsCompliant,
            DI_MachineGroup,
            DI_AssetValue,
            DI_ExposureLevel,
            DI_AzureResourceId,
            DI_AadDeviceId,
            EG_AssetName,
            EG_AssetLabel,
            EG_CriticalityRuleBased,
            EG_CriticalityRuleNames,
            AssetTags,
            AssetTierByTag,
            EG_AssetProps
        | order by CriticalityTier asc, Impact desc, AssetName asc, ConfigurationId asc

  - ReportName: Device_Recommendations_Detailed_BucketFilter
    ReportPurpose: Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tags, and add a probability score based on Internet-Exposed (EG CustomerFacing) and LegacyEndOfSupport OS detection
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tier tags, and add a probability score based on Internet-Exposed (from EG CustomerFacing) and LegacyEndOfSupport OS detection

        // Step 0  Define configuration IDs removed from the Windows Server scope
        // These controls do not make sense for Windows Server devices (in my opinion!)
        // They are excluded only when OSPlatform indicates Windows Server
        let excludeForWindowsServer = dynamic([
          "scid-2090",
          "scid-22"
        ]);

        // Step 1  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 2  Lookup tables (short standard texts)
        // If a new Category or Subcategory appears, it is kept but the description is blank
        let CategoryLookup = datatable(Category:string, CategoryDescription:string)
        [
          "Security controls", "Endpoint protection and attack-surface policies that block common malware and attacker techniques.",
          "Network",           "Network security policies that limit attack surface and lateral movement.",
          "BitLocker",         "Full-disk encryption to prevent data exposure on lost or stolen devices.",
          "OS",                "Operating system baseline hardening and core protections.",
          "Credentials",       "Controls that prevent credential theft and reuse.",
          "Browser",           "Safe browsing and web threat protections.",
          "Application",       "Application control and exploit protection to restrict unauthorized code execution.",
          "Device",            "General endpoint configuration and health requirements.",
          "Audit",             "Monitoring-focused baselines to validate configuration posture."
        ];

        let SubCategoryLookup = datatable(Subcategory:string, SubCategoryDescription:string)
        [
          "EDR",                        "Defender for Endpoint sensor presence and reporting health.",
          "Attack Surface Reduction",   "Blocks common malware execution paths from email, web and Office content.",
          "Firewall",                   "Enforces inbound/outbound traffic policy and host firewall state.",
          "Antivirus",                  "Ensures Microsoft Defender Antivirus is active and properly configured.",
          "BitLocker",                  "Enforces full-disk encryption and key escrow.",
          "Exploit Guard",              "Hardens OS/apps against memory corruption and exploit chains.",
          "Authentication",             "Strengthens sign-in security and protects credential boundaries.",
          "Remote Access",              "Restricts remote shell/administrative entry points.",
          "TLS/Communication",          "Requires secure protocols and prevents crypto downgrade.",
          "Removable Storage",          "Controls external media to reduce malware risk and data exfiltration."
        ];

        // Step 3  Parameters
        let lookback         = 30d;
        let onlyApplicable   = true;
        let osFilter         = dynamic([]);
        let categoryFilter   = dynamic([]);
        let idFilter         = dynamic([]);
        let nameSearch       = "";
        let sortByImpactDesc = true;
        let SecurityDomain   = "Endpoint";

        // Step 4  DeviceInfo (latest)
        // OSVersion is optional in some schemas so it is pulled using column_ifexists
        let DeviceInfoLatest =
          DeviceInfo
          | where TimeGenerated >= ago(lookback)
          | summarize arg_max(TimeGenerated, *) by DeviceId
          | project
              DeviceId,
              DI_DeviceName      = DeviceName,
              DI_OSPlatform      = OSPlatform,
              DI_OSVersion       = tostring(column_ifexists("OSVersion", "")),
              DI_MachineGroup    = MachineGroup,
              DI_AssetValue      = tostring(AssetValue),
              DI_ExposureLevel   = tostring(ExposureLevel),
              DI_AzureResourceId = tostring(AzureResourceId),
              DI_AadDeviceId     = tostring(AadDeviceId);

        // Step 5  Exposure Graph endpoint assets joined via aadDeviceId
        // AssetTags combines tags found in multiple rawData locations
        // AssetTierByTag contains tags including --tier and --SI, separated with ;
        // Criticality tier prefers EG criticality level and falls back to tier tags when missing
        let EG_Assets =
          ExposureGraphNodes
          | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
          | extend EG_CriticalityLevel = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
              tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
          , EG_CriticalityRuleBased = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
              tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
          , EG_CriticalityRuleNames = coalesce(
              strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
              strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
          | extend EG_AadDeviceId = tostring(coalesce(
              NodeProperties.rawData.aadDeviceId,
              NodeProperties.raw.aadDeviceId,
              NodeProperties.aadDeviceId
            ))
          | extend EG_IsCustomerFacing = tobool(coalesce(
              NodeProperties.rawData.isCustomerFacing,
              NodeProperties.raw.isCustomerFacing
            ))
          | extend EG_IsExcluded = tobool(coalesce(
              NodeProperties.rawData.isExcluded,
              NodeProperties.raw.isExcluded
            ))
          | extend NoderawData = todynamic(NodeProperties).rawData
          | extend
              deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
              deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
              tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
          | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
          | extend AssetTags = strcat_array(_AllTags, ";")
          | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
          | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
          | extend CriticalityTierFromTag =
              case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
              )
          | extend EG_CriticalityTier = toint(coalesce(EG_CriticalityLevel, CriticalityTierFromTag, int(null)))
          | project
              EG_AadDeviceId,
              EG_AssetName    = NodeName,
              EG_AssetLabel   = NodeLabel,
              EG_AssetProps   = NodeProperties,
              EG_CriticalityLevel,
              EG_CriticalityRuleBased,
              EG_CriticalityRuleNames,
              EG_CriticalityTier,
              EG_IsCustomerFacing,
              EG_IsExcluded,
              AssetTags,
              AssetTierByTag;

        // Step 6  TVM secure configuration assessment core dataset
        // Latest row per DeviceId and ConfigurationId
        let TVM_Base =
          DeviceTvmSecureConfigurationAssessment
          | where TimeGenerated >= ago(lookback)
          | where (array_length(osFilter) == 0 or OSPlatform in~ (osFilter))
          | where (array_length(idFilter) == 0 or ConfigurationId in~ (idFilter))
          | where (nameSearch == "" or tostring(DeviceName) contains nameSearch)
          | where not (OSPlatform contains "WindowsServer" and ConfigurationId in~ (excludeForWindowsServer))
          | where iff(onlyApplicable, IsApplicable == 1, true)
          | join kind=leftouter (
              DeviceTvmSecureConfigurationAssessmentKB
              | project
                  ConfigurationId,
                  KB_ConfigurationName        = ConfigurationName,
                  KB_ConfigurationCategory    = ConfigurationCategory,
                  KB_ConfigurationSubcategory = ConfigurationSubcategory,
                  KB_Impact                   = toint(ConfigurationImpact),
                  KB_RiskDescription          = tostring(RiskDescription),
                  KB_Description              = tostring(ConfigurationDescription),
                  KB_Remediation              = tostring(RemediationOptions),
                  KB_Benchmarks               = ConfigurationBenchmarks
            ) on ConfigurationId
          | where (array_length(categoryFilter) == 0 or KB_ConfigurationCategory in~ (categoryFilter))
          | extend ImpactInt = toint(coalesce(KB_Impact, toint(ConfigurationImpact)))
          | extend
              Category          = coalesce(KB_ConfigurationCategory, ConfigurationCategory),
              Subcategory       = KB_ConfigurationSubcategory,
              ConfigurationName = coalesce(KB_ConfigurationName, tostring(ConfigurationId)),
              IsCompliant       = tobool(IsCompliant),
              IsApplicable      = tobool(IsApplicable)
          | extend
              RecommendedAction =
                  case(
                      ImpactInt >= 9, "Fix immediately - Security Change Queue / Intune / GPO rollout",
                      ImpactInt == 8, "Schedule within quarterly hardening cycle",
                      ImpactInt >= 5 and ImpactInt < 8, "Fix opportunistically (during upgrades / refresh)",
                      "Monitor, document as baseline exceptions"
                  ),
              SecuritySeverity =
                  case(
                      ImpactInt == 10, "Very High",
                      ImpactInt == 9,  "High",
                      ImpactInt == 8,  "Medium-High",
                      ImpactInt >= 5,  "Medium",
                      "Low Risk"
                  ),
              SecuritySeverityDescription =
                  case(
                      ImpactInt == 10, "If this configuration is not applied, attackers gain a major foothold or common attack vector remains wide open.",
                      ImpactInt == 9,  "Strongly recommended to fix ASAP; commonly exploited by real-world malware and ransomware.",
                      ImpactInt == 8,  "Important baseline security hardening; reduces attack surface and lateral movement.",
                      ImpactInt >= 5,  "Security best practice; helps reduce exposure but less frequently exploited.",
                      "Hardening / hygiene controls; helps, but attackers less likely to target."
                  ),
              SortKey = iff(sortByImpactDesc, todouble(ImpactInt), 0.0)
          | summarize arg_max(TimeGenerated, *) by DeviceId, ConfigurationId
          | where IsCompliant == false
          | lookup CategoryLookup on Category
          | lookup SubCategoryLookup on Subcategory
          | extend
              CategoryDescription    = iff(isnotempty(CategoryDescription), CategoryDescription, ""),
              SubCategoryDescription = iff(isnotempty(SubCategoryDescription), SubCategoryDescription, "");

        // Step 7  Enrich with DeviceInfo and Exposure Graph, compute tiers and risk factors
        // RiskFactor_Probability increments for Internet-Exposed and LegacyEndOfSupport
        // RiskFactor_Probability_Detailed and RiskFactor_Probability_DetailedScore are semicolon separated strings
        TVM_Base
        | join kind=leftouter (DeviceInfoLatest) on DeviceId
        | join kind=leftouter (
            EG_Assets
            | where isnotempty(EG_AadDeviceId)
          ) on $left.DI_AadDeviceId == $right.EG_AadDeviceId
        | where EG_IsExcluded == false

        // Tier logic uses EG criticality first and falls back to tier tags inside EG_Assets
        | extend CriticalityTier = toint(EG_CriticalityTier)
        | where isnotempty(CriticalityTier)
        | extend CriticalityTierLevel =
            case(
              CriticalityTier == 3, "Low - tier 3",
              CriticalityTier == 2, "Medium - tier 2",
              CriticalityTier == 1, "High - tier 1",
              CriticalityTier == 0, "Critical - tier 0",
              "Unknown - unmapped"
            )

        // LegacyEndOfSupport detection is based on DeviceInfo OSPlatform and OSVersion (when present)
        | extend OSPlatformNorm = coalesce(DI_OSPlatform, OSPlatform)
        | extend OSVersionNorm  = coalesce(DI_OSVersion, "")
        | extend MacMajor = toint(extract(@"^(\d+)", 1, OSVersionNorm))
        | extend IsLegacyWindows = iff(OSPlatformNorm in~ (LegacyWindowsOSPlatforms), 1, 0)
        | extend IsLegacyMacOS = iff(tolower(OSPlatformNorm) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
        | extend IsLegacyLinux = iff(
            tolower(OSPlatformNorm) has "linux"
            and (OSPlatformNorm has_any (LegacyLinuxMatchers) or OSVersionNorm has_any (LegacyLinuxMatchers)),
            1, 0
          )
        | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

        // RiskFactor_Probability model
        // Internet-Exposed is derived from Exposure Graph CustomerFacing
        // LegacyEndOfSupport adds an additional point
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
              array_concat(
                iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
              ),
              ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
              "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
              "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )

        // Keep consequence defaulted to 0
        | extend RiskFactor_Consequence = 0

        // Normalize output names and apply bucket filter
        | extend SecurityDomain = SecurityDomain
        | extend
            AssetName  = coalesce(DI_DeviceName, DeviceName),
            AssetLabel = EG_AssetLabel
        | extend DeviceKey = iif(isnotempty(DI_AadDeviceId), DI_AadDeviceId, AssetName)
        __BUCKET_FILTER__

        | project
            TimeGenerated,
            SecurityDomain,
            AssetName,
            AssetLabel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            LegacyEndOfSupport,
            DeviceId,
            DeviceName           = coalesce(DI_DeviceName, DeviceName),
            OSPlatform           = OSPlatformNorm,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            ConfigurationId,
            ConfigurationName,
            CriticalityTier,
            CriticalityTierLevel,
            Impact               = ImpactInt,
            SecuritySeverity,
            SecuritySeverityDescription,
            RecommendedAction,
            RiskDescription      = KB_RiskDescription,
            ConfigurationDescription = KB_Description,
            RemediationOptions   = KB_Remediation,
            Benchmarks           = KB_Benchmarks,
            EG_IsCustomerFacing,
            EG_IsExcluded,
            IsApplicable,
            IsCompliant,
            DI_MachineGroup,
            DI_AssetValue,
            DI_ExposureLevel,
            DI_AzureResourceId,
            DI_AadDeviceId,
            EG_AssetName,
            EG_AssetLabel,
            EG_CriticalityRuleBased,
            EG_CriticalityRuleNames,
            AssetTags,
            AssetTierByTag,
            EG_AssetProps
        | order by CriticalityTier asc, Impact desc, AssetName asc, ConfigurationId asc

       
  - ReportName: Azure_Recommendations_Summary
    ReportPurpose: Summarize Azure exposure graph findings per asset and recommendation with tier fallback from tags and probability scoring from all risk factors
    SecurityDomain: Azure
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Summarize Azure exposure graph findings per recommendation and criticality tier
        // Tier uses Defender criticality when present and falls back to AssetTierByTag from Azure tags
        // RiskFactor_Probability equals the count of distinct risk factors on the edge and detailed columns show what was counted

        // Step 1  Build asset list for Azure and capture tier from tags with fallback
        // Scope includes assets where environmentName contains Azure
        // Excluded assets are removed early
        // AssetTierByTag prefers the Azure tag key AssetTier when present
        // If AssetTier is missing, fallback scans tag arrays for strings like --tier0--SI
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.environmentName) contains "Azure"
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
                )
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))

            // Normalize rawData and raw for tag reading
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend NodeRaw     = todynamic(todynamic(NodeProperties).raw)

            // Tag bags  Azure tags are often stored as a bag and AssetTier is a key in that bag
            | extend tagsBag1 = todynamic(coalesce(NoderawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(NodeRaw.tags, dynamic({})))

            // Preferred method  AssetTier tag key lookup
            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier,
                tagsBag2.AssetTier,
                tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"],
                tagsBag2["AssetTier--SI"],
                tagsBag3["AssetTier--SI"]
            ))

            // Fallback method  gather tag arrays and scan for tier markers
            | extend deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")

            // Regex fallback must include a capturing group
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            // Final AssetTierByTag value
            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                AssetTags,
                AssetTierByTag;


        // Step 2  Build finding list
        // Only nodes with a category containing finding are included
        // CVE nodes are excluded from this Azure finding view
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | where NodeLabel !contains "cve"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges with labels containing affecting are used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        let AF_edges =
            union
            (
                Edges
                | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            ),
            (
                Edges
                | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            );

        AF_edges
        // Step 5  De-duplicate and merge edge properties
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAny         = any(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            AssetTierByTag       = any(AssetTierByTag),
            AssetTags            = any(AssetTags)
          by AssetNodeId, AssetName, AssetLabel, FindingName
        | where EG_IsExcluded == false


        // Step 6  Build a unified Properties bag for simple lookups
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAny)
            )
        | extend SubCategory = tostring(Properties.raw.securityIssue.securityIssue)


        // Step 7  Risk extraction from graph edge
        | extend RiskLevel = tostring(Properties.edge.rawData.risk.riskLevel)
        | extend RiskFactorsArray = todynamic(Properties.edge.rawData.risk.riskFactors)
        | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)


        // Step 8  Normalize and score risk factors
        // RiskFactor_Probability increments by +1 for each distinct risk factor found
        // Detailed outputs are semicolon strings with stable sorting
        | mv-apply rf = RiskFactorsArray on (
            where isnotempty(trim(" ", tostring(rf)))
            | summarize RiskFactorSet = make_set(tostring(rf))
        )
        | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
        | extend RiskFactor_Probability = array_length(RiskFactorSet)
        | extend RiskFactor_Consequence = 0
        | extend RiskFactor_Probability_Detailed =
            strcat_array(array_sort_asc(RiskFactorSet), ";")
        | mv-apply rf = RiskFactorSet on (
            summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
        )
        | extend RiskFactor_Probability_DetailedScore =
            strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")


        // Step 9  Criticality tier mapping with fallback to AssetTierByTag
        // Prefer Defender CriticalityLevel first
        // If missing, map tier from AssetTierByTag
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - tier"
            )


        // Step 10  Severity and impact normalization
        | extend Severity = tostring(Properties.raw.severity)
        | extend Impact =
            case(
                tolower(Severity) == "low",                   3,
                tolower(Severity) == "medium",                7,
                tolower(Severity) in ("high","critical"),    10,
                999
            )


        // Step 11  Set fields expected by the risk engine
        | extend SecurityDomain    = "Azure"
        | extend ConfigurationId   = "Azure"
        | extend Category          = tostring(FindingLabel)
        | extend ConfigurationName = tostring(FindingName)
        | extend SecuritySeverity  = Severity
        | where isnotempty(SecuritySeverity)


        // Step 12  Summarize at recommendation level
        | summarize
            AssetCount             = dcount(AssetNodeId),
            TotalIssues            = count(),
            AvgImpact              = avg(Impact),
            MaxImpact              = max(Impact),
            ImpactedAssets         = make_set(AssetName),
            SampleFindings         = make_set(FindingName),

            // Keep a representative tag value for the group
            AssetTierByTag         = any(AssetTierByTag),

            RiskFactor_Consequence = max(RiskFactor_Consequence),
            RiskFactor_Probability = max(RiskFactor_Probability),
            RiskFactor_Probability_Detailed      = any(RiskFactor_Probability_Detailed),
            RiskFactor_Probability_DetailedScore = any(RiskFactor_Probability_DetailedScore)
          by SecurityDomain, Category, SubCategory, ConfigurationName, ConfigurationId, CriticalityTier, CriticalityTierLevel, SecuritySeverity


        // Step 13  Final shape and sorting
        | project
            SecurityDomain,
            Category,
            Subcategory = SubCategory,
            ConfigurationName,
            ConfigurationId,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity,
            AssetTierByTag,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            AvgImpact = round(AvgImpact, 1),
            MaxImpact = toint(ceiling(MaxImpact)),
            ImpactedAssets,
            SampleFindings
        | order by CriticalityTier asc, MaxImpact desc, AvgImpact desc, AssetCount desc, TotalIssues desc

  - ReportName: Azure_Recommendations_Detailed
    ReportPurpose: Summarize Azure exposure graph findings per asset and recommendation with tier fallback from tags and probability scoring from all risk factors
    SecurityDomain: Azure
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Identify and prioritize Azure security findings from Exposure Graph by asset criticality and finding severity
        // Enrich each row with tier tags and risk factor scoring where RiskFactor_Probability equals the count of distinct risk factors on the edge

        // Step 1  Build Azure asset list with criticality, scoping flags, and tier tags
        // Scope includes only assets where rawData environmentName contains Azure
        // Criticality is read from multiple possible criticality fields for robustness
        // Customer facing and excluded flags are normalized from rawData or raw
        // AssetTierByTag prefers the Azure tag key AssetTier when present
        // If AssetTier is missing, fallback scans tag arrays for strings like --tier0--SI
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.environmentName) contains "Azure"
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
                )
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))

            // Normalize rawData and raw for tag reading
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend NodeRaw     = todynamic(todynamic(NodeProperties).raw)

            // Tag bags  Azure tags often stored as a bag and AssetTier is a key
            | extend tagsBag1 = todynamic(coalesce(NoderawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(NodeRaw.tags, dynamic({})))

            // Preferred method  AssetTier tag key lookup
            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier,
                tagsBag2.AssetTier,
                tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"],
                tagsBag2["AssetTier--SI"],
                tagsBag3["AssetTier--SI"]
            ))

            // Fallback method  gather tag arrays and scan for tier markers
            | extend deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")

            // Regex fallback must include a capturing group
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            // Final AssetTierByTag value
            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                AssetTierByTag,
                AssetTags;


        // Step 2  Build finding list and scope to non-CVE finding nodes
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | where NodeLabel !contains "cve"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list used to connect assets to findings
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        let AF_edges =
            union
            (
                Edges
                | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            ),
            (
                Edges
                | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            );

        AF_edges
        // Step 5  De-duplicate and keep one row per AssetName AssetLabel FindingName
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAny         = any(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            AssetTierByTag       = any(AssetTierByTag),
            AssetTags            = any(AssetTags)
          by AssetName, AssetLabel, FindingName
        | where EG_IsExcluded == false


        // Step 6  Build unified Properties bag for easier extraction
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAny)
            )


        // Step 7  Extract the subcategory used for reporting
        | extend Subcategory = tostring(Properties.raw.securityIssue.securityIssue)


        // Step 8  Extract risk model fields from the edge rawData
        | extend RawCriticality = tostring(Properties.edge.rawData.risk.riskLevel)
        | extend RiskFactorsArray = todynamic(Properties.edge.rawData.risk.riskFactors)
        | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)


        // Step 9  Score risk factors
        | mv-apply rf = RiskFactorsArray on (
            where isnotempty(tostring(rf))
            | summarize RiskFactorSet = make_set(tostring(rf))
        )
        | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
        | extend RiskFactor_Probability = array_length(RiskFactorSet)
        | extend RiskFactor_Consequence = 0
        | extend RiskFactor_Probability_Detailed =
            strcat_array(array_sort_asc(RiskFactorSet), ";")
        | mv-apply rf = RiskFactorSet on (
            summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
        )
        | extend RiskFactor_Probability_DetailedScore =
            strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")


        // Step 10  Normalize severity to an impact score
        | extend Severity = tostring(Properties.raw.severity)
        | extend Impact =
            case(
                tolower(Severity) == "low",                   3,
                tolower(Severity) == "medium",                7,
                tolower(Severity) in ("high","critical"),    10,
                999
            )


        // Step 11  Compute criticality tier
        // Prefer Defender criticality level first
        // If Defender criticality is missing, fallback to tag-based tier detection
        // If both are missing, default tier is 3
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI" or AssetTierByTag has "tier0", 0,
                AssetTierByTag has "--tier1--SI" or AssetTierByTag has "tier1", 1,
                AssetTierByTag has "--tier2--SI" or AssetTierByTag has "tier2", 2,
                AssetTierByTag has "--tier3--SI" or AssetTierByTag has "tier3", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - tier"
            )


        // Step 12  Stamp fixed identifiers and apply final scoping filters
        | extend SecurityDomain = "Azure"
        | extend ConfigurationId = "Azure"
        | where isnotempty(Severity)


        // Step 13  Final projection and ordering
        | project
            SecurityDomain,
            AssetName,
            AssetLabel,
            Category              = tostring(FindingLabel),
            Subcategory,
            ConfigurationName     = tostring(FindingName),
            ConfigurationId,
            CriticalityLevel,
            CriticalityRuleBased,
            CriticalityRuleNames,
            AssetTierByTag,
            AssetTags,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity      = Severity,
            Impact,
            RawCriticality,
            RiskFactors           = RiskFactorsArray,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            RiskFactor_Consequence,
            Properties
        | order by CriticalityTier asc, Impact desc, AssetName asc

  - ReportName: Attack_Paths_Summary_Credential_Based_Lateral_Movement
    ReportPurpose: Identify credential driven attack paths in Exposure Graph and prioritize them by the business impact of the final target.
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // ===================== FULL QUERY (DETAILED TABLE + COLLAPSED SUMMARY OUTPUT) =====================

        // Step 0  Define legacy operating systems that should increase probability (same as CVE report)
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 1  Build node catalog used to enrich attack paths
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )
            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))
            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))
            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)
            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))
            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))
            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )
            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )
            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )
            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))
            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)
            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)
            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0
            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )
            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")
            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;

        // Step 2  Find credentials that exist on devices or systems
        let CredentialsOnDevices =
            ExposureGraphEdges
            | where EdgeLabel in ("contains", "defined in", "runs on", "has credentials of")
            | where SourceNodeLabel in (
                "device",
                "computer-account",
                "microsoft.compute/virtualmachines",
                "microsoft.web/sites_webapp",
                "microsoft.storage/storageaccounts",
                "user",
                "serviceprincipal"
            )
            | where TargetNodeLabel in (
                "azure-active-directory-app-secret",
                "user-azure-cli-secret",
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-user-credentials",
                "service-principal-azure-cli-secret",
                "entra-userCookie"
            )
            | project
                SourceDeviceId    = SourceNodeId,
                SourceDeviceName  = SourceNodeName,
                SourceDeviceLabel = SourceNodeLabel,
                CredentialNodeId  = TargetNodeId,
                CredentialName    = TargetNodeName,
                CredentialLabel   = TargetNodeLabel
            | summarize
                SourceDevices          = make_set(SourceDeviceName),
                SourceDeviceTypes      = make_set(SourceDeviceLabel),
                SourceDeviceCount      = dcount(SourceDeviceId),
                FirstSourceDeviceId    = any(SourceDeviceId),
                FirstSourceDeviceName  = any(SourceDeviceName),
                FirstSourceDeviceLabel = any(SourceDeviceLabel)
              by CredentialNodeId, CredentialName, CredentialLabel;

        // Step 3  Hop 1 credential can authenticate as identity
        let Hop1 =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                Hop1_SourceCredentialId   = SourceNodeId,
                Hop1_EdgeLabel            = EdgeLabel,
                IntermediateIdentityId    = TargetNodeId,
                IntermediateIdentity      = TargetNodeName,
                IntermediateIdentityLabel = TargetNodeLabel;

        // Step 4  Hop 2 identity can reach target resources
        let Hop2 =
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "runs on", "has permissions to", "has role on")
            | where TargetNodeLabel in (
                "microsoft.compute/virtualmachines",
                "microsoft.compute/virtualmachines/extensions",
                "device",
                "computer-account",
                "microsoft.web/sites_webapp",
                "microsoft.sql/servers",
                "microsoft.storage/storageaccounts",
                "microsoft.keyvault/vaults",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts_openai",
                "microsoft.operationalinsights/workspaces",
                "subscriptions",
                "resourcegroups"
            )
            | project
                Hop2_SourceIdentityId = SourceNodeId,
                Hop2_EdgeLabel        = EdgeLabel,
                FinalTargetId         = TargetNodeId,
                FinalTargetName       = TargetNodeName,
                FinalTargetLabel      = TargetNodeLabel;

        // Step 5  Assemble 2 hop attack paths and de-duplicate
        let Paths =
            CredentialsOnDevices
            | join kind=inner (Hop1) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId
            | join kind=inner (Hop2) on $left.IntermediateIdentityId == $right.Hop2_SourceIdentityId
            | where FirstSourceDeviceId != FinalTargetId
            | summarize
                SourceDevices              = any(SourceDevices),
                SourceDeviceTypes          = any(SourceDeviceTypes),
                SourceDeviceCount          = any(SourceDeviceCount),
                FirstSourceDeviceId        = any(FirstSourceDeviceId),
                FirstSourceDeviceName      = any(FirstSourceDeviceName),
                FirstSourceDeviceLabel     = any(FirstSourceDeviceLabel),
                CredentialName             = any(CredentialName),
                CredentialLabel            = any(CredentialLabel),
                IntermediateIdentityId     = any(IntermediateIdentityId),
                IntermediateIdentity       = any(IntermediateIdentity),
                IntermediateIdentityLabel  = any(IntermediateIdentityLabel),
                Hop1Edge                   = any(Hop1_EdgeLabel),
                Hop2Edge                   = any(Hop2_EdgeLabel),
                FinalTargetName            = any(FinalTargetName),
                FinalTargetLabel           = any(FinalTargetLabel)
              by CredentialNodeId, FinalTargetId;

        // Step 6-8  Build the detailed output table
        let Detailed =
            Paths
            | join kind=leftouter (
                Nodes
                | project-rename
                    SourceNodeId                     = NodeId,
                    SourceNodeName                   = NodeName,
                    SourceNodeLabel                  = NodeLabel,
                    SourceCriticalityTier            = CriticalityTier,
                    SourceCriticalityTierLevel       = CriticalityTierLevel,
                    SourceIsInternetExposed          = IsInternetExposed,
                    SourceIsExcluded                 = IsExcluded,
                    SourceAssetTierByTag             = AssetTierByTag,
                    SourceLegacyEndOfSupport         = LegacyEndOfSupport,
                    SourceRiskProb                   = RiskFactor_Probability,
                    SourceRiskProbDetailed           = RiskFactor_Probability_Detailed,
                    SourceRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                    SourceNodeProperties             = NodeProperties
            ) on $left.FirstSourceDeviceId == $right.SourceNodeId
            | join kind=leftouter (
                Nodes
                | project-rename
                    IntermediateNodeId                = NodeId,
                    IntermediateNodeName              = NodeName,
                    IntermediateNodeLabel             = NodeLabel,
                    IntermediateCriticalityTier       = CriticalityTier,
                    IntermediateCriticalityTierLevel  = CriticalityTierLevel,
                    IntermediateIsInternetExposed     = IsInternetExposed,
                    IntermediateIsExcluded            = IsExcluded,
                    IntermediateAssetTierByTag        = AssetTierByTag,
                    IntermediateLegacyEndOfSupport    = LegacyEndOfSupport,
                    IntermediateRiskProb              = RiskFactor_Probability,
                    IntermediateRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    IntermediateRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                    IntermediateNodeProperties        = NodeProperties
            ) on $left.IntermediateIdentityId == $right.IntermediateNodeId
            | join kind=leftouter (
                Nodes
                | project-rename
                    TargetNodeId                     = NodeId,
                    TargetNodeName                   = NodeName,
                    TargetNodeLabel                  = NodeLabel,
                    TargetCriticalityTier            = CriticalityTier,
                    TargetCriticalityTierLevel       = CriticalityTierLevel,
                    TargetIsInternetExposed          = IsInternetExposed,
                    TargetIsExcluded                 = IsExcluded,
                    TargetAssetTierByTag             = AssetTierByTag,
                    TargetLegacyEndOfSupport         = LegacyEndOfSupport,
                    TargetRiskProb                   = RiskFactor_Probability,
                    TargetRiskProbDetailed           = RiskFactor_Probability_Detailed,
                    TargetRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                    TargetNodeProperties             = NodeProperties
            ) on $left.FinalTargetId == $right.TargetNodeId
            | join kind=leftouter (
                Nodes
                | project-rename
                    CredentialNodeId_join        = NodeId,
                    CredentialNodeName_join      = NodeName,
                    CredentialNodeLabel_join     = NodeLabel,
                    CredentialNodeProperties     = NodeProperties
            ) on $left.CredentialNodeId == $right.CredentialNodeId_join
            | extend TierEscalation =
                case(
                    isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                        SourceCriticalityTier - TargetCriticalityTier,
                    0
                )
            | extend IsLateralMovement = TierEscalation > 0
            | extend LateralMovementType =
                case(
                    TierEscalation >= 3, "Privilege escalation large tier jump",
                    TierEscalation == 2, "Privilege escalation two tiers",
                    TierEscalation == 1, "Privilege escalation one tier",
                    "Direct access same tier"
                )
            | extend TargetTierWeight =
                case(
                    TargetCriticalityTier == 0, 100,
                    TargetCriticalityTier == 1, 60,
                    TargetCriticalityTier == 2, 30,
                    10
                )
            | extend EscalationWeight = TierEscalation * 10
            | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
            | extend SourceTierAmplifier =
                case(
                    SourceCriticalityTier == 0, 8,
                    SourceCriticalityTier == 1, 5,
                    SourceCriticalityTier == 2, 2,
                    0
                )
            | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier
            | extend AttackPathPriority =
                case(
                    AttackPathPriorityScore >= 120, "Critical",
                    AttackPathPriorityScore >= 90,  "Very High",
                    AttackPathPriorityScore >= 60,  "High",
                    AttackPathPriorityScore >= 30,  "Medium-High",
                    AttackPathPriorityScore >= 15,  "Medium",
                    "Low"
                )
            | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
            | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
            | extend AttackPath =
                strcat(
                    FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] -> ",
                    CredentialLabel, " [", CredentialName, "] -> ",
                    IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                    FinalTargetLabel, " [", FinalTargetName, "]"
                )
            | extend AttackPathDetailed =
                strcat(
                    "SOURCE ", FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] ",
                    "tier ", tostring(SourceCriticalityTier), " ", tostring(SourceCriticalityTierLevel), " ",
                    " | ", InternetExposureSource,
                    " -> CREDENTIAL ", CredentialLabel, " [", CredentialName, "] ",
                    " -> IDENTITY ", IntermediateIdentityLabel, " [", IntermediateIdentity, "] ",
                    " -> TARGET ", FinalTargetLabel, " [", FinalTargetName, "] ",
                    "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " ",
                    " | ", InternetExposureTarget,
                    " | escalation ", tostring(TierEscalation),
                    " | ", LateralMovementType
                )
            | project
                AttackPathPriority,
                AttackPathPriorityScore,
                TierEscalation,
                IsLateralMovement,
                LateralMovementType,

                FirstSourceDeviceId,
                FirstSourceDeviceName,
                FirstSourceDeviceLabel,
                IntermediateIdentityId,
                IntermediateIdentity,
                IntermediateIdentityLabel,
                CredentialNodeId,
                CredentialName,
                CredentialLabel,
                FinalTargetId,
                FinalTargetName,
                FinalTargetLabel,

                TargetCriticalityTier,
                TargetCriticalityTierLevel,
                TargetAssetTierByTag,
                TargetIsInternetExposed,
                TargetLegacyEndOfSupport,
                TargetRiskProb,
                TargetRiskProbDetailed,
                TargetRiskProbDetailedScore,

                SourceCriticalityTier,
                SourceCriticalityTierLevel,
                SourceAssetTierByTag,
                SourceIsInternetExposed,
                SourceLegacyEndOfSupport,
                SourceRiskProb,
                SourceRiskProbDetailed,
                SourceRiskProbDetailedScore,

                IntermediateCriticalityTier,
                IntermediateCriticalityTierLevel,
                IntermediateIsInternetExposed,
                IntermediateLegacyEndOfSupport,
                IntermediateRiskProb,
                IntermediateRiskProbDetailed,
                IntermediateRiskProbDetailedScore,

                SourceDeviceCount,
                SourceDevices,
                SourceDeviceTypes,
                Hop1Edge,
                Hop2Edge,

                AttackPath,
                AttackPathDetailed,

                SourceNodeProperties,
                IntermediateNodeProperties,
                TargetNodeProperties,
                CredentialNodeProperties;

        // ===================== COLLAPSED SUMMARY VERSION (FINAL OUTPUT) =====================

        // Collapse to unique logical path (PathKey) so credential spam doesnt multiply counts.
        let CollapsedPaths =
            Detailed
            | extend PathKey = strcat(FirstSourceDeviceId, "->", IntermediateIdentityId, "->", FinalTargetId)
            | extend SecurityDomain =
                case(
                    FinalTargetLabel in ("device","computer-account","microsoft.compute/virtualmachines"), "Endpoint",
                    "Azure"
                )
            | extend
                Category    = "Attack Paths",
                SubCategory = "LateralMovement",
                ConfigurationName = tostring(LateralMovementType),
                SecuritySeverity  = tostring(AttackPathPriority),
                RiskFactor_Consequence = 0
            | summarize
                AttackPathPriorityScore_Path = max(AttackPathPriorityScore),
                AttackPathPriority_Path      = any(AttackPathPriority),

                TargetCriticalityTier_Path      = any(TargetCriticalityTier),
                TargetCriticalityTierLevel_Path = any(TargetCriticalityTierLevel),
                TargetRiskProb_Path             = max(TargetRiskProb),

                TargetRiskProbDetailed_Path      = any(TargetRiskProbDetailed),
                TargetRiskProbDetailedScore_Path = any(TargetRiskProbDetailedScore),

                CredentialLabels_Path = make_set(tostring(CredentialLabel)),
                SourceAssets_Path     = make_set(tostring(FirstSourceDeviceName)),
                TotalIssues_Path      = count()
              by
                PathKey,
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,
                FinalTargetId;

        // Main summary (counts stay correct)
        let SummaryMain =
            CollapsedPaths
            | summarize
                ConfigurationId = strcat_array(array_sort_asc(make_set(strcat_array(CredentialLabels_Path, ";"))), ";"),

                SecuritySeverity = any(AttackPathPriority_Path),
                CriticalityTier = toint(any(TargetCriticalityTier_Path)),
                CriticalityTierLevel = tostring(any(TargetCriticalityTierLevel_Path)),

                RiskFactor_Consequence = 0,
                RiskFactor_Probability = max(TargetRiskProb_Path),

                AssetCount   = dcount(FinalTargetId),
                TotalIssues  = sum(TotalIssues_Path),

                ImpactedAssets = strcat_array(array_sort_asc(make_set(strcat_array(SourceAssets_Path, ";"))), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        // Detail flattening split -> mv-expand -> make_set -> join once (prevents leading ';')
        let SummaryDetail =
            CollapsedPaths
            | extend _d = split(tostring(TargetRiskProbDetailed_Path), ";")
            | mv-expand _d to typeof(string)
            | extend _d = trim(" ", _d)
            | where isnotempty(_d)
            | summarize
                RiskFactor_Probability_Detailed = strcat_array(array_sort_asc(make_set(_d)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        let SummaryDetailScore =
            CollapsedPaths
            | extend _s = split(tostring(TargetRiskProbDetailedScore_Path), ";")
            | mv-expand _s to typeof(string)
            | extend _s = trim(" ", _s)
            | where isnotempty(_s)
            | summarize
                RiskFactor_Probability_DetailedScore = strcat_array(array_sort_asc(make_set(_s)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        // Final output
        SummaryMain
        | join kind=leftouter SummaryDetail on SecurityDomain, Category, SubCategory, ConfigurationName
        | join kind=leftouter SummaryDetailScore on SecurityDomain, Category, SubCategory, ConfigurationName
        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,
            SecuritySeverity,
            CriticalityTier,
            CriticalityTierLevel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by
            RiskFactor_Probability desc,
            CriticalityTier asc,
            TotalIssues desc,
            AssetCount desc

  - ReportName: Attack_Paths_Detailed_Credential_Based_Lateral_Movement
    ReportPurpose: Identify credential driven attack paths in Exposure Graph and prioritize them by the business impact of the final target.
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Identify credential driven attack paths in Exposure Graph and prioritize them by the business impact of the final target.
        //
        // Important interpretation guard
        // This query prioritizes based on TARGET criticality tier first, then tier escalation, then internet exposure.
        // A tier 2 workstation used as a source does NOT outrank a tier 0 target resource.
        // The source still matters as an amplifier, but the target drives the priority.


        // Step 0  Define legacy operating systems that should increase probability (same as CVE report)
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        // Includes
        // - Defender criticality tier preferred with tag fallback
        // - AssetTierByTag prefers Azure tag bag key AssetTier fallback scans tag arrays for --tierX--SI
        // - LegacyEndOfSupport derived from rawData OS fields when present
        // - RiskFactor scoring count distinct node risk factors plus Internet-Exposed plus LegacyEoS
        // Naming
        // - CustomerFacing terminology is replaced by Internet-Exposed IsInternetExposed
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            // Criticality extraction from multiple possible fields
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            // Internet exposure flag derived from graph property isCustomerFacing renamed
            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            // Exclusion flag
            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            // Normalize rawData and raw for tag and OS reading
            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            // AssetTierByTag preferred bag key AssetTier fallback tag array scan
            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            // Tag fallback mapping only used when Defender criticality is missing
            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            // Prefer Defender criticality over tag
            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            // LegacyEndOfSupport detection same as CVE report
            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            // Risk factors on nodes count distinct plus Internet-Exposed plus LegacyEoS
            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Find credentials that exist on devices or systems
        let CredentialsOnDevices =
            ExposureGraphEdges
            | where EdgeLabel in ("contains", "defined in", "runs on", "has credentials of")
            | where SourceNodeLabel in (
                "device",
                "computer-account",
                "microsoft.compute/virtualmachines",
                "microsoft.web/sites_webapp",
                "microsoft.storage/storageaccounts",
                "user",
                "serviceprincipal"
            )
            | where TargetNodeLabel in (
                "azure-active-directory-app-secret",
                "user-azure-cli-secret",
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-user-credentials",
                "service-principal-azure-cli-secret",
                "entra-userCookie"
            )
            | project
                SourceDeviceId    = SourceNodeId,
                SourceDeviceName  = SourceNodeName,
                SourceDeviceLabel = SourceNodeLabel,
                CredentialNodeId  = TargetNodeId,
                CredentialName    = TargetNodeName,
                CredentialLabel   = TargetNodeLabel
            | summarize
                SourceDevices          = make_set(SourceDeviceName),
                SourceDeviceTypes      = make_set(SourceDeviceLabel),
                SourceDeviceCount      = dcount(SourceDeviceId),
                FirstSourceDeviceId    = any(SourceDeviceId),
                FirstSourceDeviceName  = any(SourceDeviceName),
                FirstSourceDeviceLabel = any(SourceDeviceLabel)
              by CredentialNodeId, CredentialName, CredentialLabel;


        // Step 3  Hop 1 credential can authenticate as identity
        let Hop1 =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                Hop1_SourceCredentialId = SourceNodeId,
                Hop1_EdgeLabel          = EdgeLabel,
                IntermediateIdentityId  = TargetNodeId,
                IntermediateIdentity    = TargetNodeName,
                IntermediateIdentityLabel = TargetNodeLabel;


        // Step 4  Hop 2 identity can reach target resources
        let Hop2 =
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "runs on", "has permissions to", "has role on")
            | where TargetNodeLabel in (
                "microsoft.compute/virtualmachines",
                "microsoft.compute/virtualmachines/extensions",
                "device",
                "computer-account",
                "microsoft.web/sites_webapp",
                "microsoft.sql/servers",
                "microsoft.storage/storageaccounts",
                "microsoft.keyvault/vaults",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts_openai",
                "microsoft.operationalinsights/workspaces",
                "subscriptions",
                "resourcegroups"
            )
            | project
                Hop2_SourceIdentityId = SourceNodeId,
                Hop2_EdgeLabel        = EdgeLabel,
                FinalTargetId         = TargetNodeId,
                FinalTargetName       = TargetNodeName,
                FinalTargetLabel      = TargetNodeLabel;


        // Step 5  Assemble 2 hop attack paths and de-duplicate
        let Paths =
            CredentialsOnDevices
            | join kind=inner (Hop1) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId
            | join kind=inner (Hop2) on $left.IntermediateIdentityId == $right.Hop2_SourceIdentityId
            | where FirstSourceDeviceId != FinalTargetId
            | summarize
                SourceDevices              = any(SourceDevices),
                SourceDeviceTypes          = any(SourceDeviceTypes),
                SourceDeviceCount          = any(SourceDeviceCount),
                FirstSourceDeviceId        = any(FirstSourceDeviceId),
                FirstSourceDeviceName      = any(FirstSourceDeviceName),
                FirstSourceDeviceLabel     = any(FirstSourceDeviceLabel),
                CredentialName             = any(CredentialName),
                CredentialLabel            = any(CredentialLabel),
                IntermediateIdentityId     = any(IntermediateIdentityId),
                IntermediateIdentity       = any(IntermediateIdentity),
                IntermediateIdentityLabel  = any(IntermediateIdentityLabel),
                Hop1Edge                   = any(Hop1_EdgeLabel),
                Hop2Edge                   = any(Hop2_EdgeLabel),
                FinalTargetName            = any(FinalTargetName),
                FinalTargetLabel           = any(FinalTargetLabel)
              by CredentialNodeId, FinalTargetId;


        // Step 6  Enrich paths with node metadata and keep NodeProperties
        Paths
        | join kind=leftouter (
            Nodes
            | project-rename
                SourceNodeId                     = NodeId,
                SourceNodeName                   = NodeName,
                SourceNodeLabel                  = NodeLabel,
                SourceCriticalityTier            = CriticalityTier,
                SourceCriticalityTierLevel       = CriticalityTierLevel,
                SourceIsInternetExposed          = IsInternetExposed,
                SourceIsExcluded                 = IsExcluded,
                SourceAssetTierByTag             = AssetTierByTag,
                SourceLegacyEndOfSupport         = LegacyEndOfSupport,
                SourceRiskProb                   = RiskFactor_Probability,
                SourceRiskProbDetailed           = RiskFactor_Probability_Detailed,
                SourceRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                SourceNodeProperties             = NodeProperties
        ) on $left.FirstSourceDeviceId == $right.SourceNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                IntermediateNodeId               = NodeId,
                IntermediateNodeName             = NodeName,
                IntermediateNodeLabel            = NodeLabel,
                IntermediateCriticalityTier      = CriticalityTier,
                IntermediateCriticalityTierLevel = CriticalityTierLevel,
                IntermediateIsInternetExposed    = IsInternetExposed,
                IntermediateIsExcluded           = IsExcluded,
                IntermediateAssetTierByTag       = AssetTierByTag,
                IntermediateLegacyEndOfSupport   = LegacyEndOfSupport,
                IntermediateRiskProb             = RiskFactor_Probability,
                IntermediateRiskProbDetailed     = RiskFactor_Probability_Detailed,
                IntermediateRiskProbDetailedScore= RiskFactor_Probability_DetailedScore,
                IntermediateNodeProperties       = NodeProperties
        ) on $left.IntermediateIdentityId == $right.IntermediateNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                     = NodeId,
                TargetNodeName                   = NodeName,
                TargetNodeLabel                  = NodeLabel,
                TargetCriticalityTier            = CriticalityTier,
                TargetCriticalityTierLevel       = CriticalityTierLevel,
                TargetIsInternetExposed          = IsInternetExposed,
                TargetIsExcluded                 = IsExcluded,
                TargetAssetTierByTag             = AssetTierByTag,
                TargetLegacyEndOfSupport         = LegacyEndOfSupport,
                TargetRiskProb                   = RiskFactor_Probability,
                TargetRiskProbDetailed           = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                TargetNodeProperties             = NodeProperties
        ) on $left.FinalTargetId == $right.TargetNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                CredentialNodeId_join        = NodeId,
                CredentialNodeName_join      = NodeName,
                CredentialNodeLabel_join     = NodeLabel,
                CredentialNodeProperties     = NodeProperties
        ) on $left.CredentialNodeId == $right.CredentialNodeId_join


        // Step 7  Attack path prioritization logic
        | extend TierEscalation =
            case(
                isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                    SourceCriticalityTier - TargetCriticalityTier,
                0
            )
        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )
        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
        | extend SourceTierAmplifier =
            case(
                SourceCriticalityTier == 0, 8,
                SourceCriticalityTier == 1, 5,
                SourceCriticalityTier == 2, 2,
                0
            )
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )


        // Step 8  Human readable paths and Internet-Exposed wording
        | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
        | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

        | extend AttackPath =
            strcat(
                FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] -> ",
                CredentialLabel, " [", CredentialName, "] -> ",
                IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                FinalTargetLabel, " [", FinalTargetName, "]"
            )
        | extend AttackPathDetailed =
            strcat(
                "SOURCE ", FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] ",
                "tier ", tostring(SourceCriticalityTier), " ", tostring(SourceCriticalityTierLevel), " ",
                " | ", InternetExposureSource,
                " -> CREDENTIAL ", CredentialLabel, " [", CredentialName, "] ",
                " -> IDENTITY ", IntermediateIdentityLabel, " [", IntermediateIdentity, "] ",
                " -> TARGET ", FinalTargetLabel, " [", FinalTargetName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " ",
                " | ", InternetExposureTarget,
                " | escalation ", tostring(TierEscalation),
                " | ", LateralMovementType
            )

        | project
            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,

            FirstSourceDeviceId,
            FirstSourceDeviceName,
            FirstSourceDeviceLabel,
            IntermediateIdentityId,
            IntermediateIdentity,
            IntermediateIdentityLabel,
            CredentialNodeId,
            CredentialName,
            CredentialLabel,
            FinalTargetId,
            FinalTargetName,
            FinalTargetLabel,

            TargetCriticalityTier,
            TargetCriticalityTierLevel,
            TargetAssetTierByTag,
            TargetIsInternetExposed,
            TargetLegacyEndOfSupport,
            TargetRiskProb,
            TargetRiskProbDetailed,
            TargetRiskProbDetailedScore,

            SourceCriticalityTier,
            SourceCriticalityTierLevel,
            SourceAssetTierByTag,
            SourceIsInternetExposed,
            SourceLegacyEndOfSupport,
            SourceRiskProb,
            SourceRiskProbDetailed,
            SourceRiskProbDetailedScore,

            IntermediateCriticalityTier,
            IntermediateCriticalityTierLevel,
            IntermediateIsInternetExposed,
            IntermediateLegacyEndOfSupport,
            IntermediateRiskProb,
            IntermediateRiskProbDetailed,
            IntermediateRiskProbDetailedScore,

            SourceDeviceCount,
            SourceDevices,
            SourceDeviceTypes,
            Hop1Edge,
            Hop2Edge,

            AttackPath,
            AttackPathDetailed,

            SourceNodeProperties,
            IntermediateNodeProperties,
            TargetNodeProperties,
            CredentialNodeProperties
        | order by AttackPathPriorityScore desc, TierEscalation desc, TargetCriticalityTier asc, FinalTargetName asc

  - ReportName: Attack_Paths_Summary_Github_to_Azure_Resources
    ReportPurpose: Identify credentials stored in GitHub workflows or repositories and trace credential driven attack paths into Azure targets. Paths are prioritized by the business impact of the FINAL TARGET.
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Credential driven attack paths from GitHub to Azure using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify credentials stored in GitHub workflows or repositories and trace credential driven
        // attack paths into Azure targets. Paths are prioritized by the business impact of the FINAL TARGET.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the TARGET criticality tier first
        // - Then by tier escalation where source tier is higher than target tier
        // - Then by Internet exposure where target exposure is weighted higher than source exposure
        // - GitHub sources are treated as Internet exposed and low trust by default
        // - A low tier source can never outrank a tier 0 or tier 1 target
        //
        // Output description
        // Detailed output produces one row per unique credential to target attack path enriched with
        // - Internet exposure flags
        // - Asset tier from tags
        // - Legacy operating system and end of support signals
        // - Risk factor probability including detailed breakdown
        // - Attack path priority score and severity
        // - Human readable attack path strings
        //
        // Collapsed summary output merges duplicates caused by many credentials or sources
        // - Collapse key uses source identity target triple
        // - Summaries include RiskFactor_Probability_Detailed and DetailedScore derived from target
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone
        // Step 2  Normalize node labels to avoid filter issues
        // Step 3  Identify credentials stored in GitHub workflows and repositories
        // Step 4  Hop 1 credential authenticates as an identity
        // Step 5  Hop 2 identity can reach Azure target resources
        // Step 6  Assemble attack paths and de duplicate
        // Step 7  Enrich source target intermediate and credential using Nodes catalog
        // Step 8  Calculate tier escalation lateral movement and priority score
        // Step 9  Build human readable AttackPath and AttackPathDetailed
        // Step 10 Emit detailed output table
        // Step 11 Collapse to unique logical path
        // Step 12 Build main summary
        // Step 13 Build probability detail summary
        // Step 14 Build probability detail score summary
        // Step 15 Emit final collapsed output
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Normalize labels to avoid typos breaking filters
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };


        // Step 3  Identify credentials stored in GitHub workflows and repositories
        let GitHubCredentials =
            ExposureGraphEdges
            | where EdgeLabel in ("contains", "defined in")
            | extend SourceNodeLabelNorm = NormalizeLabel(SourceNodeLabel),
                     TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where SourceNodeLabelNorm in ("githubworkflow", "githubrepository")
            | where TargetNodeLabelNorm in (
                "azure-active-directory-app-secret",
                "user-azure-cli-secret",
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-user-credentials",
                "service-principal-azure-cli-secret",
                "azure-app-configuration-key"
            )
            | project
                SourceGitHubNodeId    = SourceNodeId,
                SourceGitHubNodeName  = SourceNodeName,
                SourceGitHubNodeLabel = SourceNodeLabel,
                CredentialNodeId      = TargetNodeId,
                CredentialNodeName    = TargetNodeName,
                CredentialNodeLabel   = TargetNodeLabel
            | summarize
                GitHubSources          = make_set(SourceGitHubNodeName),
                GitHubSourceTypes      = make_set(SourceGitHubNodeLabel),
                GitHubSourceCount      = dcount(SourceGitHubNodeId),
                FirstGitHubSource      = any(SourceGitHubNodeId),
                FirstGitHubSourceName  = any(SourceGitHubNodeName),
                FirstGitHubSourceLabel = any(SourceGitHubNodeLabel)
              by CredentialNodeId, CredentialNodeName, CredentialNodeLabel;


        // Step 4  Hop 1 credential authenticates as an identity
        let Hop1 =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                Hop1_SourceCredentialId    = SourceNodeId,
                Hop1_EdgeLabel             = EdgeLabel,
                IntermediateIdentityId     = TargetNodeId,
                IntermediateIdentity       = TargetNodeName,
                IntermediateIdentityLabel  = TargetNodeLabel;


        // Step 5  Hop 2 identity can reach Azure target resources
        let Hop2 =
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "has permissions to", "has role on")
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.compute/virtualmachines",
                "microsoft.storage/storageaccounts",
                "microsoft.keyvault/vaults",
                "microsoft.sql/servers",
                "microsoft.sql/servers/databases",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts_openai",
                "subscriptions",
                "resourcegroups",
                "blobcontainer"
            )
            | project
                Hop2_SourceIdentityId = SourceNodeId,
                Hop2_EdgeLabel        = EdgeLabel,
                FinalTargetId         = TargetNodeId,
                FinalTargetName       = TargetNodeName,
                FinalTargetLabel      = TargetNodeLabel;


        // Step 6  Assemble attack paths and de duplicate
        let Detailed =
            GitHubCredentials
            | join kind=inner (Hop1) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId
            | join kind=inner (Hop2) on $left.IntermediateIdentityId == $right.Hop2_SourceIdentityId
            | where FirstGitHubSource != FinalTargetId
            | summarize
                GitHubSources          = any(GitHubSources),
                GitHubSourceTypes      = any(GitHubSourceTypes),
                GitHubSourceCount      = any(GitHubSourceCount),
                FirstGitHubSource      = any(FirstGitHubSource),
                FirstGitHubSourceName  = any(FirstGitHubSourceName),
                FirstGitHubSourceLabel = any(FirstGitHubSourceLabel),

                CredentialNodeName     = any(CredentialNodeName),
                CredentialNodeLabel    = any(CredentialNodeLabel),

                IntermediateIdentityId    = any(IntermediateIdentityId),
                IntermediateIdentity      = any(IntermediateIdentity),
                IntermediateIdentityLabel = any(IntermediateIdentityLabel),

                Hop1Edge = any(Hop1_EdgeLabel),
                Hop2Edge = any(Hop2_EdgeLabel),

                FinalTargetName  = any(FinalTargetName),
                FinalTargetLabel = any(FinalTargetLabel)
              by CredentialNodeId, FinalTargetId;


        // Step 7  Enrich source target intermediate and credential using Nodes catalog
        let DetailedEnriched =
            Detailed
            | join kind=leftouter (
                Nodes
                | project-rename
                    SourceNodeId                = NodeId,
                    SourceNodeName              = NodeName,
                    SourceNodeLabel             = NodeLabel,
                    SourceCriticalityTier       = CriticalityTier,
                    SourceCriticalityTierLevel  = CriticalityTierLevel,
                    SourceIsInternetExposed     = IsInternetExposed,
                    SourceIsExcluded            = IsExcluded,
                    SourceAssetTierByTag        = AssetTierByTag,
                    SourceLegacyEndOfSupport    = LegacyEndOfSupport,
                    SourceRiskProb              = RiskFactor_Probability,
                    SourceRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    SourceRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                    SourceNodeProperties        = NodeProperties
            ) on $left.FirstGitHubSource == $right.SourceNodeId

            | join kind=leftouter (
                Nodes
                | project-rename
                    IntermediateNodeId                = NodeId,
                    IntermediateNodeName              = NodeName,
                    IntermediateNodeLabel             = NodeLabel,
                    IntermediateCriticalityTier       = CriticalityTier,
                    IntermediateCriticalityTierLevel  = CriticalityTierLevel,
                    IntermediateIsInternetExposed     = IsInternetExposed,
                    IntermediateIsExcluded            = IsExcluded,
                    IntermediateAssetTierByTag        = AssetTierByTag,
                    IntermediateLegacyEndOfSupport    = LegacyEndOfSupport,
                    IntermediateRiskProb              = RiskFactor_Probability,
                    IntermediateRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    IntermediateRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                    IntermediateNodeProperties        = NodeProperties
            ) on $left.IntermediateIdentityId == $right.IntermediateNodeId

            | join kind=leftouter (
                Nodes
                | project-rename
                    TargetNodeId                = NodeId,
                    TargetNodeName              = NodeName,
                    TargetNodeLabel             = NodeLabel,
                    TargetCriticalityTier       = CriticalityTier,
                    TargetCriticalityTierLevel  = CriticalityTierLevel,
                    TargetIsInternetExposed     = IsInternetExposed,
                    TargetIsExcluded            = IsExcluded,
                    TargetAssetTierByTag        = AssetTierByTag,
                    TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                    TargetRiskProb              = RiskFactor_Probability,
                    TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                    TargetNodeProperties        = NodeProperties
            ) on $left.FinalTargetId == $right.TargetNodeId

            | join kind=leftouter (
                Nodes
                | project-rename
                    CredentialNodeId_join    = NodeId,
                    CredentialNodeName_join  = NodeName,
                    CredentialNodeLabel_join = NodeLabel,
                    CredentialNodeProperties = NodeProperties
            ) on $left.CredentialNodeId == $right.CredentialNodeId_join

            | extend
                SourceIsInternetExposed = true,
                SourceCriticalityTier   = toint(coalesce(SourceCriticalityTier, 3)),
                SourceCriticalityTierLevel = tostring(coalesce(SourceCriticalityTierLevel, "Low - tier 3"))

            | extend TierEscalation =
                case(
                    isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                        SourceCriticalityTier - TargetCriticalityTier,
                    0
                )
            | extend IsLateralMovement = TierEscalation > 0
            | extend LateralMovementType =
                case(
                    TierEscalation >= 3, "Privilege escalation large tier jump",
                    TierEscalation == 2, "Privilege escalation two tiers",
                    TierEscalation == 1, "Privilege escalation one tier",
                    "Direct access same tier"
                )

            | extend TargetTierWeight =
                case(
                    TargetCriticalityTier == 0, 100,
                    TargetCriticalityTier == 1, 60,
                    TargetCriticalityTier == 2, 30,
                    10
                )
            | extend EscalationWeight = TierEscalation * 10
            | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
            | extend SourceTierAmplifier =
                case(
                    SourceCriticalityTier == 0, 8,
                    SourceCriticalityTier == 1, 5,
                    SourceCriticalityTier == 2, 2,
                    0
                )
            | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

            | extend AttackPathPriority =
                case(
                    AttackPathPriorityScore >= 120, "Critical",
                    AttackPathPriorityScore >= 90,  "Very High",
                    AttackPathPriorityScore >= 60,  "High",
                    AttackPathPriorityScore >= 30,  "Medium-High",
                    AttackPathPriorityScore >= 15,  "Medium",
                    "Low"
                )

            | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
            | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

            | extend AttackPath =
                strcat(
                    FirstGitHubSourceLabel, " [", FirstGitHubSourceName, "] -> ",
                    CredentialNodeLabel, " [", CredentialNodeName, "] -> ",
                    IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                    FinalTargetLabel, " [", FinalTargetName, "]"
                )

            | extend AttackPathDetailed =
                strcat(
                    "SOURCE ", FirstGitHubSourceLabel, " [", FirstGitHubSourceName, "] ",
                    "tier ", tostring(SourceCriticalityTier), " ", SourceCriticalityTierLevel, " | ", InternetExposureSource,
                    iff(GitHubSourceCount > 1, strcat(" | + ", tostring(GitHubSourceCount - 1), " other GitHub source(s)"), ""),
                    " -> CREDENTIAL ", CredentialNodeLabel, " [", CredentialNodeName, "] ",
                    " -> IDENTITY ", IntermediateIdentityLabel, " [", IntermediateIdentity, "] ",
                    " -> TARGET ", FinalTargetLabel, " [", FinalTargetName, "] ",
                    "tier ", tostring(TargetCriticalityTier), " ", TargetCriticalityTierLevel, " | ", InternetExposureTarget,
                    " | escalation ", tostring(TierEscalation),
                    " | ", LateralMovementType
                );


        // Step 10  Emit detailed output table
        let DetailedOutput =
            DetailedEnriched
            | extend SecurityDomain = "Supply Chain"
            | extend Category = "AttackPath_GitHubToAzure"
            | extend Subcategory =
                case(
                    TierEscalation >= 3, strcat("GitHub to Tier ", tostring(TargetCriticalityTier), " - Critical Supply Chain Risk"),
                    TierEscalation >= 2, strcat("GitHub to Tier ", tostring(TargetCriticalityTier), " - High Supply Chain Risk"),
                    TierEscalation >= 1, strcat("GitHub to Tier ", tostring(TargetCriticalityTier), " - Moderate Supply Chain Risk"),
                    "GitHub to Azure - Direct Access"
                )
            | project
                SecurityDomain,
                Category,
                Subcategory,

                AttackPathPriority,
                AttackPathPriorityScore,
                TierEscalation,
                IsLateralMovement,
                LateralMovementType,
                EscalationWeight,
                ExposureWeight,

                FirstGitHubSource,
                FirstGitHubSourceName,
                FirstGitHubSourceLabel,
                TotalGitHubSourcesWithCredential = GitHubSourceCount,
                AllGitHubSources = GitHubSources,
                GitHubSourceTypes,

                CredentialNodeId,
                CredentialNodeName,
                CredentialNodeLabel,

                IntermediateIdentityId,
                IntermediateIdentity,
                IntermediateIdentityType = IntermediateIdentityLabel,

                FinalTargetId,
                FinalTarget = FinalTargetName,
                FinalTargetType = FinalTargetLabel,

                CriticalityTier = TargetCriticalityTier,
                CriticalityTierLevel = TargetCriticalityTierLevel,
                TargetAssetTierByTag,
                TargetIsInternetExposed,
                TargetLegacyEndOfSupport,
                TargetRiskProb,
                TargetRiskProbDetailed,
                TargetRiskProbDetailedScore,

                SourceAssetTierByTag,
                SourceLegacyEndOfSupport,
                SourceRiskProb,
                SourceRiskProbDetailed,
                SourceRiskProbDetailedScore,

                IntermediateCriticalityTier,
                IntermediateCriticalityTierLevel,
                IntermediateIsInternetExposed,
                IntermediateLegacyEndOfSupport,
                IntermediateRiskProb,
                IntermediateRiskProbDetailed,
                IntermediateRiskProbDetailedScore,

                Hop1Edge,
                Hop2Edge,

                AttackPath,
                AttackPathDetailed,

                SourceNodeProperties,
                IntermediateNodeProperties,
                TargetNodeProperties,
                CredentialNodeProperties;


        // Step 11  Collapse to unique logical path
        let CollapsedPaths =
            DetailedEnriched
            | extend PathKey = strcat(FirstGitHubSource, "->", IntermediateIdentityId, "->", FinalTargetId)
            | extend SecurityDomain =
                case(
                    FinalTargetLabel in ("device","computer-account","microsoft.compute/virtualmachines"), "Endpoint",
                    "Azure"
                )
            | extend
                Category    = "Attack Paths",
                SubCategory = "LateralMovement",
                ConfigurationName = tostring(LateralMovementType),
                SecuritySeverity  = tostring(AttackPathPriority),
                RiskFactor_Consequence = 0
            | summarize
                AttackPathPriorityScore_Path = max(AttackPathPriorityScore),
                AttackPathPriority_Path      = any(AttackPathPriority),

                TargetCriticalityTier_Path      = any(TargetCriticalityTier),
                TargetCriticalityTierLevel_Path = any(TargetCriticalityTierLevel),
                TargetRiskProb_Path             = max(TargetRiskProb),

                TargetRiskProbDetailed_Path      = any(TargetRiskProbDetailed),
                TargetRiskProbDetailedScore_Path = any(TargetRiskProbDetailedScore),

                CredentialLabels_Path = make_set(tostring(CredentialNodeLabel)),
                SourceAssets_Path     = make_set(tostring(FirstGitHubSourceName)),
                TotalIssues_Path      = count()
              by
                PathKey,
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,
                FinalTargetId;


        // Step 12  Build main summary
        let SummaryMain =
            CollapsedPaths
            | summarize
                ConfigurationId = strcat_array(array_sort_asc(make_set(strcat_array(CredentialLabels_Path, ";"))), ";"),

                SecuritySeverity = any(AttackPathPriority_Path),
                CriticalityTier = toint(any(TargetCriticalityTier_Path)),
                CriticalityTierLevel = tostring(any(TargetCriticalityTierLevel_Path)),

                RiskFactor_Consequence = 0,
                RiskFactor_Probability = max(TargetRiskProb_Path),

                AssetCount   = dcount(FinalTargetId),
                TotalIssues  = sum(TotalIssues_Path),

                ImpactedAssets = strcat_array(array_sort_asc(make_set(strcat_array(SourceAssets_Path, ";"))), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 13  Build probability detail summary
        let SummaryDetail =
            CollapsedPaths
            | extend _d = split(tostring(TargetRiskProbDetailed_Path), ";")
            | mv-expand _d to typeof(string)
            | extend _d = trim(" ", _d)
            | where isnotempty(_d)
            | summarize
                RiskFactor_Probability_Detailed = strcat_array(array_sort_asc(make_set(_d)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 14  Build probability detail score summary
        let SummaryDetailScore =
            CollapsedPaths
            | extend _s = split(tostring(TargetRiskProbDetailedScore_Path), ";")
            | mv-expand _s to typeof(string)
            | extend _s = trim(" ", _s)
            | where isnotempty(_s)
            | summarize
                RiskFactor_Probability_DetailedScore = strcat_array(array_sort_asc(make_set(_s)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 15  Emit final collapsed output
        SummaryMain
        | join kind=leftouter SummaryDetail on SecurityDomain, Category, SubCategory, ConfigurationName
        | join kind=leftouter SummaryDetailScore on SecurityDomain, Category, SubCategory, ConfigurationName
        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,
            SecuritySeverity,
            CriticalityTier,
            CriticalityTierLevel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by
            RiskFactor_Probability desc,
            CriticalityTier asc,
            TotalIssues desc,
            AssetCount desc

  - ReportName: Attack_Paths_Detailed_Github_to_Azure_Resources
    ReportPurpose: Attack Paths - Github to Azure resources.  GitHub -> Secret -> Azure Resource. Key Detection -> Supply chain compromise
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Credential driven attack paths from GitHub to Azure using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify credentials stored in GitHub workflows or repositories and trace credential driven
        // attack paths into Azure targets. Paths are prioritized by the business impact of the FINAL TARGET.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the TARGET criticality tier first
        // - Then by tier escalation where source tier is higher than target tier
        // - Then by Internet exposure where target exposure is weighted higher than source exposure
        // - GitHub sources are treated as Internet exposed and low trust by default
        // - A low tier source can never outrank a tier 0 or tier 1 target
        //
        // Output description
        // One row per unique credential to target attack path enriched with
        // - Internet exposure flags
        // - Asset tier from tags
        // - Legacy operating system and end of support signals
        // - Risk factor probability including detailed breakdown
        // - Attack path priority score and severity
        // - Human readable attack path strings
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone
        // Step 2  Normalize node labels to avoid filter issues
        // Step 3  Identify credentials stored in GitHub workflows and repositories
        // Step 4  Hop 1 credential authenticates as an identity
        // Step 5  Hop 2 identity can reach Azure target resources
        // Step 6  De duplicate attack paths to a stable grain
        // Step 7  Enrich source and target nodes using Nodes catalog
        // Step 8  Calculate tier escalation lateral movement and priority score
        // Step 9  Build human readable AttackPath and AttackPathDetailed
        // Step 10 Project final report columns and apply ordering
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability (same as CVE report)
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths (UPDATED to match your standard context)
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            // Criticality extraction from multiple possible fields
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            // Internet exposure flag derived from graph property isCustomerFacing renamed
            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            // Exclusion flag
            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            // Normalize rawData and raw for tag and OS reading
            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            // AssetTierByTag preferred bag key AssetTier fallback tag array scan
            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            // Tag fallback mapping only used when Defender criticality is missing
            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            // Prefer Defender criticality over tag
            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            // LegacyEndOfSupport detection same as CVE report
            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            // Risk factors on nodes count distinct plus Internet-Exposed plus LegacyEoS
            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Normalize labels to avoid typos breaking filters
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };


        // Step 3  Find credentials in GitHub workflows/repositories
        let GitHubCredentials =
            ExposureGraphEdges
            | where EdgeLabel in ("contains", "defined in")
            | extend SourceNodeLabelNorm = NormalizeLabel(SourceNodeLabel),
                     TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where SourceNodeLabelNorm in ("githubworkflow", "githubrepository")
            | where TargetNodeLabelNorm in (
                "azure-active-directory-app-secret",
                "user-azure-cli-secret",
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-user-credentials",
                "service-principal-azure-cli-secret",
                "azure-app-configuration-key"
            )
            | project
                SourceGitHubNodeId    = SourceNodeId,
                SourceGitHubNodeName  = SourceNodeName,
                SourceGitHubNodeLabel = SourceNodeLabel,
                CredentialNodeId      = TargetNodeId,
                CredentialNodeName    = TargetNodeName,
                CredentialNodeLabel   = TargetNodeLabel
            | summarize
                GitHubSources          = make_set(SourceGitHubNodeName),
                GitHubSourceTypes      = make_set(SourceGitHubNodeLabel),
                GitHubSourceCount      = dcount(SourceGitHubNodeId),
                FirstGitHubSource      = any(SourceGitHubNodeId),
                FirstGitHubSourceName  = any(SourceGitHubNodeName),
                FirstGitHubSourceLabel = any(SourceGitHubNodeLabel)
              by CredentialNodeId, CredentialNodeName, CredentialNodeLabel;


        // Step 4  Main attack path query GitHub Credential -> Identity
        GitHubCredentials
        | join kind=inner (
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                Hop1_SourceCredentialId = SourceNodeId,
                Hop1_EdgeLabel          = EdgeLabel,
                IntermediateIdentityId  = TargetNodeId,
                IntermediateIdentity    = TargetNodeName,
                IntermediateIdentityLabel = TargetNodeLabel
        ) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId

        // Step 5  Hop 2 Identity -> Azure Target
        | join kind=inner (
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "has permissions to", "has role on")
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.compute/virtualmachines",
                "microsoft.storage/storageaccounts",
                "microsoft.keyvault/vaults",
                "microsoft.sql/servers",
                "microsoft.sql/servers/databases",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts_openai",
                "subscriptions",
                "resourcegroups",
                "blobcontainer"
            )
            | project
                Hop2_SourceIdentityId = SourceNodeId,
                Hop2_EdgeLabel        = EdgeLabel,
                FinalTargetId         = TargetNodeId,
                FinalTargetName       = TargetNodeName,
                FinalTargetLabel      = TargetNodeLabel
        ) on $left.IntermediateIdentityId == $right.Hop2_SourceIdentityId

        // Optional avoid GitHub source == target asset scenarios (usually not needed but safe)
        | where FirstGitHubSource != FinalTargetId

        // Step 6  De-duplicate to stable grain
        | summarize
            GitHubSources          = any(GitHubSources),
            GitHubSourceTypes      = any(GitHubSourceTypes),
            GitHubSourceCount      = any(GitHubSourceCount),
            FirstGitHubSource      = any(FirstGitHubSource),
            FirstGitHubSourceName  = any(FirstGitHubSourceName),
            FirstGitHubSourceLabel = any(FirstGitHubSourceLabel),

            CredentialNodeName     = any(CredentialNodeName),
            CredentialNodeLabel    = any(CredentialNodeLabel),

            IntermediateIdentityId    = any(IntermediateIdentityId),
            IntermediateIdentity      = any(IntermediateIdentity),
            IntermediateIdentityLabel = any(IntermediateIdentityLabel),

            Hop1Edge = any(Hop1_EdgeLabel),
            Hop2Edge = any(Hop2_EdgeLabel),

            FinalTargetName  = any(FinalTargetName),
            FinalTargetLabel = any(FinalTargetLabel)
          by CredentialNodeId, FinalTargetId

        // Step 7  Enrich SOURCE + TARGET using Nodes (context-standard fields)
        | join kind=leftouter (
            Nodes
            | project-rename
                SourceNodeId                = NodeId,
                SourceNodeName              = NodeName,
                SourceNodeLabel             = NodeLabel,
                SourceCriticalityTier       = CriticalityTier,
                SourceCriticalityTierLevel  = CriticalityTierLevel,
                SourceIsInternetExposed     = IsInternetExposed,
                SourceIsExcluded            = IsExcluded,
                SourceAssetTierByTag        = AssetTierByTag,
                SourceLegacyEndOfSupport    = LegacyEndOfSupport,
                SourceRiskProb              = RiskFactor_Probability,
                SourceRiskProbDetailed      = RiskFactor_Probability_Detailed,
                SourceRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                SourceNodeProperties        = NodeProperties
        ) on $left.FirstGitHubSource == $right.SourceNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                = NodeId,
                TargetNodeName              = NodeName,
                TargetNodeLabel             = NodeLabel,
                TargetCriticalityTier       = CriticalityTier,
                TargetCriticalityTierLevel  = CriticalityTierLevel,
                TargetIsInternetExposed     = IsInternetExposed,
                TargetIsExcluded            = IsExcluded,
                TargetAssetTierByTag        = AssetTierByTag,
                TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                TargetRiskProb              = RiskFactor_Probability,
                TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                TargetNodeProperties        = NodeProperties
        ) on $left.FinalTargetId == $right.TargetNodeId

        // Step 8  Apply your standard prioritization logic (GitHub treated as Internet-exposed / low trust)
        | extend
            // GitHub is internet-facing by default (override if Nodes is missing or false)
            SourceIsInternetExposed = true,
            // GitHub treated as low trust force source tier=3 if Nodes did not map it
            SourceCriticalityTier   = toint(coalesce(SourceCriticalityTier, 3)),
            SourceCriticalityTierLevel = tostring(coalesce(SourceCriticalityTierLevel, "Low - tier 3"))

        // Tier escalation (only if source tier > target tier)
        | extend TierEscalation =
            case(
                isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                    SourceCriticalityTier - TargetCriticalityTier,
                0
            )
        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        // Standard AttackPathPriorityScore components
        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )
        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
        | extend SourceTierAmplifier =
            case(
                SourceCriticalityTier == 0, 8,
                SourceCriticalityTier == 1, 5,
                SourceCriticalityTier == 2, 2,
                0
            )
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )

        // Step 9  Human readable paths and Internet-Exposed wording
        | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
        | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

        | extend AttackPath =
            strcat(
                FirstGitHubSourceLabel, " [", FirstGitHubSourceName, "] -> ",
                CredentialNodeLabel, " [", CredentialNodeName, "] -> ",
                IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                FinalTargetLabel, " [", FinalTargetName, "]"
            )

        | extend AttackPathDetailed =
            strcat(
                "SOURCE ", FirstGitHubSourceLabel, " [", FirstGitHubSourceName, "] ",
                "tier ", tostring(SourceCriticalityTier), " ", SourceCriticalityTierLevel, " | ", InternetExposureSource,
                iff(GitHubSourceCount > 1, strcat(" | + ", tostring(GitHubSourceCount - 1), " other GitHub source(s)"), ""),
                " -> CREDENTIAL ", CredentialNodeLabel, " [", CredentialNodeName, "] ",
                " -> IDENTITY ", IntermediateIdentityLabel, " [", IntermediateIdentity, "] ",
                " -> TARGET ", FinalTargetLabel, " [", FinalTargetName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", TargetCriticalityTierLevel, " | ", InternetExposureTarget,
                " | escalation ", tostring(TierEscalation),
                " | ", LateralMovementType
            )

        // Final projection (keeps your original taxonomy fields but aligned to the context-standard logic)
        | extend SecurityDomain = "Supply Chain"
        | extend Category = "AttackPath_GitHubToAzure"
        | extend Subcategory =
            case(
                TierEscalation >= 3, strcat("GitHub to Tier ", tostring(TargetCriticalityTier), " - Critical Supply Chain Risk"),
                TierEscalation >= 2, strcat("GitHub to Tier ", tostring(TargetCriticalityTier), " - High Supply Chain Risk"),
                TierEscalation >= 1, strcat("GitHub to Tier ", tostring(TargetCriticalityTier), " - Moderate Supply Chain Risk"),
                "GitHub to Azure - Direct Access"
            )

        | project
            SecurityDomain,
            Category,
            Subcategory,

            // Priority outputs (context-standard)
            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,
            EscalationWeight,
            ExposureWeight,

            // Source (GitHub)
            FirstGitHubSource,
            FirstGitHubSourceName,
            FirstGitHubSourceLabel,
            TotalGitHubSourcesWithCredential = GitHubSourceCount,
            AllGitHubSources = GitHubSources,
            GitHubSourceTypes,

            // Credential
            CredentialNodeId,
            CredentialNodeName,
            CredentialNodeLabel,

            // Identity + Target
            IntermediateIdentityId,
            IntermediateIdentity,
            IntermediateIdentityType = IntermediateIdentityLabel,

            FinalTargetId,
            FinalTarget = FinalTargetName,
            FinalTargetType = FinalTargetLabel,

            // Target criticality + enrichment (context-standard)
            CriticalityTier = TargetCriticalityTier,
            CriticalityTierLevel = TargetCriticalityTierLevel,
            TargetAssetTierByTag,
            TargetIsInternetExposed,
            TargetLegacyEndOfSupport,
            TargetRiskProb,
            TargetRiskProbDetailed,
            TargetRiskProbDetailedScore,
            TargetCriticalityRuleBased = CriticalityRuleBased1,
            TargetCriticalityRuleNames = CriticalityRuleNames1,

            // Source enrichment (context-standard)
            SourceAssetTierByTag,
            SourceLegacyEndOfSupport,
            SourceRiskProb,
            SourceRiskProbDetailed,
            SourceRiskProbDetailedScore,

            // Paths + edges
            Hop1Edge,
            Hop2Edge,

            // Human readable
            AttackPath,
            AttackPathDetailed,

            // NodeProperties for drilldown
            SourceNodeProperties,
            TargetNodeProperties

        | order by AttackPathPriorityScore desc, TierEscalation desc, CriticalityTier asc

  - ReportName: Attack_Paths_Summary_Public_IP_to_VM_with_CVE_Exploitation
    ReportPurpose: Attack Paths with focus on Public IP to VM with CVE Exploitation. Public IP -> Vulnerable VM/Device. Key detection -> Internet-exposed vulnerabilities
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Internet exposed assets with vulnerabilities using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify Azure and endpoint resources that are connected to Public IP addresses and are affected by CVEs.
        // Each finding represents an internet reachable resource with at least one known vulnerability.
        // Results are prioritized by the business impact of the exposed resource and by CVE severity signals.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the exposed TARGET resource criticality tier first
        // - Internet exposure is implied by the presence of a Public IP connection
        // - CVE severity increases priority as an additional amplifier
        // - Target criticality tier comes from Defender criticality when present with tag fallback
        // - RiskFactor probability is derived from graph risk factors plus Internet-Exposed plus LegacyEndOfSupport
        //
        // Output description detailed table
        // One row per unique PublicIP -> ExposedResource -> CVE combination enriched with
        // - Target criticality tier and tier label
        // - Target Internet exposure flags and tag derived asset tier
        // - Target legacy OS end of support signal
        // - Target risk probability including detailed breakdown fields
        // - CVE severity text and a numeric CVESeverityScore
        // - Priority score and mapped severity label
        // - Human readable AttackPath and AttackPathDetailed strings
        //
        // Output description collapsed summary
        // One row per report grain grouped by SecurityDomain Category SubCategory ConfigurationName where
        // - Duplicate paths are collapsed so repeated Public IPs or CVEs do not inflate counts
        // - ConfigurationId becomes a semicolon list of distinct CVE names in the group
        // - ImpactedAssets becomes a semicolon list of distinct exposed resources
        // - RiskFactor_Probability_Detailed fields are preserved via split expand and re aggregation
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone
        // Step 2  Normalize node labels to avoid filter issues
        // Step 3  Identify Public IP connections to resources
        // Step 4  Identify CVEs affecting resources
        // Step 5  Join Public IP connections with CVE affected resources and de duplicate to stable grain
        // Step 6  Enrich exposed resource using Nodes and enrich CVE node for severity text
        // Step 7  Compute CVE severity score and target tier weighted priority score
        // Step 8  Create AttackPath and AttackPathDetailed strings and project detailed output table
        // Step 9  Create DetailedForSummary table with only required columns for collapsing
        // Step 10 Collapse to unique logical PathKey to prevent count inflation
        // Step 11 Build SummaryMain counts and key fields
        // Step 12 Re build RiskFactor_Probability_Detailed and DetailedScore via split expand and re aggregation
        // Step 13 Join summary parts and output final collapsed summary ordering
        // =================================================================================================

        // Step 0  Define legacy operating systems that should increase probability (same as CVE report)
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))

            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | extend CVESeverity =
                tostring(coalesce(
                    NodeProperties.rawData.severity,
                    NodeProperties.rawData.Severity,
                    NodeProperties.rawData.cvssScore,
                    ""
                ))

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence,
                CVESeverity;


        // Step 2  Normalize labels to avoid typos breaking filters
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };


        // Step 3  Find Public IPs connected to resources
        let PublicIPConnections =
            ExposureGraphEdges
            | where SourceNodeLabel == "microsoft.network/publicipaddresses"
            | where EdgeLabel in ("routes traffic to", "contains")
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.network/networkinterfaces",
                "microsoft.compute/virtualmachines",
                "device",
                "computer-account"
            )
            | project
                PublicIPNodeId            = SourceNodeId,
                PublicIPNodeName          = SourceNodeName,
                ExposedResourceNodeId     = TargetNodeId,
                ExposedResourceNodeName   = TargetNodeName,
                ExposedResourceNodeLabel  = TargetNodeLabel
            | summarize
                PublicIPs         = make_set(PublicIPNodeName),
                PublicIPCount     = dcount(PublicIPNodeId),
                FirstPublicIPId   = any(PublicIPNodeId),
                FirstPublicIPName = any(PublicIPNodeName)
              by ExposedResourceNodeId, ExposedResourceNodeName, ExposedResourceNodeLabel;


        // Step 4  Find CVEs affecting resources
        let CVEsAffectingResources =
            ExposureGraphEdges
            | where SourceNodeLabel == "Cve"
            | where EdgeLabel == "affecting"
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.compute/virtualmachines",
                "device",
                "computer-account"
            )
            | project
                CVENodeId                  = SourceNodeId,
                CVENodeName                = SourceNodeName,
                AffectedResourceNodeId     = TargetNodeId,
                AffectedResourceNodeName   = TargetNodeName,
                AffectedResourceNodeLabel  = TargetNodeLabel
            | summarize
                CVEs         = make_set(CVENodeName),
                CVECount     = dcount(CVENodeId),
                FirstCVEId   = any(CVENodeId),
                FirstCVEName = any(CVENodeName)
              by AffectedResourceNodeId, AffectedResourceNodeName, AffectedResourceNodeLabel;


        // Step 5  Assemble detailed records and de duplicate
        // Important fix
        // Do not aggregate FirstPublicIPId or FirstCVEId when they are in the by clause
        let Paths =
            PublicIPConnections
            | join kind=inner (CVEsAffectingResources) on $left.ExposedResourceNodeId == $right.AffectedResourceNodeId
            | summarize
                PublicIPs               = any(PublicIPs),
                PublicIPCount           = any(PublicIPCount),
                FirstPublicIPName       = any(FirstPublicIPName),

                CVEs                    = any(CVEs),
                CVECount                = any(CVECount),
                FirstCVEName            = any(FirstCVEName),

                ExposedResourceNodeName  = any(ExposedResourceNodeName),
                ExposedResourceNodeLabel = any(ExposedResourceNodeLabel)
              by
                ExposedResourceNodeId,
                FirstPublicIPId,
                FirstCVEId;


        // Step 6-8  Build the detailed output table
        let Detailed =
            Paths

            | join kind=leftouter (
                Nodes
                | project-rename
                    TargetNodeId                = NodeId,
                    TargetNodeName              = NodeName,
                    TargetNodeLabel             = NodeLabel,
                    TargetCriticalityTier       = CriticalityTier,
                    TargetCriticalityTierLevel  = CriticalityTierLevel,
                    TargetCriticalityRuleBased  = CriticalityRuleBased,
                    TargetCriticalityRuleNames  = CriticalityRuleNames,
                    TargetIsInternetExposed     = IsInternetExposed,
                    TargetIsExcluded            = IsExcluded,
                    TargetAssetTierByTag        = AssetTierByTag,
                    TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                    TargetRiskProb              = RiskFactor_Probability,
                    TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                    TargetNodeProperties        = NodeProperties
            ) on $left.ExposedResourceNodeId == $right.TargetNodeId

            | join kind=leftouter (
                Nodes
                | project-rename
                    PublicIPNodeId_join      = NodeId,
                    PublicIPNodeName_join    = NodeName,
                    PublicIPNodeProperties   = NodeProperties
            ) on $left.FirstPublicIPId == $right.PublicIPNodeId_join

            | join kind=leftouter (
                Nodes
                | project-rename
                    CVENodeId_join        = NodeId,
                    CVENodeName_join      = NodeName,
                    CVESeverity_join      = CVESeverity,
                    CVENodeProperties     = NodeProperties
            ) on $left.FirstCVEId == $right.CVENodeId_join

            | extend CVESev = tostring(coalesce(CVESeverity_join, ""))

            | extend CVESeverityScore =
                case(
                    tolower(CVESev) has "critical", 5,
                    tolower(CVESev) has "high", 4,
                    tolower(CVESev) has "medium", 3,
                    tolower(CVESev) has "low", 2,
                    1
                )

            | extend TargetTierWeight =
                case(
                    TargetCriticalityTier == 0, 100,
                    TargetCriticalityTier == 1, 60,
                    TargetCriticalityTier == 2, 30,
                    10
                )

            | extend ExposureWeight = 8

            | extend AttackPathPriorityScore = TargetTierWeight + ExposureWeight + (CVESeverityScore * 2)

            | extend AttackPathPriority =
                case(
                    AttackPathPriorityScore >= 120, "Critical",
                    AttackPathPriorityScore >= 90,  "Very High",
                    AttackPathPriorityScore >= 60,  "High",
                    AttackPathPriorityScore >= 30,  "Medium-High",
                    AttackPathPriorityScore >= 15,  "Medium",
                    "Low"
                )

            | extend AttackPath =
                strcat(
                    "PublicIP [", FirstPublicIPName, "] -> ",
                    ExposedResourceNodeLabel, " [", ExposedResourceNodeName, "] <- ",
                    "CVE [", FirstCVEName, "]"
                )

            | extend AttackPathDetailed =
                strcat(
                    "PUBLICIP [", FirstPublicIPName, "] ",
                    iff(PublicIPCount > 1, strcat("| + ", tostring(PublicIPCount - 1), " other PublicIP(s)"), ""),
                    " -> TARGET ", ExposedResourceNodeLabel, " [", ExposedResourceNodeName, "] ",
                    "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " ",
                    "| CVE [", FirstCVEName, "] ",
                    "| CVESeverity ", CVESev,
                    iff(CVECount > 1, strcat(" | + ", tostring(CVECount - 1), " other CVE(s)"), "")
                )

            | extend SecurityDomain = "Internet-Exposed Assets"
            | extend Category = "Attack Paths"
            | extend SubCategory = "InternetExposedVulnerability"
            | extend ConfigurationName = "PublicIPWithCVE"
            | extend ConfigurationId = tostring(FirstCVEName)
            | extend SecuritySeverity = AttackPathPriority
            | extend RiskFactor_Consequence = 0

            | project
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,
                ConfigurationId,

                SecuritySeverity,
                AttackPathPriorityScore,

                ExposedResourceNodeId,
                ExposedResourceNodeName,
                ExposedResourceNodeLabel,

                TargetCriticalityTier,
                TargetCriticalityTierLevel,
                TargetCriticalityRuleBased,
                TargetCriticalityRuleNames,

                TargetAssetTierByTag,
                TargetIsInternetExposed,
                TargetLegacyEndOfSupport,
                TargetRiskProb,
                TargetRiskProbDetailed,
                TargetRiskProbDetailedScore,

                PublicIPCount,
                PublicIPs,
                FirstPublicIPId,
                FirstPublicIPName,

                CVECount,
                CVEs,
                FirstCVEId,
                FirstCVEName,
                CVESev,
                CVESeverityScore,

                AttackPath,
                AttackPathDetailed,

                TargetNodeProperties,
                PublicIPNodeProperties,
                CVENodeProperties;


        // ===================== COLLAPSED SUMMARY VERSION (FINAL OUTPUT) =====================


        // Step 9  Prepare a clean detailed shape for collapsing
        let DetailedForSummary =
            Detailed
            | project
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,

                ExposedResourceNodeId,
                ExposedResourceNodeName,

                TargetCriticalityTier,
                TargetCriticalityTierLevel,
                TargetRiskProb,
                TargetRiskProbDetailed,
                TargetRiskProbDetailedScore,

                AttackPathPriorityScore,
                SecuritySeverity,

                FirstPublicIPId,
                FirstPublicIPName,
                FirstCVEId,
                FirstCVEName;


        // Step 10  Collapse to unique logical path so PublicIP spam and CVE spam do not multiply counts
        let CollapsedPaths =
            DetailedForSummary
            | extend PathKey = strcat(FirstPublicIPId, "->", ExposedResourceNodeId, "->", FirstCVEId)
            | summarize
                AttackPathPriorityScore_Path = max(AttackPathPriorityScore),
                SecuritySeverity_Path        = any(SecuritySeverity),

                TargetCriticalityTier_Path      = any(TargetCriticalityTier),
                TargetCriticalityTierLevel_Path = any(TargetCriticalityTierLevel),
                TargetRiskProb_Path             = max(TargetRiskProb),

                TargetRiskProbDetailed_Path      = any(TargetRiskProbDetailed),
                TargetRiskProbDetailedScore_Path = any(TargetRiskProbDetailedScore),

                CVEs_Path      = make_set(tostring(FirstCVEName)),
                PublicIPs_Path = make_set(tostring(FirstPublicIPName)),

                SourceAssets_Path = make_set(tostring(ExposedResourceNodeName)),
                TotalIssues_Path  = count()
              by
                PathKey,
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,
                ExposedResourceNodeId;


        // Step 11  Main summary (counts stay correct)
        let SummaryMain =
            CollapsedPaths
            | summarize
                ConfigurationId = strcat_array(array_sort_asc(make_set(strcat_array(CVEs_Path, ";"))), ";"),

                SecuritySeverity = any(SecuritySeverity_Path),
                CriticalityTier = toint(any(TargetCriticalityTier_Path)),
                CriticalityTierLevel = tostring(any(TargetCriticalityTierLevel_Path)),

                RiskFactor_Consequence = 0,
                RiskFactor_Probability = max(TargetRiskProb_Path),

                AssetCount   = dcount(ExposedResourceNodeId),
                TotalIssues  = sum(TotalIssues_Path),

                ImpactedAssets = strcat_array(array_sort_asc(make_set(strcat_array(SourceAssets_Path, ";"))), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 12  Detail flattening split -> mv-expand -> make_set -> join once
        let SummaryDetail =
            CollapsedPaths
            | extend _d = split(tostring(TargetRiskProbDetailed_Path), ";")
            | mv-expand _d to typeof(string)
            | extend _d = trim(" ", _d)
            | where isnotempty(_d)
            | summarize
                RiskFactor_Probability_Detailed = strcat_array(array_sort_asc(make_set(_d)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        let SummaryDetailScore =
            CollapsedPaths
            | extend _s = split(tostring(TargetRiskProbDetailedScore_Path), ";")
            | mv-expand _s to typeof(string)
            | extend _s = trim(" ", _s)
            | where isnotempty(_s)
            | summarize
                RiskFactor_Probability_DetailedScore = strcat_array(array_sort_asc(make_set(_s)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 13  Final output
        SummaryMain
        | join kind=leftouter SummaryDetail on SecurityDomain, Category, SubCategory, ConfigurationName
        | project-away SecurityDomain1, Category1, SubCategory1, ConfigurationName1
        | join kind=leftouter SummaryDetailScore on SecurityDomain, Category, SubCategory, ConfigurationName
        | project-away SecurityDomain1, Category1, SubCategory1, ConfigurationName1
        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,
            SecuritySeverity,
            CriticalityTier,
            CriticalityTierLevel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by
            RiskFactor_Probability desc,
            CriticalityTier asc,
            TotalIssues desc,
            AssetCount desc

  - ReportName: Attack_Paths_Detailed_Public_IP_to_VM_with_CVE_Exploitation
    ReportPurpose: Attack Paths with focus on Public IP to VM with CVE Exploitation. Public IP -> Vulnerable VM/Device. Key detection -> Internet-exposed vulnerabilities
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Internet exposed assets with vulnerabilities using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify resources that are reachable from a Public IP and have CVEs affecting them.
        // Results are prioritized by the business impact of the exposed resource.
        // Uses the same enrichment backbone as your credential driven attack path reports.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the EXPOSED RESOURCE criticality tier first
        // - Internet exposure is explicit because a Public IP is the entry point
        // - Legacy end of support and risk factors increase probability scoring
        // - CVE severity is included as supporting signal not the primary driver
        //
        // Output description
        // One row per exposed resource with at least one Public IP connection and at least one CVE
        // Includes enrichment fields
        // - IsInternetExposed
        // - AssetTierByTag
        // - LegacyEndOfSupport
        // - RiskFactor_Probability and detailed breakdown
        // - AttackPathPriorityScore and severity
        // - Human readable AttackPath strings
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone
        // Step 2  Normalize node labels to avoid filter issues
        // Step 3  Find Public IP connections to resources
        // Step 4  Find CVEs affecting resources
        // Step 5  Join Public IP connections with CVEs and de duplicate
        // Step 6  Enrich exposed resource and CVE using Nodes
        // Step 7  Compute CVE severity score and attack path priority score
        // Step 8  Build AttackPath and AttackPathDetailed
        // Step 9  Project final columns and apply ordering
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich results (context standard)
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | extend CVESeverity =
                tostring(coalesce(
                    NodeProperties.rawData.severity,
                    NodeProperties.rawData.Severity,
                    NodeProperties.rawData.cvssScore,
                    ""
                ))

            | extend IsEntryPoint =
                        (CategoriesStr has "ip_address")
                     or (CategoriesStr has "device")
                     or (CategoriesStr has "virtual_machine")
                     or (CategoriesStr has "computer"),
                     IsAzureResource =
                        (CategoriesStr has "environmentazure")
                     or (CategoriesStr has "environmentcloud")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence,
                CVESeverity,
                IsEntryPoint,
                IsAzureResource;


        // Step 2  Helper to avoid label typos or spaces
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };


        // Step 3  Find Public IPs connected to resources
        let PublicIPConnections =
            ExposureGraphEdges
            | where SourceNodeLabel == "microsoft.network/publicipaddresses"
            | where EdgeLabel in ("routes traffic to", "contains")
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.network/networkinterfaces",
                "microsoft.compute/virtualmachines",
                "device"
            )
            | project
                PublicIPNodeId            = SourceNodeId,
                PublicIPNodeName          = SourceNodeName,
                ExposedResourceNodeId     = TargetNodeId,
                ExposedResourceNodeName   = TargetNodeName,
                ExposedResourceNodeLabel  = TargetNodeLabel
            | summarize
                PublicIPs         = make_set(PublicIPNodeName),
                PublicIPCount     = dcount(PublicIPNodeId),
                FirstPublicIP     = any(PublicIPNodeId),
                FirstPublicIPName = any(PublicIPNodeName)
              by ExposedResourceNodeId, ExposedResourceNodeName, ExposedResourceNodeLabel;


        // Step 4  Find CVEs affecting resources
        let CVEsAffectingResources =
            ExposureGraphEdges
            | where SourceNodeLabel == "Cve"
            | where EdgeLabel == "affecting"
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.compute/virtualmachines",
                "device",
                "computer-account"
            )
            | project
                CVENodeId                  = SourceNodeId,
                CVENodeName                = SourceNodeName,
                AffectedResourceNodeId     = TargetNodeId,
                AffectedResourceNodeName   = TargetNodeName,
                AffectedResourceNodeLabel  = TargetNodeLabel
            | summarize
                CVEs         = make_set(CVENodeName),
                CVECount     = dcount(CVENodeId),
                FirstCVE     = any(CVENodeId),
                FirstCVEName = any(CVENodeName)
              by AffectedResourceNodeId, AffectedResourceNodeName, AffectedResourceNodeLabel;


        // Step 5  Join Public IPs with CVEs and de duplicate
        PublicIPConnections
        | join kind=inner CVEsAffectingResources on $left.ExposedResourceNodeId == $right.AffectedResourceNodeId
        | summarize
            PublicIPs         = any(PublicIPs),
            PublicIPCount     = any(PublicIPCount),
            FirstPublicIPName = any(FirstPublicIPName),

            CVEs              = any(CVEs),
            CVECount          = any(CVECount),
            FirstCVEName      = any(FirstCVEName),
            FirstCVE          = any(FirstCVE)
          by ExposedResourceNodeId, ExposedResourceNodeName, ExposedResourceNodeLabel


        // Step 6  Enrich exposed resource and CVE using Nodes
        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                = NodeId,
                TargetNodeName              = NodeName,
                TargetNodeLabel             = NodeLabel,
                TargetCriticalityTier       = CriticalityTier,
                TargetCriticalityTierLevel  = CriticalityTierLevel,
                TargetCriticalityRuleBased  = CriticalityRuleBased,
                TargetCriticalityRuleNames  = CriticalityRuleNames,
                TargetIsInternetExposed     = IsInternetExposed,
                TargetIsExcluded            = IsExcluded,
                TargetAssetTierByTag        = AssetTierByTag,
                TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                TargetRiskProb              = RiskFactor_Probability,
                TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                TargetNodeProperties        = NodeProperties
        ) on $left.ExposedResourceNodeId == $right.TargetNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                CVENodeId_join      = NodeId,
                CVENodeName_join    = NodeName,
                CVESeverity_join    = CVESeverity,
                CVENodeProperties   = NodeProperties
        ) on $left.FirstCVE == $right.CVENodeId_join


        // Step 7  Compute CVE severity score and attack path priority score
        | extend CVESev = tostring(coalesce(CVESeverity_join, ""))

        | extend CVESeverityScore =
            case(
                tolower(CVESev) has "critical", 5,
                tolower(CVESev) has "high", 4,
                tolower(CVESev) has "medium", 3,
                tolower(CVESev) has "low", 2,
                1
            )

        | extend
            SourceIsInternetExposed = true,
            SourceCriticalityTier   = 3,
            SourceCriticalityTierLevel = "Low - tier 3"

        | extend TierEscalation =
            case(
                SourceCriticalityTier > TargetCriticalityTier, SourceCriticalityTier - TargetCriticalityTier,
                0
            )

        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )

        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = 8
        | extend SourceTierAmplifier = 0
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )

        | extend SecuritySeverityScore =
            case(
                TargetCriticalityTier == 0 and CVESeverityScore >= 4, 10,
                TargetCriticalityTier == 0 and CVESeverityScore >= 3, 9,
                TargetCriticalityTier == 1 and CVESeverityScore >= 4, 8,
                TargetCriticalityTier == 1 and CVESeverityScore >= 3, 7,
                TargetCriticalityTier == 2 and CVESeverityScore >= 4, 6,
                CVESeverityScore >= 4, 5,
                CVESeverityScore >= 3, 4,
                3
            )

        | extend SecuritySeverityLevel =
            case(
                SecuritySeverityScore >= 9, "Critical",
                SecuritySeverityScore >= 7, "Very High",
                SecuritySeverityScore >= 5, "High",
                SecuritySeverityScore >= 3, "Medium-High",
                "Medium"
            )

        | extend SecurityDomain = "Internet-Exposed Assets"
        | extend Category = "AttackPath_PublicIPWithCVE"
        | extend Subcategory =
            case(
                TargetCriticalityTier == 0 and CVESeverityScore >= 4, "Tier 0 - Internet-Exposed with Critical CVE",
                TargetCriticalityTier == 0, "Tier 0 - Internet-Exposed with Vulnerability",
                TargetCriticalityTier == 1 and CVESeverityScore >= 4, "Tier 1 - Internet-Exposed with Critical CVE",
                TargetCriticalityTier == 1, "Tier 1 - Internet-Exposed with Vulnerability",
                CVESeverityScore >= 4, "Internet-Exposed with Critical CVE",
                "Internet-Exposed with Vulnerability"
            )


        // Step 8  Build AttackPath and AttackPathDetailed
        | extend AttackPath =
            strcat(
                "Public IP [", FirstPublicIPName, "] -> ",
                ExposedResourceNodeLabel, " [", ExposedResourceNodeName, "] <- ",
                "CVE [", FirstCVEName, "]"
            )

        | extend AttackPathDetailed =
            strcat(
                "PUBLIC IP [", FirstPublicIPName, "] ",
                iff(PublicIPCount > 1, strcat("| + ", tostring(PublicIPCount - 1), " other IP(s)"), ""),
                " -> EXPOSED ", ExposedResourceNodeLabel, " [", ExposedResourceNodeName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", TargetCriticalityTierLevel, " | Internet-Exposed",
                " | AssetTierByTag ", tostring(TargetAssetTierByTag),
                " | LegacyEndOfSupport ", tostring(TargetLegacyEndOfSupport),
                " <- CVE [", FirstCVEName, "] ",
                "severity ", CVESev,
                iff(CVECount > 1, strcat("| + ", tostring(CVECount - 1), " other CVE(s)"), "")
            )


        // Step 9  Project final columns and apply ordering
        | order by AttackPathPriorityScore desc, TargetCriticalityTier asc, CVESeverityScore desc

        | project
            SecurityDomain,
            Category,
            Subcategory,

            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,
            EscalationWeight,
            ExposureWeight,

            AssetName = ExposedResourceNodeName,
            AssetLabel = ExposedResourceNodeLabel,

            ConfigurationName = FirstPublicIPName,
            ConfigurationId = FirstCVEName,

            PublicIPAddress = FirstPublicIPName,
            TotalPublicIPs = PublicIPCount,
            AllPublicIPs = PublicIPs,

            CVE = FirstCVEName,
            TotalCVEs = CVECount,
            AllCVEs = CVEs,
            CVESeverity = CVESev,

            ExposedResource = ExposedResourceNodeName,
            ExposedResourceType = ExposedResourceNodeLabel,

            CriticalityTier = TargetCriticalityTier,
            CriticalityTierLevel = TargetCriticalityTierLevel,
            CriticalityRuleBased = TargetCriticalityRuleBased,
            CriticalityRuleNames = TargetCriticalityRuleNames,

            IsInternetExposed = true,
            AssetTierByTag = TargetAssetTierByTag,
            LegacyEndOfSupport = TargetLegacyEndOfSupport,

            RiskProbability = TargetRiskProb,
            RiskProbability_Detailed = TargetRiskProbDetailed,
            RiskProbability_DetailedScore = TargetRiskProbDetailedScore,

            SecuritySeverity = SecuritySeverityLevel,
            SecurityScore = SecuritySeverityScore,

            AttackPath,
            AttackPathDetailed,

            TargetNodeProperties,
            CVENodeProperties


  - ReportName: Attack_Paths_Summary_Identity_Group_Membership_to_Privileged_Resources
    ReportPurpose: Attack Paths based on Identity Group Membership to Privileged Resources. Identity -> Group -> Privileged Resource. Key Detection -> Group-based attacks
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Group membership privilege paths to Azure resources using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify identities that are members of groups and where those groups have permissions or roles on
        // privileged Azure targets. Enrich each path with the standard node context and prioritize by the
        // business impact of the FINAL TARGET. Provide both detailed rows and a collapsed summary output.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the TARGET criticality tier first
        // - Then by tier escalation where source tier is higher than target tier
        // - Then by internet exposure where target exposure is weighted higher than source exposure
        // - The source identity matters as an amplifier but the target drives the priority
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone using standard context fields
        // Step 2  Find identities in groups and de duplicate to a stable group membership grain
        // Step 3  Find group permissions or roles on Azure targets
        // Step 4  Assemble Identity -> Group -> Target paths and de duplicate
        // Step 5  Enrich source identity and target using Nodes catalog
        // Step 6  Apply standard prioritization logic and build attack path strings
        // Step 7  Build detailed output table as Detailed
        // Step 8  Collapse to unique logical path PathKey so identity spam does not multiply counts
        // Step 9  Build SummaryMain counts and key fields
        // Step 10 Re build RiskFactor_Probability_Detailed fields via split expand and re aggregation
        // Step 11 Join summary parts and output final collapsed summary ordering
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))


            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))

            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                NodeProperties,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Find identities in groups and de duplicate
        let IdentityGroupMembership =
            ExposureGraphEdges
            | where EdgeLabel == "member of"
            | where SourceNodeLabel in ("user", "serviceprincipal", "managedidentity")
            | where TargetNodeLabel == "group"
            | project
                IdentityNodeId    = SourceNodeId,
                IdentityNodeName  = SourceNodeName,
                IdentityNodeLabel = SourceNodeLabel,
                GroupNodeId       = TargetNodeId,
                GroupNodeName     = TargetNodeName
            | summarize
                Identities        = make_set(IdentityNodeName),
                IdentityTypes     = make_set(IdentityNodeLabel),
                IdentityCount     = dcount(IdentityNodeId),
                FirstIdentityId   = any(IdentityNodeId),
                FirstIdentityName = any(IdentityNodeName),
                FirstIdentityLabel= any(IdentityNodeLabel)
              by GroupNodeId, GroupNodeName;


        // Step 3  Find group permissions or roles on Azure targets
        let GroupAccessToTargets =
            ExposureGraphEdges
            | where EdgeLabel in ("has role on", "has permissions to")
            | where SourceNodeLabel == "group"
            | where TargetNodeLabel in (
                "subscriptions",
                "resourcegroups",
                "microsoft.keyvault/vaults",
                "microsoft.storage/storageaccounts",
                "microsoft.sql/servers",
                "microsoft.compute/virtualmachines",
                "microsoft.cognitiveservices/accounts"
            )
            | project
                GroupNodeId      = SourceNodeId,
                EdgeLabel        = EdgeLabel,
                FinalTargetId    = TargetNodeId,
                FinalTargetName  = TargetNodeName,
                FinalTargetLabel = TargetNodeLabel;


        // Step 4  Assemble Identity -> Group -> Target paths and de duplicate
        let Paths =
            IdentityGroupMembership
            | join kind=inner (GroupAccessToTargets) on GroupNodeId
            | summarize
                Identities         = any(Identities),
                IdentityTypes      = any(IdentityTypes),
                IdentityCount      = any(IdentityCount),
                FirstIdentityId    = any(FirstIdentityId),
                FirstIdentityName  = any(FirstIdentityName),
                FirstIdentityLabel = any(FirstIdentityLabel),
                GroupNodeName      = any(GroupNodeName),
                EdgeLabel          = any(EdgeLabel),
                FinalTargetName    = any(FinalTargetName),
                FinalTargetLabel   = any(FinalTargetLabel)
              by FinalTargetId, GroupNodeId;


        // Step 5-7  Build the detailed output table
        let Detailed =
            Paths
            | join kind=leftouter (
                Nodes
                | project-rename
                    SourceNodeId                = NodeId,
                    SourceNodeName              = NodeName,
                    SourceNodeLabel             = NodeLabel,
                    SourceCriticalityTier       = CriticalityTier,
                    SourceCriticalityTierLevel  = CriticalityTierLevel,
                    SourceIsInternetExposed     = IsInternetExposed,
                    SourceIsExcluded            = IsExcluded,
                    SourceAssetTierByTag        = AssetTierByTag,
                    SourceLegacyEndOfSupport    = LegacyEndOfSupport,
                    SourceRiskProb              = RiskFactor_Probability,
                    SourceRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    SourceRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                    SourceNodeProperties        = NodeProperties
            ) on $left.FirstIdentityId == $right.SourceNodeId
            | join kind=leftouter (
                Nodes
                | project-rename
                    TargetNodeId                = NodeId,
                    TargetNodeName              = NodeName,
                    TargetNodeLabel             = NodeLabel,
                    TargetCriticalityTier       = CriticalityTier,
                    TargetCriticalityTierLevel  = CriticalityTierLevel,
                    TargetCriticalityRuleBased  = CriticalityRuleBased,
                    TargetCriticalityRuleNames  = CriticalityRuleNames,
                    TargetIsInternetExposed     = IsInternetExposed,
                    TargetIsExcluded            = IsExcluded,
                    TargetAssetTierByTag        = AssetTierByTag,
                    TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                    TargetRiskProb              = RiskFactor_Probability,
                    TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                    TargetNodeProperties        = NodeProperties
            ) on $left.FinalTargetId == $right.TargetNodeId
            | extend TierEscalation =
                case(
                    isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                        SourceCriticalityTier - TargetCriticalityTier,
                    0
                )
            | extend IsLateralMovement = TierEscalation > 0
            | extend LateralMovementType =
                case(
                    TierEscalation >= 3, "Privilege escalation large tier jump",
                    TierEscalation == 2, "Privilege escalation two tiers",
                    TierEscalation == 1, "Privilege escalation one tier",
                    "Direct access same tier"
                )
            | extend TargetTierWeight =
                case(
                    TargetCriticalityTier == 0, 100,
                    TargetCriticalityTier == 1, 60,
                    TargetCriticalityTier == 2, 30,
                    10
                )
            | extend EscalationWeight = TierEscalation * 10
            | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
            | extend SourceTierAmplifier =
                case(
                    SourceCriticalityTier == 0, 8,
                    SourceCriticalityTier == 1, 5,
                    SourceCriticalityTier == 2, 2,
                    0
                )
            | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier
            | extend AttackPathPriority =
                case(
                    AttackPathPriorityScore >= 120, "Critical",
                    AttackPathPriorityScore >= 90,  "Very High",
                    AttackPathPriorityScore >= 60,  "High",
                    AttackPathPriorityScore >= 30,  "Medium-High",
                    AttackPathPriorityScore >= 15,  "Medium",
                    "Low"
                )
            | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
            | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
            | extend AttackPath =
                strcat(
                    FirstIdentityLabel, " [", FirstIdentityName, "] -> ",
                    "group [", GroupNodeName, "] -> ",
                    TargetNodeLabel, " [", FinalTargetName, "]"
                )
            | extend AttackPathDetailed =
                strcat(
                    "SOURCE ", FirstIdentityLabel, " [", FirstIdentityName, "] ",
                    "tier ", tostring(SourceCriticalityTier), " ", tostring(SourceCriticalityTierLevel), " | ", InternetExposureSource,
                    iff(IdentityCount > 1, strcat(" | + ", tostring(IdentityCount - 1), " other identity/ies"), ""),
                    " -> GROUP [", GroupNodeName, "] ",
                    " -> TARGET ", TargetNodeLabel, " [", FinalTargetName, "] ",
                    "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " | ", InternetExposureTarget,
                    " | escalation ", tostring(TierEscalation),
                    " | ", LateralMovementType
                )
            | extend SecurityDomain = "Azure"
            | extend Category = "Attack Paths"
            | extend SubCategory = "GroupMembershipPrivilege"
            | extend ConfigurationName = tostring(LateralMovementType)
            | extend SecuritySeverity  = tostring(AttackPathPriority)
            | extend RiskFactor_Consequence = 0
            | project
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,

                SecuritySeverity,
                AttackPathPriorityScore,
                TierEscalation,
                IsLateralMovement,
                LateralMovementType,

                GroupNodeId,
                GroupNodeName,
                EdgeLabel,

                FirstIdentityId,
                FirstIdentityName,
                FirstIdentityLabel,
                TotalIdentitiesInGroup = IdentityCount,
                AllIdentities = Identities,

                FinalTargetId,
                FinalTarget = FinalTargetName,
                FinalTargetType = FinalTargetLabel,

                TargetCriticalityTier,
                TargetCriticalityTierLevel,
                TargetAssetTierByTag,
                TargetIsInternetExposed,
                TargetLegacyEndOfSupport,
                TargetRiskProb,
                TargetRiskProbDetailed,
                TargetRiskProbDetailedScore,

                AttackPath,
                AttackPathDetailed,

                SourceNodeProperties,
                TargetNodeProperties;


        // ===================== COLLAPSED SUMMARY VERSION (FINAL OUTPUT) =====================


        // Step 8  Collapse to unique logical path so identity spam does not multiply counts
        let CollapsedPaths =
            Detailed
            | extend PathKey = strcat(FirstIdentityId, "->", GroupNodeId, "->", FinalTargetId)
            | summarize
                AttackPathPriorityScore_Path = max(AttackPathPriorityScore),
                SecuritySeverity_Path        = any(SecuritySeverity),

                TargetCriticalityTier_Path      = any(TargetCriticalityTier),
                TargetCriticalityTierLevel_Path = any(TargetCriticalityTierLevel),
                TargetRiskProb_Path             = max(TargetRiskProb),

                TargetRiskProbDetailed_Path      = any(TargetRiskProbDetailed),
                TargetRiskProbDetailedScore_Path = any(TargetRiskProbDetailedScore),

                IdentityTypes_Path  = make_set(tostring(FirstIdentityLabel)),
                SourceIdentities_Path = make_set(tostring(FirstIdentityName)),
                TargetAssets_Path   = make_set(tostring(FinalTarget)),
                TotalIssues_Path    = count()
              by
                PathKey,
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,
                FinalTargetId;


        // Step 9  Main summary (counts stay correct)
        let SummaryMain =
            CollapsedPaths
            | summarize
                ConfigurationId = strcat_array(array_sort_asc(make_set(strcat_array(IdentityTypes_Path, ";"))), ";"),

                SecuritySeverity = any(SecuritySeverity_Path),
                CriticalityTier = toint(any(TargetCriticalityTier_Path)),
                CriticalityTierLevel = tostring(any(TargetCriticalityTierLevel_Path)),

                RiskFactor_Consequence = 0,
                RiskFactor_Probability = max(TargetRiskProb_Path),

                AssetCount   = dcount(FinalTargetId),
                TotalIssues  = sum(TotalIssues_Path),

                ImpactedAssets = strcat_array(array_sort_asc(make_set(strcat_array(TargetAssets_Path, ";"))), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 10  Detail flattening split -> mv-expand -> make_set -> join once
        let SummaryDetail =
            CollapsedPaths
            | extend _d = split(tostring(TargetRiskProbDetailed_Path), ";")
            | mv-expand _d to typeof(string)
            | extend _d = trim(" ", _d)
            | where isnotempty(_d)
            | summarize
                RiskFactor_Probability_Detailed = strcat_array(array_sort_asc(make_set(_d)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        let SummaryDetailScore =
            CollapsedPaths
            | extend _s = split(tostring(TargetRiskProbDetailedScore_Path), ";")
            | mv-expand _s to typeof(string)
            | extend _s = trim(" ", _s)
            | where isnotempty(_s)
            | summarize
                RiskFactor_Probability_DetailedScore = strcat_array(array_sort_asc(make_set(_s)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 11  Final output
        SummaryMain
        | join kind=leftouter SummaryDetail on SecurityDomain, Category, SubCategory, ConfigurationName
        | project-away SecurityDomain1, Category1, SubCategory1, ConfigurationName1
        | join kind=leftouter SummaryDetailScore on SecurityDomain, Category, SubCategory, ConfigurationName
        | project-away SecurityDomain1, Category1, SubCategory1, ConfigurationName1
        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,
            SecuritySeverity,
            CriticalityTier,
            CriticalityTierLevel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by
            RiskFactor_Probability desc,
            CriticalityTier asc,
            TotalIssues desc,
            AssetCount desc

  - ReportName: Attack_Paths_Detailed_Identity_Group_Membership_to_Privileged_Resources
    ReportPurpose: Identify identities that are members of groups and where those groups have permissions or roles on privileged Azure targets. Enrich each path with the standard node context and prioritize by the business impact of the FINAL TARGET.
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Group membership privilege paths to Azure resources using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify identities that are members of groups and where those groups have permissions or roles on
        // privileged Azure targets. Enrich each path with the standard node context and prioritize by the
        // business impact of the FINAL TARGET.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the TARGET criticality tier first
        // - Then by tier escalation where source tier is higher than target tier
        // - Then by internet exposure where target exposure is weighted higher than source exposure
        // - The source identity matters as an amplifier but the target drives the priority
        //
        // Output description detailed rows
        // One row per unique path
        // Identity -> Group -> Target
        // Enriched with
        // - IsInternetExposed for source and target
        // - AssetTierByTag for source and target
        // - LegacyEndOfSupport for source and target
        // - RiskFactor probability fields including detailed breakdown for source and target
        // - AttackPathPriorityScore components and mapped severity label
        // - Human readable AttackPath and AttackPathDetailed strings
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone using standard context fields
        // Step 2  Find identities in groups and de duplicate to a stable group membership grain
        // Step 3  Find group permissions or roles on Azure targets
        // Step 4  Assemble Identity -> Group -> Target paths and de duplicate
        // Step 5  Enrich source identity and target using Nodes catalog
        // Step 6  Apply standard prioritization logic and build attack path strings
        // Step 7  Project detailed output columns and apply ordering
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))

            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Find identities in groups and de duplicate
        let IdentityGroupMembership =
            ExposureGraphEdges
            | where EdgeLabel == "member of"
            | where SourceNodeLabel in ("user", "serviceprincipal", "managedidentity")
            | where TargetNodeLabel == "group"
            | project
                IdentityNodeId    = SourceNodeId,
                IdentityNodeName  = SourceNodeName,
                IdentityNodeLabel = SourceNodeLabel,
                GroupNodeId       = TargetNodeId,
                GroupNodeName     = TargetNodeName
            | summarize
                Identities        = make_set(IdentityNodeName),
                IdentityTypes     = make_set(IdentityNodeLabel),
                IdentityCount     = dcount(IdentityNodeId),
                FirstIdentityId   = any(IdentityNodeId),
                FirstIdentityName = any(IdentityNodeName),
                FirstIdentityLabel= any(IdentityNodeLabel)
              by GroupNodeId, GroupNodeName;


        // Step 3  Find group permissions or roles on Azure targets
        let GroupAccessToTargets =
            ExposureGraphEdges
            | where EdgeLabel in ("has role on", "has permissions to")
            | where SourceNodeLabel == "group"
            | where TargetNodeLabel in (
                "subscriptions",
                "resourcegroups",
                "microsoft.keyvault/vaults",
                "microsoft.storage/storageaccounts",
                "microsoft.sql/servers",
                "microsoft.compute/virtualmachines",
                "microsoft.cognitiveservices/accounts"
            )
            | project
                GroupNodeId      = SourceNodeId,
                EdgeLabel        = EdgeLabel,
                FinalTargetId    = TargetNodeId,
                FinalTargetName  = TargetNodeName,
                FinalTargetLabel = TargetNodeLabel;

        // Step 4  Assemble Identity -> Group -> Target paths and de duplicate
        let Paths =
            IdentityGroupMembership
            | join kind=inner (GroupAccessToTargets) on GroupNodeId
            | summarize
                Identities         = any(Identities),
                IdentityTypes      = any(IdentityTypes),
                IdentityCount      = any(IdentityCount),
                FirstIdentityId    = any(FirstIdentityId),
                FirstIdentityName  = any(FirstIdentityName),
                FirstIdentityLabel = any(FirstIdentityLabel),
                GroupNodeName      = any(GroupNodeName),
                EdgeLabel          = any(EdgeLabel),
                FinalTargetName    = any(FinalTargetName),
                FinalTargetLabel   = any(FinalTargetLabel)
              by FinalTargetId, GroupNodeId;

        // Step 5-7  Enrich source and target and apply standard prioritization logic
        Paths
        | join kind=leftouter (
            Nodes
            | project-rename
                SourceNodeId                = NodeId,
                SourceNodeName              = NodeName,
                SourceNodeLabel             = NodeLabel,
                SourceCriticalityTier       = CriticalityTier,
                SourceCriticalityTierLevel  = CriticalityTierLevel,
                SourceIsInternetExposed     = IsInternetExposed,
                SourceIsExcluded            = IsExcluded,
                SourceAssetTierByTag        = AssetTierByTag,
                SourceLegacyEndOfSupport    = LegacyEndOfSupport,
                SourceRiskProb              = RiskFactor_Probability,
                SourceRiskProbDetailed      = RiskFactor_Probability_Detailed,
                SourceRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                SourceNodeProperties        = NodeProperties
        ) on $left.FirstIdentityId == $right.SourceNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                = NodeId,
                TargetNodeName              = NodeName,
                TargetNodeLabel             = NodeLabel,
                TargetCriticalityTier       = CriticalityTier,
                TargetCriticalityTierLevel  = CriticalityTierLevel,
                TargetCriticalityRuleBased  = CriticalityRuleBased,
                TargetCriticalityRuleNames  = CriticalityRuleNames,
                TargetIsInternetExposed     = IsInternetExposed,
                TargetIsExcluded            = IsExcluded,
                TargetAssetTierByTag        = AssetTierByTag,
                TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                TargetRiskProb              = RiskFactor_Probability,
                TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                TargetNodeProperties        = NodeProperties
        ) on $left.FinalTargetId == $right.TargetNodeId


        // Step 6  Attack path prioritization logic
        | extend TierEscalation =
            case(
                isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                    SourceCriticalityTier - TargetCriticalityTier,
                0
            )
        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )
        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
        | extend SourceTierAmplifier =
            case(
                SourceCriticalityTier == 0, 8,
                SourceCriticalityTier == 1, 5,
                SourceCriticalityTier == 2, 2,
                0
            )
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )

        // Step 7  Human readable paths
        | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
        | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

        | extend AttackPath =
            strcat(
                FirstIdentityLabel, " [", FirstIdentityName, "] -> ",
                "group [", GroupNodeName, "] -> ",
                TargetNodeLabel, " [", FinalTargetName, "]"
            )

        | extend AttackPathDetailed =
            strcat(
                "SOURCE ", FirstIdentityLabel, " [", FirstIdentityName, "] ",
                "tier ", tostring(SourceCriticalityTier), " ", tostring(SourceCriticalityTierLevel), " | ", InternetExposureSource,
                iff(IdentityCount > 1, strcat(" | + ", tostring(IdentityCount - 1), " other identity/ies"), ""),
                " -> GROUP [", GroupNodeName, "] ",
                " -> TARGET ", TargetNodeLabel, " [", FinalTargetName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " | ", InternetExposureTarget,
                " | escalation ", tostring(TierEscalation),
                " | ", LateralMovementType
            )

        | extend SecurityDomain = "Azure"
        | extend Category = "Attack Paths"
        | extend SubCategory = "GroupMembershipPrivilege"
        | extend ConfigurationName = tostring(LateralMovementType)
        | extend ConfigurationId = "group_membership"


        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,

            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,
            EscalationWeight,
            ExposureWeight,

            GroupNodeId,
            GroupNodeName,
            EdgeLabel,

            FirstIdentityId,
            FirstIdentityName,
            FirstIdentityLabel,
            TotalIdentitiesInGroup = IdentityCount,
            AllIdentities = Identities,
            IdentityTypes,

            FinalTargetId,
            FinalTarget = FinalTargetName,
            FinalTargetType = FinalTargetLabel,

            TargetCriticalityTier,
            TargetCriticalityTierLevel,
            TargetCriticalityRuleBased,
            TargetCriticalityRuleNames,

            TargetAssetTierByTag,
            TargetIsInternetExposed,
            TargetLegacyEndOfSupport,
            TargetRiskProb,
            TargetRiskProbDetailed,
            TargetRiskProbDetailedScore,

            SourceCriticalityTier,
            SourceCriticalityTierLevel,
            SourceAssetTierByTag,
            SourceIsInternetExposed,
            SourceLegacyEndOfSupport,
            SourceRiskProb,
            SourceRiskProbDetailed,
            SourceRiskProbDetailedScore,

            AttackPath,
            AttackPathDetailed,

            SourceNodeProperties,
            TargetNodeProperties

        | order by AttackPathPriorityScore desc, TierEscalation desc, TargetCriticalityTier asc, FinalTarget asc

  - ReportName: Attack_Paths_Summary_Data_Sensitivity_to_Exposed_Credentials
    ReportPurpose: Attack Paths with Data Sensitivity to Exposed Credentials. Sensitive Data -> Storage -> Exposed Credential. Key detection -> Data exfiltration risk
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Exposed credentials enabling access to sensitive data locations using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify sensitive data locations and the credential driven attack paths that can reach them.
        // The path shape is
        // ExposedCredential -> Identity -> DataLocation <- DataSensitivityScan
        // Results are enriched using the standard Nodes context and prioritized by the business impact of the
        // FINAL TARGET which is the data location. Output is a collapsed summary suitable for your risk engine.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the TARGET criticality tier first
        // - Then by tier escalation where source tier is higher than target tier
        // - Then by internet exposure where target exposure is weighted higher than source exposure
        // - The source identity matters as an amplifier but the target drives the priority
        //
        // Output description summary rows
        // One row per ConfigurationName which is LateralMovementType grouped within the report taxonomy
        // and collapsed so many credentials and identities do not multiply the counts.
        // RiskFactor detailed strings are rebuilt from TargetRiskProbDetailed and TargetRiskProbDetailedScore.
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone using standard context fields
        // Step 2  Normalize labels for allowlists
        // Step 3  Identify sensitive data locations from dataSensitivityScan edges
        // Step 4  Identify identity access to data locations
        // Step 5  Identify exposed credentials linked to identities and filter to credential allowlist
        // Step 6  Build detailed enriched table as Detailed
        // Step 7  Collapse to PathKey so credential spam does not multiply counts
        // Step 8  Build SummaryMain with correct counts
        // Step 9  Rebuild RiskFactor_Probability_Detailed via split expand and re aggregation
        // Step 10 Rebuild RiskFactor_Probability_DetailedScore via split expand and re aggregation
        // Step 11 Join summary parts and output final collapsed summary ordering
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))


            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))

            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                NodeProperties,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Normalize labels to avoid typos breaking allowlists
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };


        // Step 3  Data location allowlist (normalized)
        let DataLocationLabels =
            dynamic([
                "blobcontainer",
                "microsoft.storage/storageaccounts",
                "microsoft.sql/servers/databases",
                "microsoft.sql/servers",
                "microsoft.storage/storageaccounts/blobservices/containers",
                "microsoft.storage/storageaccounts/fileservices/shares"
            ]);


        // Step 4  Credential allowlist (normalized)
        let CredentialLabels =
            dynamic([
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-app-secret",
                "service-principal-azure-cli-secret",
                "user-azure-cli-secret",
                "azure-active-directory-user-credentials",
                "entra-usercookie"
            ]);


        // Step 5  Find sensitive data locations
        let SensitiveDataLocations =
            ExposureGraphEdges
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where SourceNodeLabel == "dataSensitivityScan"
            | where EdgeLabel in ("defined in", "contains")
            | where TargetNodeLabelNorm in (DataLocationLabels)
            | project
                SensitiveDataNodeId   = SourceNodeId,
                SensitiveDataNodeName = SourceNodeName,
                DataLocationNodeId    = TargetNodeId,
                DataLocationNodeName  = TargetNodeName,
                DataLocationNodeLabel = TargetNodeLabel;


        // Step 6  Identity -> data location access edges
        let IdentityAccessToData =
            ExposureGraphEdges
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where EdgeLabel in ("has permissions to", "has role on", "can authenticate to", "has access to", "can access")
            | where TargetNodeLabelNorm in (DataLocationLabels)
            | project
                IdentityNodeId     = SourceNodeId,
                DataLocationNodeId = TargetNodeId;


        // Step 7  Credential exposure edges (support both directions)
        let ExposedCredentialsToIdentity =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                CredentialNodeId    = SourceNodeId,
                CredentialName      = SourceNodeName,
                CredentialLabel     = SourceNodeLabel,
                IdentityNodeId      = TargetNodeId;

        let IdentityToExposedCredentials =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "uses credential", "uses credentials", "authenticated by")
            | project
                IdentityNodeId      = SourceNodeId,
                CredentialNodeId    = TargetNodeId,
                CredentialName      = TargetNodeName,
                CredentialLabel     = TargetNodeLabel;


        // Step 8  Union both forms and then filter credential types
        let ExposedCreds =
            union isfuzzy=true ExposedCredentialsToIdentity, IdentityToExposedCredentials
            | extend CredentialNodeLabelNorm = NormalizeLabel(CredentialLabel)
            | where CredentialNodeLabelNorm in (CredentialLabels);


        // Step 9  Build the detailed output table
        let Detailed =
            IdentityAccessToData
            | join kind=inner SensitiveDataLocations on DataLocationNodeId
            | join kind=inner (
                ExposedCreds
                | project-rename IdentityNodeId_join = IdentityNodeId
            ) on $left.IdentityNodeId == $right.IdentityNodeId_join
            | project
                DataLocationNodeId,
                DataLocationNodeName,
                DataLocationNodeLabel,
                SensitiveDataNodeId,
                SensitiveDataNodeName,
                IdentityNodeId,
                CredentialNodeId,
                CredentialName,
                CredentialLabel
            | summarize
                SensitiveDataItems = make_set(SensitiveDataNodeName),
                SensitiveDataCount = dcount(SensitiveDataNodeId),

                CredentialNodeId   = any(CredentialNodeId),
                CredentialName     = any(CredentialName),
                CredentialLabel    = any(CredentialLabel),

                ExposedCredentials     = make_set(CredentialName),
                ExposedCredentialTypes = make_set(CredentialLabel),
                ExposedCredentialCount = dcount(CredentialNodeId),

                IdentityNodeId = any(IdentityNodeId)
              by
                DataLocationNodeId,
                DataLocationNodeName,
                DataLocationNodeLabel

            | join kind=leftouter (
                Nodes
                | project-rename
                    TargetNodeId                = NodeId,
                    TargetCriticalityTier       = CriticalityTier,
                    TargetCriticalityTierLevel  = CriticalityTierLevel,
                    TargetCriticalityRuleBased  = CriticalityRuleBased,
                    TargetCriticalityRuleNames  = CriticalityRuleNames,
                    TargetIsInternetExposed     = IsInternetExposed,
                    TargetAssetTierByTag        = AssetTierByTag,
                    TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                    TargetRiskProb              = RiskFactor_Probability,
                    TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore
            ) on $left.DataLocationNodeId == $right.TargetNodeId

            | join kind=leftouter (
                Nodes
                | project-rename
                    SourceNodeId                = NodeId,
                    SourceCriticalityTier       = CriticalityTier,
                    SourceCriticalityTierLevel  = CriticalityTierLevel,
                    SourceIsInternetExposed     = IsInternetExposed,
                    SourceAssetTierByTag        = AssetTierByTag,
                    SourceLegacyEndOfSupport    = LegacyEndOfSupport,
                    SourceRiskProb              = RiskFactor_Probability,
                    SourceRiskProbDetailed      = RiskFactor_Probability_Detailed,
                    SourceRiskProbDetailedScore = RiskFactor_Probability_DetailedScore
            ) on $left.IdentityNodeId == $right.SourceNodeId

            | extend TierEscalation =
                case(
                    isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                        SourceCriticalityTier - TargetCriticalityTier,
                    0
                )
            | extend IsLateralMovement = TierEscalation > 0
            | extend LateralMovementType =
                case(
                    TierEscalation >= 3, "Privilege escalation large tier jump",
                    TierEscalation == 2, "Privilege escalation two tiers",
                    TierEscalation == 1, "Privilege escalation one tier",
                    "Direct access same tier"
                )

            | extend TargetTierWeight =
                case(
                    TargetCriticalityTier == 0, 100,
                    TargetCriticalityTier == 1, 60,
                    TargetCriticalityTier == 2, 30,
                    10
                )
            | extend EscalationWeight = TierEscalation * 10
            | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
            | extend SourceTierAmplifier =
                case(
                    SourceCriticalityTier == 0, 8,
                    SourceCriticalityTier == 1, 5,
                    SourceCriticalityTier == 2, 2,
                    0
                )
            | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

            | extend AttackPathPriority =
                case(
                    AttackPathPriorityScore >= 120, "Critical",
                    AttackPathPriorityScore >= 90,  "Very High",
                    AttackPathPriorityScore >= 60,  "High",
                    AttackPathPriorityScore >= 30,  "Medium-High",
                    AttackPathPriorityScore >= 15,  "Medium",
                    "Low"
                )

            | extend SecurityDomain = "Data Protection"
            | extend Category = "Attack Paths"
            | extend SubCategory = "SensitiveDataExposure"
            | extend ConfigurationName = tostring(LateralMovementType)
            | extend SecuritySeverity  = tostring(AttackPathPriority)
            | extend RiskFactor_Consequence = 0;


        // ===================== COLLAPSED SUMMARY VERSION (FINAL OUTPUT) =====================


        // Step 10  Collapse to unique logical path so credential spam does not multiply counts
        let CollapsedPaths =
            Detailed
            | extend PathKey = strcat(CredentialNodeId, "->", IdentityNodeId, "->", DataLocationNodeId)
            | summarize
                AttackPathPriorityScore_Path = max(AttackPathPriorityScore),
                SecuritySeverity_Path        = any(SecuritySeverity),

                TargetCriticalityTier_Path      = any(TargetCriticalityTier),
                TargetCriticalityTierLevel_Path = any(TargetCriticalityTierLevel),
                TargetRiskProb_Path             = max(TargetRiskProb),

                TargetRiskProbDetailed_Path      = any(TargetRiskProbDetailed),
                TargetRiskProbDetailedScore_Path = any(TargetRiskProbDetailedScore),

                CredentialTypes_Path = make_set(tostring(CredentialLabel)),
                TargetAssets_Path    = make_set(tostring(DataLocationNodeName)),
                TotalIssues_Path     = count()
              by
                PathKey,
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,
                DataLocationNodeId;


        // Step 11  Main summary (counts stay correct)
        let SummaryMain =
            CollapsedPaths
            | summarize
                ConfigurationId = strcat_array(array_sort_asc(make_set(strcat_array(CredentialTypes_Path, ";"))), ";"),

                SecuritySeverity = any(SecuritySeverity_Path),
                CriticalityTier = toint(any(TargetCriticalityTier_Path)),
                CriticalityTierLevel = tostring(any(TargetCriticalityTierLevel_Path)),

                RiskFactor_Consequence = 0,
                RiskFactor_Probability = max(TargetRiskProb_Path),

                AssetCount   = dcount(DataLocationNodeId),
                TotalIssues  = sum(TotalIssues_Path),

                ImpactedAssets = strcat_array(array_sort_asc(make_set(strcat_array(TargetAssets_Path, ";"))), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 12  Detail flattening split -> mv-expand -> make_set -> join once
        let SummaryDetail =
            CollapsedPaths
            | extend _d = split(tostring(TargetRiskProbDetailed_Path), ";")
            | mv-expand _d to typeof(string)
            | extend _d = trim(" ", _d)
            | where isnotempty(_d)
            | summarize
                RiskFactor_Probability_Detailed = strcat_array(array_sort_asc(make_set(_d)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        let SummaryDetailScore =
            CollapsedPaths
            | extend _s = split(tostring(TargetRiskProbDetailedScore_Path), ";")
            | mv-expand _s to typeof(string)
            | extend _s = trim(" ", _s)
            | where isnotempty(_s)
            | summarize
                RiskFactor_Probability_DetailedScore = strcat_array(array_sort_asc(make_set(_s)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Step 13  Final output
        SummaryMain
        | join kind=leftouter SummaryDetail on SecurityDomain, Category, SubCategory, ConfigurationName
        | project-away SecurityDomain1, Category1, SubCategory1, ConfigurationName1
        | join kind=leftouter SummaryDetailScore on SecurityDomain, Category, SubCategory, ConfigurationName
        | project-away SecurityDomain1, Category1, SubCategory1, ConfigurationName1
        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,
            SecuritySeverity,
            CriticalityTier,
            CriticalityTierLevel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by
            RiskFactor_Probability desc,
            CriticalityTier asc,
            TotalIssues desc,
            AssetCount desc

  - ReportName: Attack_Paths_Detailed_Data_Sensitivity_to_Exposed_Credentials
    ReportPurpose: Attack Paths with Data Sensitivity to Exposed Credentials. Sensitive Data -> Storage -> Exposed Credential. Key detection -> Data exfiltration risk
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Exposed credentials enabling access to sensitive data locations using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify sensitive data locations and the credential driven attack paths that can reach them.
        // The path shape is
        // ExposedCredential -> Identity -> DataLocation <- DataSensitivityScan
        // Results are enriched using the standard Nodes context and prioritized by the business impact of the
        // FINAL TARGET which is the data location.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the TARGET criticality tier first
        // - Then by tier escalation where source tier is higher than target tier
        // - Then by internet exposure where target exposure is weighted higher than source exposure
        // - A low tier credential source can never outrank a tier 0 or tier 1 target
        //
        // Output description detailed rows
        // One row per unique ExposedCredential -> Identity -> DataLocation path enriched with
        // - IsInternetExposed for credential source and target location
        // - AssetTierByTag for source and target
        // - LegacyEndOfSupport for source and target
        // - RiskFactor probability fields including detailed breakdown for source and target
        // - AttackPathPriorityScore and severity label
        // - Human readable AttackPath and AttackPathDetailed strings
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog as enrichment backbone using standard context fields
        // Step 2  Normalize labels for allowlists
        // Step 3  Identify sensitive data locations from dataSensitivityScan edges
        // Step 4  Identify identity access to data locations
        // Step 5  Identify exposed credentials linked to identities and filter to credential allowlist
        // Step 6  Assemble credential driven paths and de duplicate to stable grain
        // Step 7  Enrich credential source identity and target location using Nodes
        // Step 8  Apply standard prioritization logic and build attack path strings
        // Step 9  Project detailed output columns and apply ordering
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))


            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))

            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                NodeProperties,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Normalize labels to avoid typos breaking allowlists
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };


        // Step 3  Data location allowlist (normalized)
        let DataLocationLabels =
            dynamic([
                "blobcontainer",
                "microsoft.storage/storageaccounts",
                "microsoft.sql/servers/databases",
                "microsoft.sql/servers",
                "microsoft.storage/storageaccounts/blobservices/containers",
                "microsoft.storage/storageaccounts/fileservices/shares"
            ]);


        // Step 4  Credential allowlist (normalized)
        let CredentialLabels =
            dynamic([
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-app-secret",
                "service-principal-azure-cli-secret",
                "user-azure-cli-secret",
                "azure-active-directory-user-credentials",
                "entra-usercookie"
            ]);


        // Step 5  Find sensitive data locations
        let SensitiveDataLocations =
            ExposureGraphEdges
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where SourceNodeLabel == "dataSensitivityScan"
            | where EdgeLabel in ("defined in", "contains")
            | where TargetNodeLabelNorm in (DataLocationLabels)
            | project
                SensitiveDataNodeId   = SourceNodeId,
                SensitiveDataNodeName = SourceNodeName,
                DataLocationNodeId    = TargetNodeId,
                DataLocationNodeName  = TargetNodeName,
                DataLocationNodeLabel = TargetNodeLabel;


        // Step 6  Identity -> data location access edges
        let IdentityAccessToData =
            ExposureGraphEdges
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where EdgeLabel in ("has permissions to", "has role on", "can authenticate to", "has access to", "can access")
            | where TargetNodeLabelNorm in (DataLocationLabels)
            | project
                IdentityNodeId     = SourceNodeId,
                IdentityNodeName   = SourceNodeName,
                IdentityNodeLabel  = SourceNodeLabel,
                DataLocationNodeId = TargetNodeId;


        // Step 7  Credential exposure edges (support both directions)
        let ExposedCredentialsToIdentity =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                CredentialNodeId    = SourceNodeId,
                CredentialNodeName  = SourceNodeName,
                CredentialNodeLabel = SourceNodeLabel,
                IdentityNodeId      = TargetNodeId;

        let IdentityToExposedCredentials =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "uses credential", "uses credentials", "authenticated by")
            | project
                IdentityNodeId      = SourceNodeId,
                CredentialNodeId    = TargetNodeId,
                CredentialNodeName  = TargetNodeName,
                CredentialNodeLabel = TargetNodeLabel;


        // Step 8  Union both forms and then filter credential types
        let ExposedCreds =
            union isfuzzy=true ExposedCredentialsToIdentity, IdentityToExposedCredentials
            | extend CredentialNodeLabelNorm = NormalizeLabel(CredentialNodeLabel)
            | where CredentialNodeLabelNorm in (CredentialLabels);


        // Step 9  Assemble detailed paths and enrich source and target using Nodes
        IdentityAccessToData
        | join kind=inner SensitiveDataLocations on DataLocationNodeId
        | join kind=inner ExposedCreds on IdentityNodeId
        | summarize
            SensitiveDataItems        = make_set(SensitiveDataNodeName),
            SensitiveDataCount        = dcount(SensitiveDataNodeId),

            CredentialNodeId          = any(CredentialNodeId),
            CredentialName            = any(CredentialNodeName),
            CredentialLabel           = any(CredentialNodeLabel),

            ExposedCredentials        = make_set(CredentialNodeName),
            ExposedCredentialTypes    = make_set(CredentialNodeLabel),
            ExposedCredentialCount    = dcount(CredentialNodeId),

            IdentityNodeId            = any(IdentityNodeId),
            IdentityName              = any(IdentityNodeName),
            IdentityLabel             = any(IdentityNodeLabel),

            DataLocationNodeName      = any(DataLocationNodeName),
            DataLocationNodeLabel     = any(DataLocationNodeLabel)
          by DataLocationNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                = NodeId,
                TargetNodeName              = NodeName,
                TargetNodeLabel             = NodeLabel,
                TargetCriticalityTier       = CriticalityTier,
                TargetCriticalityTierLevel  = CriticalityTierLevel,
                TargetCriticalityRuleBased  = CriticalityRuleBased,
                TargetCriticalityRuleNames  = CriticalityRuleNames,
                TargetIsInternetExposed     = IsInternetExposed,
                TargetIsExcluded            = IsExcluded,
                TargetAssetTierByTag        = AssetTierByTag,
                TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                TargetRiskProb              = RiskFactor_Probability,
                TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                TargetNodeProperties        = NodeProperties
        ) on $left.DataLocationNodeId == $right.TargetNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                SourceNodeId                = NodeId,
                SourceNodeName              = NodeName,
                SourceNodeLabel             = NodeLabel,
                SourceCriticalityTier       = CriticalityTier,
                SourceCriticalityTierLevel  = CriticalityTierLevel,
                SourceIsInternetExposed     = IsInternetExposed,
                SourceIsExcluded            = IsExcluded,
                SourceAssetTierByTag        = AssetTierByTag,
                SourceLegacyEndOfSupport    = LegacyEndOfSupport,
                SourceRiskProb              = RiskFactor_Probability,
                SourceRiskProbDetailed      = RiskFactor_Probability_Detailed,
                SourceRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                SourceNodeProperties        = NodeProperties
        ) on $left.IdentityNodeId == $right.SourceNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                CredentialNodeId_join       = NodeId,
                CredentialNodeName_join     = NodeName,
                CredentialNodeLabel_join    = NodeLabel,
                CredentialIsInternetExposed = IsInternetExposed,
                CredentialAssetTierByTag    = AssetTierByTag,
                CredentialLegacyEndOfSupport= LegacyEndOfSupport,
                CredentialRiskProb          = RiskFactor_Probability,
                CredentialRiskProbDetailed  = RiskFactor_Probability_Detailed,
                CredentialRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                CredentialNodeProperties    = NodeProperties
        ) on $left.CredentialNodeId == $right.CredentialNodeId_join


        // Step 10  Apply standard prioritization logic based on FINAL TARGET
        | extend TierEscalation =
            case(
                isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                    SourceCriticalityTier - TargetCriticalityTier,
                0
            )
        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )
        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
        | extend SourceTierAmplifier =
            case(
                SourceCriticalityTier == 0, 8,
                SourceCriticalityTier == 1, 5,
                SourceCriticalityTier == 2, 2,
                0
            )
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )

        | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
        | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

        | extend SecurityDomain = "Data Protection"
        | extend Category = "Attack Paths"
        | extend SubCategory = "SensitiveDataExposure"
        | extend ConfigurationName = tostring(LateralMovementType)
        | extend ConfigurationId = tostring(CredentialLabel)


        // Step 11  Human readable paths
        | extend AttackPath =
            strcat(
                CredentialLabel, " [", CredentialName, "] -> ",
                IdentityLabel, " [", IdentityName, "] -> ",
                DataLocationNodeLabel, " [", DataLocationNodeName, "]"
            )

        | extend AttackPathDetailed =
            strcat(
                "CREDENTIAL ", CredentialLabel, " [", CredentialName, "] ",
                iff(ExposedCredentialCount > 1, strcat("| + ", tostring(ExposedCredentialCount - 1), " other credential(s) "), ""),
                "-> IDENTITY ", IdentityLabel, " [", IdentityName, "] ",
                "tier ", tostring(SourceCriticalityTier), " ", tostring(SourceCriticalityTierLevel), " | ", InternetExposureSource,
                " -> TARGET ", DataLocationNodeLabel, " [", DataLocationNodeName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " | ", InternetExposureTarget,
                " | escalation ", tostring(TierEscalation),
                " | ", LateralMovementType,
                " | sensitive items ", tostring(SensitiveDataCount)
            )


        // Step 12  Final projection detailed output
        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,

            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,
            EscalationWeight,
            ExposureWeight,

            DataLocationNodeId,
            DataLocationNodeName,
            DataLocationNodeLabel,
            SensitiveDataCount,
            SensitiveDataItems,

            CredentialNodeId,
            CredentialName,
            CredentialLabel,
            ExposedCredentialCount,
            ExposedCredentials,
            ExposedCredentialTypes,

            IdentityNodeId,
            IdentityName,
            IdentityLabel,

            TargetCriticalityTier,
            TargetCriticalityTierLevel,
            TargetAssetTierByTag,
            TargetIsInternetExposed,
            TargetLegacyEndOfSupport,
            TargetRiskProb,
            TargetRiskProbDetailed,
            TargetRiskProbDetailedScore,
            TargetCriticalityRuleBased,
            TargetCriticalityRuleNames,

            SourceCriticalityTier,
            SourceCriticalityTierLevel,
            SourceAssetTierByTag,
            SourceIsInternetExposed,
            SourceLegacyEndOfSupport,
            SourceRiskProb,
            SourceRiskProbDetailed,
            SourceRiskProbDetailedScore,

            CredentialIsInternetExposed,
            CredentialAssetTierByTag,
            CredentialLegacyEndOfSupport,
            CredentialRiskProb,
            CredentialRiskProbDetailed,
            CredentialRiskProbDetailedScore,

            AttackPath,
            AttackPathDetailed,

            SourceNodeProperties,
            TargetNodeProperties,
            CredentialNodeProperties

        | order by AttackPathPriorityScore desc, TierEscalation desc, TargetCriticalityTier asc, DataLocationNodeName asc

  - ReportName: Attack_Paths_Summary_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure 
    ReportPurpose: Attack Paths with Device with high severity vulnerabilities allows lateral movement
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Collapsed summary for vulnerable device to target attack paths
        // =================================================================================================
        //
        // Report purpose
        // Produce a collapsed summary of attack paths where vulnerable devices expose credentials that authenticate
        // as identities and reach target resources. Priority is derived from the final target using the standard
        // scoring model.
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog using standard context fields
        // Step 2  Build detailed paths Device -> Credential -> Identity -> Target
        // Step 3  Collapse to unique logical path key DeviceId -> IdentityId -> TargetId
        // Step 4  Summarize to report grain and stitch detailed risk strings without leading separators
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build Nodes catalog used to enrich paths (standard context)
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))

            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | extend CVESeverity =
                tostring(coalesce(
                    NodeProperties.rawData.severity,
                    NodeProperties.rawData.Severity,
                    NodeProperties.rawData.cvssScore,
                    ""
                ))

            | project
                NodeId,
                NodeName = NodeNameNorm,
                NodeLabel,
                NodeProperties,

                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,

                IsInternetExposed,
                IsExcluded,
                AssetTierByTag,
                LegacyEndOfSupport,

                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,

                CVESeverity;


        // Step 2  Build detailed paths Device -> Credential -> Identity -> Target
        let DevicesWithCVEs =
            ExposureGraphEdges
            | where SourceNodeLabel == "Cve"
            | where EdgeLabel == "affecting"
            | where TargetNodeLabel in ("device", "computer-account", "microsoft.compute/virtualmachines")
            | project
                CVENodeId   = SourceNodeId,
                CVENodeName = SourceNodeName,
                DeviceNodeId    = TargetNodeId,
                DeviceNodeName  = TargetNodeName,
                DeviceNodeLabel = TargetNodeLabel
            | join kind=leftouter (
                Nodes
                | project CVE_NodeId = NodeId, CVESeverity
            ) on $left.CVENodeId == $right.CVE_NodeId
            | summarize
                CVEs          = make_set(CVENodeName),
                CVESeverities = make_set(CVESeverity),
                CVECount      = dcount(CVENodeId),
                HighSeverityCVEs = countif(
                    tolower(CVESeverity) has "critical"
                    or tolower(CVESeverity) has "high"
                    or tolower(CVESeverity) has "medium"
                ),
                FirstCVE         = any(CVENodeName),
                FirstCVESeverity = any(CVESeverity)
              by
                DeviceNodeId,
                DeviceNodeName,
                DeviceNodeLabel;

        let CredentialsOnVulnerableDevices =
            DevicesWithCVEs
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("contains", "defined in", "runs on", "has credentials of", "frequently logged in by")
                | where TargetNodeLabel in (
                    "user",
                    "serviceprincipal",
                    "managedidentity",
                    "entra-userCookie",
                    "azure-active-directory-app-secret",
                    "user-azure-cli-secret",
                    "azure-storage-shared-access-signature",
                    "azure-storage-connection-string",
                    "azure-database-connection-string",
                    "azure-app-configuration-key",
                    "azure-active-directory-user-credentials",
                    "service-principal-azure-cli-secret"
                )
                | project SourceDeviceId = SourceNodeId,
                         CredentialNodeId = TargetNodeId,
                         CredentialNodeName = TargetNodeName,
                         CredentialNodeLabel = TargetNodeLabel
            ) on $left.DeviceNodeId == $right.SourceDeviceId
            | project
                DeviceNodeId, DeviceNodeName, DeviceNodeLabel,
                CVEs, CVESeverities, CVECount, HighSeverityCVEs, FirstCVE, FirstCVESeverity,
                CredentialNodeId, CredentialNodeName, CredentialNodeLabel;

        let Hop1 =
            CredentialsOnVulnerableDevices
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
                | project Hop1_SourceCredentialId = SourceNodeId,
                         Hop1Edge = EdgeLabel,
                         IdentityNodeId = TargetNodeId,
                         IdentityNodeName = TargetNodeName,
                         IdentityNodeLabel = TargetNodeLabel
            ) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId
            | project
                DeviceNodeId, DeviceNodeName, DeviceNodeLabel,
                CVEs, CVESeverities, CVECount, HighSeverityCVEs, FirstCVE, FirstCVESeverity,
                CredentialNodeId, CredentialNodeName, CredentialNodeLabel,
                Hop1Edge,
                IdentityNodeId, IdentityNodeName, IdentityNodeLabel;

        let Detailed =
            Hop1
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("can authenticate to", "has permissions to", "has role on")
                | where TargetNodeLabel in (
                    "microsoft.keyvault/vaults",
                    "microsoft.storage/storageaccounts",
                    "microsoft.sql/servers",
                    "microsoft.sql/servers/databases",
                    "microsoft.compute/virtualmachines",
                    "microsoft.compute/virtualmachines/extensions",
                    "microsoft.cognitiveservices/accounts",
                    "microsoft.cognitiveservices/accounts/deployments",
                    "microsoft.cognitiveservices/accounts_openai",
                    "microsoft.operationalinsights/workspaces",
                    "microsoft.web/sites_webapp",
                    "microsoft.web/serverfarms",
                    "microsoft.logic/workflows",
                    "microsoft.network/virtualnetworks",
                    "microsoft.network/virtualnetworks/subnets",
                    "microsoft.network/networksecuritygroups",
                    "subscriptions",
                    "resourcegroups",
                    "BlobContainer",
                    "device",
                    "computer-account"
                )
                | project Hop2_SourceIdentityId = SourceNodeId,
                         Hop2Edge = EdgeLabel,
                         FinalTargetId = TargetNodeId,
                         FinalTargetName = TargetNodeName,
                         FinalTargetLabel = TargetNodeLabel
            ) on $left.IdentityNodeId == $right.Hop2_SourceIdentityId
            | where DeviceNodeId != FinalTargetId

            | join kind=leftouter (
                Nodes
                | project-rename
                    SourceDeviceId                = NodeId,
                    SourceCriticalityTier         = CriticalityTier,
                    SourceCriticalityTierLevel    = CriticalityTierLevel,
                    SourceIsInternetExposed       = IsInternetExposed,
                    SourceAssetTierByTag          = AssetTierByTag,
                    SourceLegacyEndOfSupport      = LegacyEndOfSupport,
                    SourceRiskProb                = RiskFactor_Probability,
                    SourceRiskProbDetailed        = RiskFactor_Probability_Detailed,
                    SourceRiskProbDetailedScore   = RiskFactor_Probability_DetailedScore
            ) on $left.DeviceNodeId == $right.SourceDeviceId

            | join kind=leftouter (
                Nodes
                | project-rename
                    TargetNodeId                  = NodeId,
                    TargetCriticalityTier         = CriticalityTier,
                    TargetCriticalityTierLevel    = CriticalityTierLevel,
                    TargetIsInternetExposed       = IsInternetExposed,
                    TargetAssetTierByTag          = AssetTierByTag,
                    TargetLegacyEndOfSupport      = LegacyEndOfSupport,
                    TargetRiskProb                = RiskFactor_Probability,
                    TargetRiskProbDetailed        = RiskFactor_Probability_Detailed,
                    TargetRiskProbDetailedScore   = RiskFactor_Probability_DetailedScore
            ) on $left.FinalTargetId == $right.TargetNodeId

            | extend TierEscalation =
                case(
                    isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                        SourceCriticalityTier - TargetCriticalityTier,
                    0
                )
            | extend IsLateralMovement = TierEscalation > 0
            | extend LateralMovementType =
                case(
                    TierEscalation >= 3, "Privilege escalation large tier jump",
                    TierEscalation == 2, "Privilege escalation two tiers",
                    TierEscalation == 1, "Privilege escalation one tier",
                    "Direct access same tier"
                )
            | extend TargetTierWeight =
                case(
                    TargetCriticalityTier == 0, 100,
                    TargetCriticalityTier == 1, 60,
                    TargetCriticalityTier == 2, 30,
                    10
                )
            | extend EscalationWeight = TierEscalation * 10
            | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
            | extend SourceTierAmplifier =
                case(
                    SourceCriticalityTier == 0, 8,
                    SourceCriticalityTier == 1, 5,
                    SourceCriticalityTier == 2, 2,
                    0
                )
            | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier
            | extend AttackPathPriority =
                case(
                    AttackPathPriorityScore >= 120, "Critical",
                    AttackPathPriorityScore >= 90,  "Very High",
                    AttackPathPriorityScore >= 60,  "High",
                    AttackPathPriorityScore >= 30,  "Medium-High",
                    AttackPathPriorityScore >= 15,  "Medium",
                    "Low"
                )
            | project
                DeviceNodeId,
                DeviceNodeName,
                IdentityNodeId,
                FinalTargetId,
                FinalTargetName,
                FinalTargetLabel,
                CredentialNodeLabel,
                AttackPathPriority,
                AttackPathPriorityScore,
                LateralMovementType,
                TargetCriticalityTier,
                TargetCriticalityTierLevel,
                TargetRiskProb,
                TargetRiskProbDetailed,
                TargetRiskProbDetailedScore;


        // Step 3  Collapse to unique logical path key
        let CollapsedPaths =
            Detailed
            | extend PathKey = strcat(DeviceNodeId, "->", IdentityNodeId, "->", FinalTargetId)
            | extend SecurityDomain = "Endpoint"
            | extend Category = "AttackPath_VulnerableDeviceToAzure"
            | extend SubCategory = "LateralMovement"
            | extend ConfigurationName = tostring(LateralMovementType)
            | extend SecuritySeverity  = tostring(AttackPathPriority)
            | extend RiskFactor_Consequence = 0
            | summarize
                AttackPathPriorityScore_Path = max(AttackPathPriorityScore),
                AttackPathPriority_Path      = any(AttackPathPriority),

                TargetCriticalityTier_Path      = any(TargetCriticalityTier),
                TargetCriticalityTierLevel_Path = any(TargetCriticalityTierLevel),
                TargetRiskProb_Path             = max(TargetRiskProb),
                TargetRiskProbDetailed_Path      = any(TargetRiskProbDetailed),
                TargetRiskProbDetailedScore_Path = any(TargetRiskProbDetailedScore),

                ConfigurationId_Set = make_set(tostring(CredentialNodeLabel)),
                SourceAssets_Set    = make_set(tostring(DeviceNodeName)),
                TotalIssues_Path    = count()
              by
                PathKey,
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName,
                FinalTargetId;


        // Step 4  Summarize to report grain and stitch detailed risk strings
        let SummaryMain =
            CollapsedPaths
            | summarize
                ConfigurationId = strcat_array(array_sort_asc(make_set(strcat_array(ConfigurationId_Set, ";"))), ";"),

                SecuritySeverity = any(AttackPathPriority_Path),
                CriticalityTier = toint(any(TargetCriticalityTier_Path)),
                CriticalityTierLevel = tostring(any(TargetCriticalityTierLevel_Path)),

                RiskFactor_Consequence = 0,
                RiskFactor_Probability = max(TargetRiskProb_Path),

                AssetCount  = dcount(FinalTargetId),
                TotalIssues = sum(TotalIssues_Path),

                ImpactedAssets = strcat_array(array_sort_asc(make_set(strcat_array(SourceAssets_Set, ";"))), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        let SummaryDetail =
            CollapsedPaths
            | extend _d = split(tostring(TargetRiskProbDetailed_Path), ";")
            | mv-expand _d to typeof(string)
            | extend _d = trim(" ", _d)
            | where isnotempty(_d)
            | summarize
                RiskFactor_Probability_Detailed = strcat_array(array_sort_asc(make_set(_d)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;

        let SummaryDetailScore =
            CollapsedPaths
            | extend _s = split(tostring(TargetRiskProbDetailedScore_Path), ";")
            | mv-expand _s to typeof(string)
            | extend _s = trim(" ", _s)
            | where isnotempty(_s)
            | summarize
                RiskFactor_Probability_DetailedScore = strcat_array(array_sort_asc(make_set(_s)), ";")
              by
                SecurityDomain,
                Category,
                SubCategory,
                ConfigurationName;


        // Final summary output
        SummaryMain
        | join kind=leftouter SummaryDetail on SecurityDomain, Category, SubCategory, ConfigurationName
        | join kind=leftouter SummaryDetailScore on SecurityDomain, Category, SubCategory, ConfigurationName
        | project
            SecurityDomain,
            Category,
            SubCategory,
            ConfigurationName,
            ConfigurationId,
            SecuritySeverity,
            CriticalityTier,
            CriticalityTierLevel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by
            RiskFactor_Probability desc,
            CriticalityTier asc,
            TotalIssues desc,
            AssetCount desc


  - ReportName: Attack_Paths_Detailed_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure 
    ReportPurpose: Attack Paths with Device with high severity vulnerabilities allows lateral movement
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // =================================================================================================
        // REPORT  Credential driven attack paths from vulnerable devices to Azure targets using Exposure Graph
        // =================================================================================================
        //
        // Report purpose
        // Identify devices with vulnerabilities and trace credential driven attack paths that start from the device,
        // pivot through exposed credentials to an identity, and end on a target resource. Paths are prioritized by the
        // business impact of the FINAL TARGET using the standard context scoring model.
        //
        // Interpretation guard and priority rules
        // - Priority is driven by the TARGET criticality tier first
        // - Then by tier escalation where source tier is higher than target tier
        // - Then by internet exposure where target exposure is weighted higher than source exposure
        // - A low tier source cannot outrank a tier 0 or tier 1 target
        //
        // Output description detailed rows
        // One row per unique Device -> Credential -> Identity -> Target path enriched with
        // - IsInternetExposed, AssetTierByTag, LegacyEndOfSupport
        // - RiskFactor probability including detailed breakdown
        // - AttackPathPriorityScore with EscalationWeight and ExposureWeight
        // - LateralMovementType plus AttackPath and AttackPathDetailed
        //
        // Query steps overview
        // Step 0  Define legacy operating system reference lists
        // Step 1  Build Nodes catalog using standard context fields
        // Step 2  Find devices with CVEs and pull CVE severity from CVE nodes
        // Step 3  Find credentials and identities present on vulnerable devices
        // Step 4  Hop 1 credential can authenticate as identity
        // Step 5  Hop 2 identity can access target resources
        // Step 6  Enrich source device, identity, target, and credential nodes from Nodes
        // Step 7  Calculate tier escalation, lateral movement, and AttackPathPriorityScore
        // Step 8  Project detailed report columns and sort
        // =================================================================================================


        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build Nodes catalog used to enrich attack paths (standard context)
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier--SI"], tagsBag2["AssetTier--SI"], tagsBag3["AssetTier--SI"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))

            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            // Keep CVE severity too for CVE nodes
            | extend CVESeverity =
                tostring(coalesce(
                    NodeProperties.rawData.severity,
                    NodeProperties.rawData.Severity,
                    NodeProperties.rawData.cvssScore,
                    ""
                ))

            | project
                AssetNodeId = NodeId,
                AssetName   = NodeNameNorm,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,

                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,

                IsInternetExposed,
                IsExcluded,
                AssetTierByTag,
                LegacyEndOfSupport,

                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,

                CVESeverity;


        // Step 2  Find devices with CVEs and capture CVE severity from CVE nodes
        let DevicesWithCVEs =
            ExposureGraphEdges
            | where SourceNodeLabel == "Cve"
            | where EdgeLabel == "affecting"
            | where TargetNodeLabel in ("device", "computer-account", "microsoft.compute/virtualmachines")
            | project
                CVENodeId   = SourceNodeId,
                CVENodeName = SourceNodeName,
                DeviceNodeId    = TargetNodeId,
                DeviceNodeName  = TargetNodeName,
                DeviceNodeLabel = TargetNodeLabel
            | join kind=leftouter (
                Nodes
                | project
                    CVE_NodeId = AssetNodeId,
                    CVESeverity
            ) on $left.CVENodeId == $right.CVE_NodeId
            | summarize
                CVEs          = make_set(CVENodeName),
                CVESeverities = make_set(CVESeverity),
                CVECount      = dcount(CVENodeId),

                HighSeverityCVEs = countif(
                    tolower(CVESeverity) has "critical"
                    or tolower(CVESeverity) has "high"
                    or tolower(CVESeverity) has "medium"
                ),

                FirstCVE         = any(CVENodeName),
                FirstCVESeverity = any(CVESeverity)
              by
                DeviceNodeId,
                DeviceNodeName,
                DeviceNodeLabel;


        // Step 3  Find credentials and identities present on those vulnerable devices
        let CredentialsOnVulnerableDevices =
            DevicesWithCVEs
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("contains", "defined in", "runs on", "has credentials of", "frequently logged in by")
                | where TargetNodeLabel in (
                    "user",
                    "serviceprincipal",
                    "managedidentity",
                    "entra-userCookie",
                    "azure-active-directory-app-secret",
                    "user-azure-cli-secret",
                    "azure-storage-shared-access-signature",
                    "azure-storage-connection-string",
                    "azure-database-connection-string",
                    "azure-app-configuration-key",
                    "azure-active-directory-user-credentials",
                    "service-principal-azure-cli-secret"
                )
                | project
                    SourceDeviceId = SourceNodeId,
                    CredentialNodeId    = TargetNodeId,
                    CredentialNodeName  = TargetNodeName,
                    CredentialNodeLabel = TargetNodeLabel
            ) on $left.DeviceNodeId == $right.SourceDeviceId
            | project
                DeviceNodeId, DeviceNodeName, DeviceNodeLabel,
                CVEs, CVESeverities, CVECount, HighSeverityCVEs, FirstCVE, FirstCVESeverity,
                CredentialNodeId, CredentialNodeName, CredentialNodeLabel;


        // Step 4  Hop 1 credential can authenticate as identity
        let Hop1 =
            CredentialsOnVulnerableDevices
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
                | project
                    Hop1_SourceCredentialId = SourceNodeId,
                    Hop1_EdgeLabel          = EdgeLabel,
                    IdentityNodeId          = TargetNodeId,
                    IdentityNodeName        = TargetNodeName,
                    IdentityNodeLabel       = TargetNodeLabel
            ) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId
            | project
                DeviceNodeId, DeviceNodeName, DeviceNodeLabel,
                CVEs, CVESeverities, CVECount, HighSeverityCVEs, FirstCVE, FirstCVESeverity,
                CredentialNodeId, CredentialNodeName, CredentialNodeLabel,
                Hop1Edge = Hop1_EdgeLabel,
                IdentityNodeId, IdentityNodeName, IdentityNodeLabel;


        // Step 5  Hop 2 identity can access target resources
        let Paths =
            Hop1
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("can authenticate to", "has permissions to", "has role on")
                | where TargetNodeLabel in (
                    "microsoft.keyvault/vaults",
                    "microsoft.storage/storageaccounts",
                    "microsoft.sql/servers",
                    "microsoft.sql/servers/databases",
                    "microsoft.compute/virtualmachines",
                    "microsoft.compute/virtualmachines/extensions",
                    "microsoft.cognitiveservices/accounts",
                    "microsoft.cognitiveservices/accounts/deployments",
                    "microsoft.cognitiveservices/accounts_openai",
                    "microsoft.operationalinsights/workspaces",
                    "microsoft.web/sites_webapp",
                    "microsoft.web/serverfarms",
                    "microsoft.logic/workflows",
                    "microsoft.network/virtualnetworks",
                    "microsoft.network/virtualnetworks/subnets",
                    "microsoft.network/networksecuritygroups",
                    "subscriptions",
                    "resourcegroups",
                    "BlobContainer",
                    "device",
                    "computer-account"
                )
                | project
                    Hop2_SourceIdentityId = SourceNodeId,
                    Hop2_EdgeLabel        = EdgeLabel,
                    FinalTargetId         = TargetNodeId,
                    FinalTargetName       = TargetNodeName,
                    FinalTargetLabel      = TargetNodeLabel
            ) on $left.IdentityNodeId == $right.Hop2_SourceIdentityId
            | where DeviceNodeId != FinalTargetId
            | summarize
                CVEs             = any(CVEs),
                CVESeverities    = any(CVESeverities),
                CVECount         = any(CVECount),
                HighSeverityCVEs = any(HighSeverityCVEs),
                FirstCVE         = any(FirstCVE),
                FirstCVESeverity = any(FirstCVESeverity),

                CredentialNodeId    = any(CredentialNodeId),
                CredentialNodeName  = any(CredentialNodeName),
                CredentialNodeLabel = any(CredentialNodeLabel),

                IdentityNodeId    = any(IdentityNodeId),
                IdentityNodeName  = any(IdentityNodeName),
                IdentityNodeLabel = any(IdentityNodeLabel),

                Hop1Edge = any(Hop1Edge),
                Hop2Edge = any(Hop2_EdgeLabel),

                FinalTargetName  = any(FinalTargetName),
                FinalTargetLabel = any(FinalTargetLabel)
              by
                DeviceNodeId, DeviceNodeName, DeviceNodeLabel,
                FinalTargetId;


        // Step 6-8  Enrich and score using standard context (DETAILED OUTPUT)
        Paths
        | join kind=leftouter (
            Nodes
            | project-rename
                SourceDeviceId                = AssetNodeId,
                SourceDeviceCriticalityTier   = CriticalityTier,
                SourceDeviceCriticalityLevel  = CriticalityTierLevel,
                SourceDeviceIsInternetExposed = IsInternetExposed,
                SourceDeviceIsExcluded        = IsExcluded,
                SourceDeviceAssetTierByTag    = AssetTierByTag,
                SourceDeviceLegacyEndOfSupport= LegacyEndOfSupport,
                SourceDeviceRiskProb          = RiskFactor_Probability,
                SourceDeviceRiskProbDetailed  = RiskFactor_Probability_Detailed,
                SourceDeviceRiskProbDetailedScore = RiskFactor_Probability_DetailedScore
        ) on $left.DeviceNodeId == $right.SourceDeviceId

        | join kind=leftouter (
            Nodes
            | project-rename
                IntermediateNodeId                 = AssetNodeId,
                IntermediateCriticalityTier        = CriticalityTier,
                IntermediateCriticalityTierLevel   = CriticalityTierLevel,
                IntermediateIsInternetExposed      = IsInternetExposed,
                IntermediateIsExcluded             = IsExcluded,
                IntermediateAssetTierByTag         = AssetTierByTag,
                IntermediateLegacyEndOfSupport     = LegacyEndOfSupport,
                IntermediateRiskProb               = RiskFactor_Probability,
                IntermediateRiskProbDetailed       = RiskFactor_Probability_Detailed,
                IntermediateRiskProbDetailedScore  = RiskFactor_Probability_DetailedScore
        ) on $left.IdentityNodeId == $right.IntermediateNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                = AssetNodeId,
                TargetCriticalityTier       = CriticalityTier,
                TargetCriticalityTierLevel  = CriticalityTierLevel,
                TargetIsInternetExposed     = IsInternetExposed,
                TargetIsExcluded            = IsExcluded,
                TargetAssetTierByTag        = AssetTierByTag,
                TargetLegacyEndOfSupport    = LegacyEndOfSupport,
                TargetRiskProb              = RiskFactor_Probability,
                TargetRiskProbDetailed      = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore = RiskFactor_Probability_DetailedScore,
                TargetCriticalityRuleBased  = CriticalityRuleBased,
                TargetCriticalityRuleNames  = CriticalityRuleNames,
                TargetNodeProperties        = AssetProps
        ) on $left.FinalTargetId == $right.TargetNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                CredentialNodeId_join    = AssetNodeId,
                CredentialNodeProperties = AssetProps
        ) on $left.CredentialNodeId == $right.CredentialNodeId_join

        | extend TierEscalation =
            case(
                isnotempty(SourceDeviceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceDeviceCriticalityTier > TargetCriticalityTier,
                    SourceDeviceCriticalityTier - TargetCriticalityTier,
                0
            )
        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )
        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceDeviceIsInternetExposed == true, 3, 0)
        | extend SourceTierAmplifier =
            case(
                SourceDeviceCriticalityTier == 0, 8,
                SourceDeviceCriticalityTier == 1, 5,
                SourceDeviceCriticalityTier == 2, 2,
                0
            )
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )

        | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
        | extend InternetExposureSource = iff(SourceDeviceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

        | extend AttackPath =
            strcat(
                DeviceNodeLabel, " [", DeviceNodeName, "] -> ",
                CredentialNodeLabel, " [", CredentialNodeName, "] -> ",
                IdentityNodeLabel, " [", IdentityNodeName, "] -> ",
                FinalTargetLabel, " [", FinalTargetName, "]"
            )

        | extend AttackPathDetailed =
            strcat(
                "ENTRY ", DeviceNodeLabel, " [", DeviceNodeName, "] ",
                "tier ", tostring(SourceDeviceCriticalityTier), " ", tostring(SourceDeviceCriticalityLevel), " | ", InternetExposureSource,
                " | high severity CVEs ", tostring(HighSeverityCVEs),
                " -> CREDENTIAL ", CredentialNodeLabel, " [", CredentialNodeName, "] ",
                " -> IDENTITY ", IdentityNodeLabel, " [", IdentityNodeName, "] ",
                " -> TARGET ", FinalTargetLabel, " [", FinalTargetName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " | ", InternetExposureTarget,
                " | escalation ", tostring(TierEscalation),
                " | ", LateralMovementType
            )

        | extend SecurityDomain = "Endpoint"
        | extend Category = "AttackPath_VulnerableDeviceToAzure"
        | extend Subcategory =
            case(
                TierEscalation >= 3, strcat("CVE-Based Escalation Tier ", tostring(SourceDeviceCriticalityTier), " to Tier ", tostring(TargetCriticalityTier)),
                TierEscalation >= 2, strcat("CVE-Based Escalation Tier ", tostring(SourceDeviceCriticalityTier), " to Tier ", tostring(TargetCriticalityTier)),
                TierEscalation >= 1, strcat("CVE-Based Movement Tier ", tostring(SourceDeviceCriticalityTier), " to Tier ", tostring(TargetCriticalityTier)),
                "Vulnerable Device to Azure Target"
            )

        | project
            SecurityDomain,
            Category,
            Subcategory,

            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,
            EscalationWeight,
            ExposureWeight,

            DeviceNodeId,
            DeviceNodeName,
            DeviceNodeLabel,
            SourceDeviceCriticalityTier,
            SourceDeviceCriticalityLevel,
            SourceDeviceIsInternetExposed,
            SourceDeviceAssetTierByTag,
            SourceDeviceLegacyEndOfSupport,
            SourceDeviceRiskProb,
            SourceDeviceRiskProbDetailed,
            SourceDeviceRiskProbDetailedScore,

            CVECount,
            HighSeverityCVEs,
            FirstCVE,
            FirstCVESeverity,
            CVEs,
            CVESeverities,

            CredentialNodeId,
            CredentialNodeName,
            CredentialNodeLabel,

            IdentityNodeId,
            IdentityNodeName,
            IdentityNodeLabel,
            IntermediateCriticalityTier,
            IntermediateCriticalityTierLevel,
            IntermediateIsInternetExposed,
            IntermediateLegacyEndOfSupport,
            IntermediateRiskProb,
            IntermediateRiskProbDetailed,
            IntermediateRiskProbDetailedScore,

            FinalTargetId,
            FinalTargetName,
            FinalTargetLabel,
            TargetCriticalityTier,
            TargetCriticalityTierLevel,
            TargetCriticalityRuleBased,
            TargetCriticalityRuleNames,
            TargetIsInternetExposed,
            TargetAssetTierByTag,
            TargetLegacyEndOfSupport,
            TargetRiskProb,
            TargetRiskProbDetailed,
            TargetRiskProbDetailedScore,

            Hop1Edge,
            Hop2Edge,

            AttackPath,
            AttackPathDetailed,

            TargetNodeProperties,
            CredentialNodeProperties
        | order by AttackPathPriorityScore desc, TierEscalation desc, TargetCriticalityTier asc, CVECount desc, HighSeverityCVEs desc


ReportTemplates:
  - ReportName: RiskAnalysis_Detailed_Bucket_8
    ReportPurpose: Overview
    ReportsIncluded:
      - Name: Device_Recommendations_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 8
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Device_Missing_CVEs_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 8
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Azure_Recommendations_Detailed
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Credential_Based_Lateral_Movement
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Github_to_Azure_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Public_IP_to_VM_with_CVE_Exploitation
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Identity_Group_Membership_to_Privileged_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Data_Sensitivity_to_Exposed_Credentials
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"

  - ReportName: RiskAnalysis_Detailed_Bucket_2
    ReportPurpose: Overview
    ReportsIncluded:
      - Name: Device_Recommendations_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 2
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Device_Missing_CVEs_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 2
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Azure_Recommendations_Detailed
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Credential_Based_Lateral_Movement
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Github_to_Azure_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Public_IP_to_VM_with_CVE_Exploitation
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Identity_Group_Membership_to_Privileged_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Data_Sensitivity_to_Exposed_Credentials
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
  
  - ReportName: RiskAnalysis_Summary
    ReportPurpose: Overview
    ReportsIncluded:
      - Name: Device_Recommendations_Summary
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Device_Missing_CVEs_Summary
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Azure_Recommendations_Summary
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Credential_Based_Lateral_Movement
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Github_to_Azure_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Public_IP_to_VM_with_CVE_Exploitation
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Identity_Group_Membership_to_Privileged_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Data_Sensitivity_to_Exposed_Credentials
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"

  - ReportName: AttackPaths_Detailed
    ReportPurpose: Attack Paths
    ReportsIncluded:
      - Name: Attack_Paths_Detailed_Credential_Based_Lateral_Movement
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Github_to_Azure_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Public_IP_to_VM_with_CVE_Exploitation
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Identity_Group_Membership_to_Privileged_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Data_Sensitivity_to_Exposed_Credentials
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"

  - ReportName: AttackPaths_Summary
    ReportPurpose: Attack Paths
    ReportsIncluded:
      - Name: Attack_Paths_Summary_Credential_Based_Lateral_Movement
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Github_to_Azure_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Public_IP_to_VM_with_CVE_Exploitation
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Identity_Group_Membership_to_Privileged_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Data_Sensitivity_to_Exposed_Credentials
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
