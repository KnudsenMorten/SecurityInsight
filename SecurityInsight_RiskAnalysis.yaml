Reports:
  - ReportName: Device_Missing_CVEs_Summary
    ReportPurpose: This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report Purpose
        // This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
        
        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 1  Build asset list and attach metadata used later in joins and scoring
        // Only endpoints are included
        // Excluded endpoints are removed
        // Customer facing flag is normalized from rawData or raw
        // Existing criticality fields are kept exactly as-is
        // Asset tags are collected from multiple rawData locations and combined into one list
        // AssetTags is the semicolon separated tag string
        // AssetTierByTag is extracted from AssetTags using regex and sorted for stable output
        // LegacyEndOfSupport is derived from AssetProps rawData OS platform and version fields when present
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))
            | where EG_IsExcluded == false
            | extend CriticalityLevel = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
            , CriticalityRuleBased = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
            , CriticalityRuleNames = coalesce(
                strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
            , AadDeviceId = tostring(coalesce(
                NodeProperties.rawData.aadDeviceId,
                NodeProperties.raw.aadDeviceId,
                NodeProperties.aadDeviceId
            ))
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend
                deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
                deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
                tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
            | extend AssetTags = strcat_array(_AllTags, ";")
            | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
            | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
            | extend NodeAssetTags = _AllTags
            | extend AssetOSPlatform = tostring(coalesce(NoderawData.osPlatform, NoderawData.OSPlatform, NoderawData.platform, NoderawData.operatingSystem, NoderawData.os))
            | extend AssetOSVersion  = tostring(coalesce(NoderawData.osVersion,  NoderawData.OSVersion,  NoderawData.version,  NoderawData.operatingSystemVersion))
            | extend AssetOSDistribution = tostring(coalesce(NoderawData.osDistribution, NoderawData.OSDistribution, NoderawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))
            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux = iff(
                tolower(AssetOSPlatform) has "linux"
                and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                1, 0
              )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                AadDeviceId,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                NodeAssetTags,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport;


        // Step 2  Build finding list
        // Each node can have multiple categories so Categories is expanded to one row per category
        // Only nodes with a category containing finding are included
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges whose label contains affecting are included
        // Edge properties are included when present otherwise an empty object is used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges
        // Edges can point in either direction so both directions are joined and then unioned
        // The result is summarized per AssetName AssetLabel FindingName to de-duplicate
        let AF_edges_oneway =
            Edges
            | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges_otherway =
            Edges
            | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges = union AF_edges_oneway, AF_edges_otherway;

        AF_edges
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAll         = make_bag(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            AadDeviceId          = any(AadDeviceId),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            NodeAssetTags        = any(NodeAssetTags),
            AssetTags            = any(AssetTags),
            AssetTierByTag       = any(AssetTierByTag),
            LegacyEndOfSupport   = any(LegacyEndOfSupport)
          by AssetName, AssetLabel, FindingName


        // Step 5  Build a unified Properties bag for simpler lookups
        // finding holds the full finding node properties
        // raw holds rawData if present otherwise an empty object
        // edge holds combined edge properties from all related edges
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAll)
            )


        // Step 6  Extract scoring and filter to CVE findings
        // Impact is derived from multiple possible cvss locations
        // Severity comes from raw severity
        // Only findings where FindingLabel contains CVE are kept
        | extend Impact = todouble(coalesce(
                Properties.raw.cvssScore,
                Properties.finding.raw.cvssScore,
                Properties.raw.cvss.cvssScore
            ))
        | extend SecuritySeverity = tostring(Properties.raw.severity)
        | where FindingLabel contains "CVE"


        // Step 7  Extract exploit related booleans from multiple locations
        | extend HasExploit = tobool(coalesce(
            Properties.finding.rawData.hasExploit,
            Properties.raw.hasExploit,
            Properties.finding.raw.hasExploit
        ))
        | extend IsExploitVerified = tobool(coalesce(
            Properties.finding.rawData.isExploitVerified,
            Properties.raw.isExploitVerified,
            Properties.finding.raw.isExploitVerified
        ))
        | extend IsInExploitKit = tobool(coalesce(
            Properties.finding.rawData.isInExploitKit,
            Properties.raw.isInExploitKit,
            Properties.finding.raw.isInExploitKit
        ))
        | extend IsZeroDay = tobool(coalesce(
            Properties.finding.rawData.isZeroDay,
            Properties.raw.isZeroDay,
            Properties.finding.raw.isZeroDay
        ))


        // Step 8  Compute risk factor scores at row level and build detailed strings
        // RiskFactor_Consequence is defaulted to 0 for compatibility
        // RiskFactor_Probability is a 0 to 3 score
        // Add 1 if any exploit signal is true
        // Add 1 if the asset is customer facing
        // Add 1 if the asset is legacy end-of-support
        // RiskFactor_Probability_Detailed is a semicolon separated list of factor names
        // RiskFactor_Probability_DetailedScore is a semicolon separated key value string of sub scores
        | extend RiskFactor_Consequence = 0
        | extend RF_P_ExploitSignals =
            iff(HasExploit == true or IsExploitVerified == true or IsInExploitKit == true or IsZeroDay == true, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_ExploitSignals + RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_ExploitSignals == 1,   dynamic(["ExploitSignals"]), dynamic([])),
                    iff(RF_P_InternetExposed == 1,  dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,        dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "ExploitSignals=", tostring(RF_P_ExploitSignals), ";",
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )


        // Step 9  Compute criticality tier with fallback to tags
        // CriticalityTierFromTag maps tier tags to a numeric tier
        // CriticalityTier prefers CriticalityLevel
        // If CriticalityLevel is missing then tier tags are used
        // If both are missing then default is 3
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - unmapped"
            )


        // Step 10  Set fixed classification fields for the report output
        | extend SecurityDomain = "Endpoint"
        | extend ConfigurationName = "Update vulnerable software"
        | extend ConfigurationId = "CVE"
        | extend Category    = "Vulnerabilities"
        | extend Subcategory = "CVEs (Missing Updates)"


        // Step 11  Filter out recently updated CVEs
        // last modified is extracted from two possible locations
        | extend CVELastModified = todatetime(coalesce(Properties.finding.raw.lastModifiedDate, Properties.raw.lastModifiedDate))
        | where CVELastModified < ago(40d)


        // Step 12  Build device key used for distinct counting
        // Prefer AadDeviceId when present otherwise fall back to AssetName
        | extend DeviceKey = iif(isnotempty(AadDeviceId), AadDeviceId, AssetName)


        // Step 13  Aggregate to report level
        // Risk factors use max so the group reflects the highest score observed
        // Detailed columns use any to keep string output compatible with CSV and Excel
        | summarize
            AssetCount      = dcount(DeviceKey),
            TotalIssues     = count(),
            AvgImpact       = avg(Impact),
            MaxImpact       = max(Impact),
            ImpactedAssets  = make_set(AssetName),
            SampleCVEs      = make_set(FindingLabel),
            RiskFactor_Consequence = max(RiskFactor_Consequence),
            RiskFactor_Probability = max(RiskFactor_Probability),
            RiskFactor_Probability_Detailed = any(RiskFactor_Probability_Detailed),
            RiskFactor_Probability_DetailedScore = any(RiskFactor_Probability_DetailedScore)
          by SecurityDomain, Category, Subcategory, ConfigurationName, ConfigurationId, CriticalityTier, CriticalityTierLevel, SecuritySeverity


        // Step 14  Final shape and sorting
        | project
            SecurityDomain,
            Category,
            Subcategory,
            ConfigurationName,
            ConfigurationId,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            AvgImpact = round(AvgImpact, 1),
            MaxImpact = toint(ceiling(MaxImpact)),
            ImpactedAssets,
            SampleCVEs
        | order by CriticalityTier asc, MaxImpact desc, AvgImpact desc, AssetCount desc, TotalIssues desc
                
  - ReportName: Device_Missing_CVEs_Detailed
    ReportPurpose: This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AadDeviceId"
      - "CVELastModified"
      - "CVSSDesc"
      - "CVE_ID"
      - "CriticalityRuleBased"
      - "CriticalityRuleNames"
      - "CriticalityLevel"
      - "AssetTierByTag"
      - "AssetTags"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report Purpose
        // This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.

        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 1  Build asset list for endpoints and keep existing risk flags
        // Only Endpoint assets are included
        // Customer facing and excluded flags are normalized from rawData or raw
        // Excluded assets are filtered out early
        // Existing criticality fields are kept as-is
        // Asset tags are collected from multiple rawData locations and combined into one list
        // AssetTags is a semicolon separated string of all tags
        // AssetTierByTag is extracted from AssetTags using regex and sorted for stable output
        // LegacyEndOfSupport is derived from AssetProps rawData OS fields when present
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))
            | where EG_IsExcluded == false
            | extend CriticalityLevel = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
            , CriticalityRuleBased = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
            , CriticalityRuleNames = coalesce(
                strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
            , AadDeviceId = tostring(coalesce(
                NodeProperties.rawData.aadDeviceId,
                NodeProperties.raw.aadDeviceId,
                NodeProperties.aadDeviceId
            ))
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend
                deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
                deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
                tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
            | extend AssetTags = strcat_array(_AllTags, ";")
            | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
            | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
            | extend NodeAssetTags = _AllTags
            | extend AssetOSPlatform = tostring(coalesce(NoderawData.osPlatform, NoderawData.OSPlatform, NoderawData.platform, NoderawData.operatingSystem, NoderawData.os))
            | extend AssetOSVersion  = tostring(coalesce(NoderawData.osVersion,  NoderawData.OSVersion,  NoderawData.version,  NoderawData.operatingSystemVersion))
            | extend AssetOSDistribution = tostring(coalesce(NoderawData.osDistribution, NoderawData.OSDistribution, NoderawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))
            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux = iff(
                tolower(AssetOSPlatform) has "linux"
                and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                1, 0
              )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                AadDeviceId,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                NodeAssetTags,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport;


        // Step 2  Build finding list
        // Categories is expanded to allow filtering on any category value
        // Only nodes with a category containing finding are included
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges with labels containing affecting are used
        // Edge properties are included when present otherwise an empty object is used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        // Both directions are needed because source and target can be swapped
        // The union is later de-duplicated using summarize by asset and finding identifiers
        let AF_edges_oneway =
            Edges
            | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges_otherway =
            Edges
            | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges = union AF_edges_oneway, AF_edges_otherway;


        // Step 5  De-duplicate and merge edge properties
        AF_edges
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAll         = make_bag(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            AadDeviceId          = any(AadDeviceId),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            NodeAssetTags        = any(NodeAssetTags),
            AssetTags            = any(AssetTags),
            AssetTierByTag       = any(AssetTierByTag),
            LegacyEndOfSupport   = any(LegacyEndOfSupport)
          by AssetName, AssetLabel, FindingName


        // Step 6  Build a unified Properties bag used for extraction
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAll)
            )


        // Step 7  Extract CVSS impact and severity and keep only CVEs
        | extend Impact = todouble(coalesce(
                Properties.raw.cvssScore,
                Properties.finding.raw.cvssScore,
                Properties.raw.cvss.cvssScore
            ))
        | extend SecuritySeverity = tostring(Properties.raw.severity)
        | where FindingLabel contains "CVE"


        // Step 8  Set fixed domain and category values for this dataset
        | extend SecurityDomain = "Endpoint"
        | extend ConfigurationId = "CVE"
        | extend Category    = "Vulnerabilities"
        | extend Subcategory = "CVEs (Missing Updates)"


        // Step 9  Filter by CVE last modified date
        | extend CVELastModified = todatetime(coalesce(Properties.finding.raw.lastModifiedDate, Properties.raw.lastModifiedDate))
        | where CVELastModified < ago(40d)


        // Step 10  Extract exploit related flags from multiple possible locations
        | extend HasExploit = tobool(coalesce(
            Properties.finding.rawData.hasExploit,
            Properties.raw.hasExploit,
            Properties.finding.raw.hasExploit
        ))
        | extend IsExploitVerified = tobool(coalesce(
            Properties.finding.rawData.isExploitVerified,
            Properties.raw.isExploitVerified,
            Properties.finding.raw.isExploitVerified
        ))
        | extend IsInExploitKit = tobool(coalesce(
            Properties.finding.rawData.isInExploitKit,
            Properties.raw.isInExploitKit,
            Properties.finding.raw.isInExploitKit
        ))
        | extend IsZeroDay = tobool(coalesce(
            Properties.finding.rawData.isZeroDay,
            Properties.raw.isZeroDay,
            Properties.finding.raw.isZeroDay
        ))


        // Step 11  Compute risk factor fields and detailed strings
        // RiskFactor_Consequence is defaulted to 0
        // RiskFactor_Probability is a 0 to 3 score
        // Add 1 when any exploit signal is present
        // Add 1 when the asset is customer facing
        // Add 1 when the asset is legacy end-of-support
        | extend RiskFactor_Consequence = 0
        | extend RF_P_ExploitSignals =
            iff(HasExploit == true or IsExploitVerified == true or IsInExploitKit == true or IsZeroDay == true, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_ExploitSignals + RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_ExploitSignals == 1,   dynamic(["ExploitSignals"]), dynamic([])),
                    iff(RF_P_InternetExposed == 1,  dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,        dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "ExploitSignals=", tostring(RF_P_ExploitSignals), ";",
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )


        // Step 12  Compute criticality tier with fallback to tier tags
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - unmapped"
            )


        // Step 13  Extra safety filter to ensure excluded assets do not appear
        | where EG_IsExcluded == false


        // Step 14  Final projection and ordering for detailed output
        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName,
            AssetLabel,
            AadDeviceId,
            EG_IsCustomerFacing,
            EG_IsExcluded,

            ConfigurationName = FindingName,
            CVE_ID = FindingLabel,
            ConfigurationId,

            CriticalityLevel,
            CriticalityRuleBased,
            CriticalityRuleNames,
            CriticalityTier,
            CriticalityTierLevel,

            AssetTierByTag,
            AssetTags,
            LegacyEndOfSupport,

            Impact,
            SecuritySeverity,
            CVELastModified,

            HasExploit,
            IsExploitVerified,
            IsInExploitKit,
            IsZeroDay,

            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,

            CVSSDesc = tostring(coalesce(
                Properties.finding.rawData.description,
                Properties.raw.description,
                Properties.finding.raw.description
            )),
            AssetProps,
            Properties
        | order by CriticalityTier asc, Impact desc, AssetName asc, CVE_ID asc

  - ReportName: Device_Missing_CVEs_Detailed_BucketFilter
    ReportPurpose: This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AadDeviceId"
      - "CVELastModified"
      - "CVSSDesc"
      - "CVE_ID"
      - "CriticalityRuleBased"
      - "CriticalityRuleNames"
      - "CriticalityLevel"
      - "AssetTierByTag"
      - "AssetTags"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report Purpose
        // This report highlights overdue endpoint CVEs older than 40 days, excluding out-of-scope assets, and prioritizes them using asset criticality, tag-based tiering, and exploit and exposure risk factors to focus remediation on the most critical and likely exploitable vulnerabilities.

        // Step 0  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 1  Build asset list for endpoints and attach fields used later
        // Only Endpoint assets are included
        // Customer facing and excluded flags are normalized from rawData or raw
        // Excluded assets are filtered out early
        // Existing criticality fields are kept exactly as-is
        // Tags are collected from multiple rawData locations and combined into one list
        // AssetTags is a semicolon separated string of all tags
        // AssetTierByTag is extracted from AssetTags using regex and stable sorting
        // LegacyEndOfSupport is derived from AssetProps rawData OS fields when present
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))
            | where EG_IsExcluded == false
            | extend CriticalityLevel = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
            , CriticalityRuleBased = toint(coalesce(
                tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
            , CriticalityRuleNames = coalesce(
                strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
            , AadDeviceId = tostring(coalesce(
                NodeProperties.rawData.aadDeviceId,
                NodeProperties.raw.aadDeviceId,
                NodeProperties.aadDeviceId
            ))
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend
                deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
                deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
                tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
            | extend AssetTags = strcat_array(_AllTags, ";")
            | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
            | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
            | extend NodeAssetTags = _AllTags
            | extend AssetOSPlatform = tostring(coalesce(NoderawData.osPlatform, NoderawData.OSPlatform, NoderawData.platform, NoderawData.operatingSystem, NoderawData.os))
            | extend AssetOSVersion  = tostring(coalesce(NoderawData.osVersion,  NoderawData.OSVersion,  NoderawData.version,  NoderawData.operatingSystemVersion))
            | extend AssetOSDistribution = tostring(coalesce(NoderawData.osDistribution, NoderawData.OSDistribution, NoderawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))
            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux = iff(
                tolower(AssetOSPlatform) has "linux"
                and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                1, 0
              )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                AadDeviceId,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                NodeAssetTags,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport;


        // Step 2  Build finding list
        // Categories is expanded to allow filtering on any category value
        // Only nodes with a category containing finding are included
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges with labels containing affecting are used
        // Edge properties are included when present otherwise an empty object is used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        // Both directions are needed because source and target can be swapped
        // The union is later de-duplicated using summarize by asset and finding identifiers
        let AF_edges_oneway =
            Edges
            | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges_otherway =
            Edges
            | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
            | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            | project AssetName, AssetLabel, AadDeviceId, EG_IsCustomerFacing, EG_IsExcluded,
                      FindingName, FindingLabel, FindingCategories, FindingProps,
                      EdgeLabel, EdgeProps,
                      AssetProps, CriticalityLevel, CriticalityRuleBased, CriticalityRuleNames,
                      NodeAssetTags, AssetTags, AssetTierByTag, LegacyEndOfSupport;

        let AF_edges = union AF_edges_oneway, AF_edges_otherway;


        // Step 5  De-duplicate asset to finding rows and merge edge properties
        // One row per AssetName AssetLabel FindingName is kept
        // Edge labels and edge properties across duplicates are combined
        AF_edges
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAll         = make_bag(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            AadDeviceId          = any(AadDeviceId),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            NodeAssetTags        = any(NodeAssetTags),
            AssetTags            = any(AssetTags),
            AssetTierByTag       = any(AssetTierByTag),
            LegacyEndOfSupport   = any(LegacyEndOfSupport)
          by AssetName, AssetLabel, FindingName


        // Step 6  Build a unified Properties bag for simpler lookups
        // finding holds the full finding node properties
        // raw holds rawData if present otherwise an empty object
        // edge holds combined edge properties from all related edges
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAll)
            )


        // Step 7  Extract scoring fields and filter to CVE findings
        // Impact is derived from multiple possible cvss locations
        // Severity comes from raw severity
        // Only findings where FindingLabel contains CVE are kept
        | extend Impact = todouble(coalesce(
                Properties.raw.cvssScore,
                Properties.finding.raw.cvssScore,
                Properties.raw.cvss.cvssScore
            ))
        | extend SecuritySeverity = tostring(Properties.raw.severity)
        | where FindingLabel contains "CVE"


        // Step 8  Compute criticality tier with fallback to tier tags
        // CriticalityLevel is preferred when present
        // When CriticalityLevel is missing tier tags are mapped to a numeric tier
        // When both are missing tier 3 is used as default
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - unmapped"
            )


        // Step 9  Set fixed domain and category values for this dataset
        | extend SecurityDomain = "Endpoint"
        | extend ConfigurationId = "CVE"
        | extend Category    = "Vulnerabilities"
        | extend Subcategory = "CVEs (Missing Updates)"


        // Step 10  Filter by CVE last modified date
        | extend CVELastModified = todatetime(coalesce(Properties.finding.raw.lastModifiedDate, Properties.raw.lastModifiedDate))
        | where CVELastModified < ago(40d)


        // Step 11  Extract exploit related flags from finding rawData and raw
        | extend HasExploit = tobool(coalesce(
            Properties.finding.rawData.hasExploit,
            Properties.raw.hasExploit,
            Properties.finding.raw.hasExploit
        ))
        | extend IsExploitVerified = tobool(coalesce(
            Properties.finding.rawData.isExploitVerified,
            Properties.raw.isExploitVerified,
            Properties.finding.raw.isExploitVerified
        ))
        | extend IsInExploitKit = tobool(coalesce(
            Properties.finding.rawData.isInExploitKit,
            Properties.raw.isInExploitKit,
            Properties.finding.raw.isInExploitKit
        ))
        | extend IsZeroDay = tobool(coalesce(
            Properties.finding.rawData.isZeroDay,
            Properties.raw.isZeroDay,
            Properties.finding.raw.isZeroDay
        ))


        // Step 12  Compute risk factor fields at row level and provide detailed strings
        // RiskFactor_Consequence is defaulted to 0
        // RiskFactor_Probability is a 0 to 3 score
        // Add 1 when any exploit signal is present
        // Add 1 when the asset is customer facing
        // Add 1 when the asset is legacy end-of-support
        // RiskFactor_Probability_Detailed and RiskFactor_Probability_DetailedScore are semicolon separated strings
        | extend RiskFactor_Consequence = 0
        | extend RF_P_ExploitSignals =
            iff(HasExploit == true or IsExploitVerified == true or IsInExploitKit == true or IsZeroDay == true, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_ExploitSignals + RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_ExploitSignals == 1,   dynamic(["ExploitSignals"]), dynamic([])),
                    iff(RF_P_InternetExposed == 1,  dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,        dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "ExploitSignals=", tostring(RF_P_ExploitSignals), ";",
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )


        // Step 13  Extra safety filter to ensure excluded assets do not appear
        | where EG_IsExcluded == false


        // Step 14  Bucket filter support
        // DeviceKey is used for bucket filtering and distinct counting
        | extend DeviceKey = iif(isnotempty(AadDeviceId), AadDeviceId, AssetName)
        __BUCKET_FILTER__


        // Step 15  Final projection and ordering for detailed output
        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName,
            AssetLabel,
            AadDeviceId,
            EG_IsCustomerFacing,
            EG_IsExcluded,

            ConfigurationName = FindingName,
            CVE_ID = FindingLabel,
            ConfigurationId,

            CriticalityLevel,
            CriticalityRuleBased,
            CriticalityRuleNames,
            CriticalityTier,
            CriticalityTierLevel,

            AssetTierByTag,
            AssetTags,
            LegacyEndOfSupport,

            Impact,
            SecuritySeverity,
            CVELastModified,

            HasExploit,
            IsExploitVerified,
            IsInExploitKit,
            IsZeroDay,

            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,

            CVSSDesc = tostring(coalesce(
                Properties.finding.rawData.description,
                Properties.raw.description,
                Properties.finding.raw.description
            )),
            AssetProps,
            Properties
        | order by CriticalityTier asc, Impact desc, AssetName asc, CVE_ID asc
       
  - ReportName: Device_Recommendations_Summary
    ReportPurpose: Identify non-compliant TVM secure configuration controls on endpoints, enriched with Exposure Graph criticality and risk context, and scored with a probability model that includes Internet-Exposed (from EG CustomerFacing) and LegacyEndOfSupport based on OS platform
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Identify non-compliant TVM secure configuration controls on endpoints, enriched with Exposure Graph criticality and risk context, and scored with a probability model that includes Internet-Exposed (from EG CustomerFacing) and LegacyEndOfSupport based on OS platform

        // Step 0  Define configuration IDs removed from the Windows Server scope
        // These controls do not make sense for Windows Server devices (in my opinion!)
        // They are excluded only when OSPlatform indicates Windows Server
        let excludeForWindowsServer = dynamic([
          "scid-2090",
          "scid-22"
        ]);

        // Step 1  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        // Step 2  Define legacy macOS major versions
        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        // Step 3  Define legacy Linux matchers
        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 4  Define lookup tables for short standard texts
        // If a category or subcategory is not present in these lookups, the output keeps the name and leaves description empty
        let CategoryLookup = datatable(Category:string, CategoryDescription:string)
        [
          "Security controls", "Endpoint protection and attack-surface policies that block common malware and attacker techniques.",
          "Network",           "Network security policies that limit attack surface and lateral movement.",
          "BitLocker",         "Full-disk encryption to prevent data exposure on lost or stolen devices.",
          "OS",                "Operating system baseline hardening and core protections.",
          "Credentials",       "Controls that prevent credential theft and reuse.",
          "Browser",           "Safe browsing and web threat protections.",
          "Application",       "Application control and exploit protection to restrict unauthorized code execution.",
          "Device",            "General endpoint configuration and health requirements.",
          "Audit",             "Monitoring-focused baselines to validate configuration posture."
        ];

        let SubCategoryLookup = datatable(Subcategory:string, SubCategoryDescription:string)
        [
          "EDR",                        "Defender for Endpoint sensor presence and reporting health.",
          "Attack Surface Reduction",   "Blocks common malware execution paths from email, web and Office content.",
          "Firewall",                   "Enforces inbound/outbound traffic policy and host firewall state.",
          "Antivirus",                  "Ensures Microsoft Defender Antivirus is active and properly configured.",
          "BitLocker",                  "Enforces full-disk encryption and key escrow.",
          "Exploit Guard",              "Hardens OS/apps against memory corruption and exploit chains.",
          "Authentication",             "Strengthens sign-in security and protects credential boundaries.",
          "Remote Access",              "Restricts remote shell/administrative entry points.",
          "TLS/Communication",          "Requires secure protocols and prevents crypto downgrade.",
          "Removable Storage",          "Controls external media to reduce malware risk and data exfiltration."
        ];

        // Step 5  Define query parameters
        let lookback         = 30d;
        let onlyApplicable   = true;
        let osFilter         = dynamic([]);
        let categoryFilter   = dynamic([]);
        let idFilter         = dynamic([]);
        let nameSearch       = "";
        let sortByImpactDesc = true;
        let SecurityDomain   = "Endpoint";

        // Step 6  Get latest DeviceInfo per device for enrichment
        // OSVersion and OSDistribution are included for macOS and Linux legacy detection
        let DeviceInfoLatest =
          DeviceInfo
          | where TimeGenerated >= ago(lookback)
          | summarize arg_max(TimeGenerated, *) by DeviceId
          | project
              DeviceId,
              DI_DeviceName      = DeviceName,
              DI_OSPlatform      = tostring(OSPlatform),
              DI_OSVersion       = tostring(OSVersion),
              DI_OSDistribution  = tostring(OSDistribution),
              DI_MachineGroup    = MachineGroup,
              DI_AssetValue      = tostring(AssetValue),
              DI_ExposureLevel   = tostring(ExposureLevel),
              DI_AzureResourceId = tostring(AzureResourceId),
              DI_AadDeviceId     = tostring(AadDeviceId);

        // Step 7  Build exposure graph asset table and join key
        // Tier tags are extracted from AssetTags and used as a fallback for criticality when EG criticality is missing
        let EG_Assets =
          ExposureGraphNodes
          | extend CriticalityLevel = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
              tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
          | extend EG_AadDeviceId = tostring(coalesce(
              NodeProperties.rawData.aadDeviceId,
              NodeProperties.raw.aadDeviceId,
              NodeProperties.aadDeviceId
            ))
          | extend EG_IsCustomerFacing = tobool(coalesce(
              NodeProperties.rawData.isCustomerFacing,
              NodeProperties.raw.isCustomerFacing
            ))
          | extend EG_IsExcluded = tobool(coalesce(
              NodeProperties.rawData.isExcluded,
              NodeProperties.raw.isExcluded
            ))
          | extend NoderawData = todynamic(NodeProperties).rawData
          | extend
              deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
              deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
              tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
          | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
          | extend AssetTags = strcat_array(_AllTags, ";")
          | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
          | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
          | project
              EG_AadDeviceId,
              EG_AssetName    = NodeName,
              EG_AssetLabel   = NodeLabel,
              EG_AssetProps   = NodeProperties,
              EG_CriticalityLevel = CriticalityLevel,
              EG_IsCustomerFacing,
              EG_IsExcluded,
              AssetTags,
              AssetTierByTag;

        // Step 8  Load TVM secure configuration data and KB enrichment
        // Controls listed in excludeForWindowsServer are excluded only for Windows Server devices
        let TVM_Base =
          DeviceTvmSecureConfigurationAssessment
          | where TimeGenerated >= ago(lookback)
          | where (array_length(osFilter) == 0 or OSPlatform in~ (osFilter))
          | where (array_length(idFilter) == 0 or ConfigurationId in~ (idFilter))
          | where (nameSearch == "" or tostring(DeviceName) contains nameSearch)
          | where not (OSPlatform contains "WindowsServer" and ConfigurationId in~ (excludeForWindowsServer))
          | where iff(onlyApplicable, IsApplicable == 1, true)
          | join kind=leftouter (
              DeviceTvmSecureConfigurationAssessmentKB
              | project
                  ConfigurationId,
                  KB_ConfigurationName        = ConfigurationName,
                  KB_ConfigurationCategory    = ConfigurationCategory,
                  KB_ConfigurationSubcategory = ConfigurationSubcategory,
                  KB_Impact                   = toint(ConfigurationImpact),
                  KB_RiskDescription          = tostring(RiskDescription),
                  KB_Description              = tostring(ConfigurationDescription),
                  KB_Remediation              = tostring(RemediationOptions),
                  KB_Benchmarks               = ConfigurationBenchmarks
            ) on ConfigurationId
          | where (array_length(categoryFilter) == 0 or KB_ConfigurationCategory in~ (categoryFilter))
          | extend ImpactInt = toint(coalesce(KB_Impact, toint(ConfigurationImpact)))
          | extend
              Category          = coalesce(KB_ConfigurationCategory, ConfigurationCategory),
              Subcategory       = KB_ConfigurationSubcategory,
              ConfigurationName = coalesce(KB_ConfigurationName, tostring(ConfigurationId)),
              IsCompliant       = tobool(IsCompliant),
              IsApplicable      = tobool(IsApplicable)
          | extend
              SecuritySeverity =
                  case(
                      ImpactInt == 10, "Very High",
                      ImpactInt == 9,  "High",
                      ImpactInt == 8,  "Medium-High",
                      ImpactInt >= 5,  "Medium",
                      "Low Risk"
                  ),
              SortKey = iff(sortByImpactDesc, todouble(ImpactInt), 0.0)
          | summarize arg_max(TimeGenerated, *) by DeviceId, ConfigurationId
          | where IsCompliant == false
          // Category and Subcategory descriptions are optional
          // Unknown categories keep the name and return an empty description
          | lookup CategoryLookup on Category
          | lookup SubCategoryLookup on Subcategory
          | extend
              CategoryDescription    = coalesce(CategoryDescription, ""),
              SubCategoryDescription = coalesce(SubCategoryDescription, "");

        // Step 9  Enrich TVM findings with DeviceInfo and Exposure Graph metadata
        // Excluded exposure graph assets are filtered out
        // CriticalityTier prefers EG criticality and falls back to tier tags if missing
        TVM_Base
        | join kind=leftouter (DeviceInfoLatest) on DeviceId
        | join kind=leftouter (
            EG_Assets
            | where isnotempty(EG_AadDeviceId)
        ) on $left.DI_AadDeviceId == $right.EG_AadDeviceId
        | where EG_IsExcluded == false

        | extend CriticalityTierFromTag =
            case(
              AssetTierByTag has "--tier0--SI", 0,
              AssetTierByTag has "--tier1--SI", 1,
              AssetTierByTag has "--tier2--SI", 2,
              AssetTierByTag has "--tier3--SI", 3,
              int(null)
            )
        | extend Criticality = toint(coalesce(EG_CriticalityLevel, CriticalityTierFromTag))
        | where isnotempty(Criticality)

        | extend SecurityDomain = SecurityDomain
        | extend CriticalityTier = toint(Criticality)
        | extend CriticalityTierLevel =
            case(
              CriticalityTier == 3, "Low - tier 3",
              CriticalityTier == 2, "Medium - tier 2",
              CriticalityTier == 1, "High - tier 1",
              CriticalityTier == 0, "Critical - tier 0",
              "Unknown - unmapped"
            )

        // Step 10  Detect legacy end-of-support operating systems
        // Windows legacy uses DI_OSPlatform list
        // macOS legacy uses major version from DI_OSVersion
        // Linux legacy uses substring matching against DI_OSDistribution and DI_OSVersion
        | extend MacMajor = toint(extract(@"^(\d+)", 1, DI_OSVersion))
        | extend IsLegacyWindows = iff(DI_OSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
        | extend IsLegacyMacOS = iff(tolower(DI_OSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
        | extend IsLegacyLinux = iff(
              tolower(DI_OSPlatform) has "linux"
              and (DI_OSDistribution has_any (LegacyLinuxMatchers) or DI_OSVersion has_any (LegacyLinuxMatchers)),
              1, 0
          )
        | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

        // Step 11  Compute risk factor fields and detailed explanation columns
        // RiskFactor_Probability is additive
        // +1 Internet-Exposed based on graph customer facing signal
        // +1 LegacyEndOfSupport when OS is treated as legacy
        // Detailed columns are exported as strings with semicolon separators
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = LegacyEndOfSupport
        | extend RiskFactor_Consequence = 0
        | extend RiskFactor_Probability = RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
                array_concat(
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1,       dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ),
                ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
                "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
                "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )

        // Step 12  Summarize to report level by configuration and tier
        // RiskFactor_Probability uses max so the group reflects the highest score observed
        // Detailed columns use any to keep string output compatible with CSV and Excel exports
        | summarize
            AssetCount     = dcount(DeviceId),
            TotalIssues    = count(),
            ImpactedAssets = make_set(coalesce(DI_DeviceName, DeviceName)),
            RiskFactor_Probability = toint(max(RiskFactor_Probability)),
            RiskFactor_Consequence = toint(max(RiskFactor_Consequence)),
            LegacyEndOfSupport = max(LegacyEndOfSupport),
            RiskFactor_Probability_Detailed = any(RiskFactor_Probability_Detailed),
            RiskFactor_Probability_DetailedScore = any(RiskFactor_Probability_DetailedScore)
          by
            SecurityDomain,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            CriticalityTier,
            CriticalityTierLevel,
            Impact = ImpactInt,
            SecuritySeverity,
            ConfigurationName,
            ConfigurationId

        // Step 13  Final projection and sorting
        | project
            SecurityDomain,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            ConfigurationName,
            ConfigurationId,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity,
            Impact,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            LegacyEndOfSupport,
            AssetCount,
            TotalIssues,
            ImpactedAssets
        | order by CriticalityTier asc, Impact desc, TotalIssues desc, AssetCount desc, ConfigurationId asc
        

  - ReportName: Device_Recommendations_Detailed
    ReportPurpose: Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tags, and add a probability score based on Internet-Exposed (EG CustomerFacing) and LegacyEndOfSupport OS detection
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tags, and add a probability score based on Internet-Exposed (EG CustomerFacing) and LegacyEndOfSupport OS detection

        // Step 0  Define configuration IDs removed from the Windows Server scope
        // These controls do not make sense for Windows Server devices (in my opinion!)
        // They are excluded only when OSPlatform indicates Windows Server
        let excludeForWindowsServer = dynamic([
          "scid-2090",
          "scid-22"
        ]);

        // Step 1  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 2  Lookup tables (short standard texts)
        // If a new Category or Subcategory appears, it is kept but the description is blank
        let CategoryLookup = datatable(Category:string, CategoryDescription:string)
        [
          "Security controls", "Endpoint protection and attack-surface policies that block common malware and attacker techniques.",
          "Network",           "Network security policies that limit attack surface and lateral movement.",
          "BitLocker",         "Full-disk encryption to prevent data exposure on lost or stolen devices.",
          "OS",                "Operating system baseline hardening and core protections.",
          "Credentials",       "Controls that prevent credential theft and reuse.",
          "Browser",           "Safe browsing and web threat protections.",
          "Application",       "Application control and exploit protection to restrict unauthorized code execution.",
          "Device",            "General endpoint configuration and health requirements.",
          "Audit",             "Monitoring-focused baselines to validate configuration posture."
        ];

        let SubCategoryLookup = datatable(Subcategory:string, SubCategoryDescription:string)
        [
          "EDR",                        "Defender for Endpoint sensor presence and reporting health.",
          "Attack Surface Reduction",   "Blocks common malware execution paths from email, web and Office content.",
          "Firewall",                   "Enforces inbound/outbound traffic policy and host firewall state.",
          "Antivirus",                  "Ensures Microsoft Defender Antivirus is active and properly configured.",
          "BitLocker",                  "Enforces full-disk encryption and key escrow.",
          "Exploit Guard",              "Hardens OS/apps against memory corruption and exploit chains.",
          "Authentication",             "Strengthens sign-in security and protects credential boundaries.",
          "Remote Access",              "Restricts remote shell/administrative entry points.",
          "TLS/Communication",          "Requires secure protocols and prevents crypto downgrade.",
          "Removable Storage",          "Controls external media to reduce malware risk and data exfiltration."
        ];

        // Step 3  Parameters
        let lookback         = 30d;
        let onlyApplicable   = true;
        let osFilter         = dynamic([]);
        let categoryFilter   = dynamic([]);
        let idFilter         = dynamic([]);
        let nameSearch       = "";
        let sortByImpactDesc = true;
        let SecurityDomain   = "Endpoint";

        // Step 4  DeviceInfo (latest)
        // OSVersion is optional in some schemas so it is pulled using column_ifexists
        let DeviceInfoLatest =
          DeviceInfo
          | where TimeGenerated >= ago(lookback)
          | summarize arg_max(TimeGenerated, *) by DeviceId
          | project
              DeviceId,
              DI_DeviceName      = DeviceName,
              DI_OSPlatform      = OSPlatform,
              DI_OSVersion       = tostring(column_ifexists("OSVersion", "")),
              DI_MachineGroup    = MachineGroup,
              DI_AssetValue      = tostring(AssetValue),
              DI_ExposureLevel   = tostring(ExposureLevel),
              DI_AzureResourceId = tostring(AzureResourceId),
              DI_AadDeviceId     = tostring(AadDeviceId);

        // Step 5  Exposure Graph assets (endpoints) joined via aadDeviceId
        // Asset tags are normalized from multiple rawData locations
        // AssetTierByTag lists tags containing --tier and --SI, separated with ;
        // Criticality tier prefers EG_CriticalityLevel and falls back to tier tags when missing
        let EG_Assets =
          ExposureGraphNodes
          | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
          | extend EG_CriticalityLevel = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
              tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
          , EG_CriticalityRuleBased = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
              tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
          , EG_CriticalityRuleNames = coalesce(
              strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
              strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
          | extend EG_AadDeviceId = tostring(coalesce(
              NodeProperties.rawData.aadDeviceId,
              NodeProperties.raw.aadDeviceId,
              NodeProperties.aadDeviceId
            ))
          | extend EG_IsCustomerFacing = tobool(coalesce(
              NodeProperties.rawData.isCustomerFacing,
              NodeProperties.raw.isCustomerFacing
            ))
          | extend EG_IsExcluded = tobool(coalesce(
              NodeProperties.rawData.isExcluded,
              NodeProperties.raw.isExcluded
            ))
          | extend NoderawData = todynamic(NodeProperties).rawData
          | extend
              deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
              deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
              tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
          | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
          | extend AssetTags = strcat_array(_AllTags, ";")
          | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
          | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
          | extend CriticalityTierFromTag =
              case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
              )
          | extend EG_CriticalityTier = toint(coalesce(EG_CriticalityLevel, CriticalityTierFromTag, int(null)))
          | project
              EG_AadDeviceId,
              EG_AssetName    = NodeName,
              EG_AssetLabel   = NodeLabel,
              EG_AssetProps   = NodeProperties,
              EG_CriticalityLevel,
              EG_CriticalityRuleBased,
              EG_CriticalityRuleNames,
              EG_CriticalityTier,
              EG_IsCustomerFacing,
              EG_IsExcluded,
              AssetTags,
              AssetTierByTag;

        // Step 6  TVM secure configuration assessment core dataset
        let TVM_Base =
          DeviceTvmSecureConfigurationAssessment
          | where TimeGenerated >= ago(lookback)
          | where (array_length(osFilter) == 0 or OSPlatform in~ (osFilter))
          | where (array_length(idFilter) == 0 or ConfigurationId in~ (idFilter))
          | where (nameSearch == "" or tostring(DeviceName) contains nameSearch)
          | where not (OSPlatform contains "WindowsServer" and ConfigurationId in~ (excludeForWindowsServer))
          | where iff(onlyApplicable, IsApplicable == 1, true)
          | join kind=leftouter (
              DeviceTvmSecureConfigurationAssessmentKB
              | project
                  ConfigurationId,
                  KB_ConfigurationName        = ConfigurationName,
                  KB_ConfigurationCategory    = ConfigurationCategory,
                  KB_ConfigurationSubcategory = ConfigurationSubcategory,
                  KB_Impact                   = toint(ConfigurationImpact),
                  KB_RiskDescription          = tostring(RiskDescription),
                  KB_Description              = tostring(ConfigurationDescription),
                  KB_Remediation              = tostring(RemediationOptions),
                  KB_Benchmarks               = ConfigurationBenchmarks
            ) on ConfigurationId
          | where (array_length(categoryFilter) == 0 or KB_ConfigurationCategory in~ (categoryFilter))
          | extend ImpactInt = toint(coalesce(KB_Impact, toint(ConfigurationImpact)))
          | extend
              Category          = coalesce(KB_ConfigurationCategory, ConfigurationCategory),
              Subcategory       = KB_ConfigurationSubcategory,
              ConfigurationName = coalesce(KB_ConfigurationName, tostring(ConfigurationId)),
              IsCompliant       = tobool(IsCompliant),
              IsApplicable      = tobool(IsApplicable)
          | extend
              RecommendedAction =
                  case(
                      ImpactInt >= 9, "Fix immediately - Security Change Queue / Intune / GPO rollout",
                      ImpactInt == 8, "Schedule within quarterly hardening cycle",
                      ImpactInt >= 5 and ImpactInt < 8, "Fix opportunistically (during upgrades / refresh)",
                      "Monitor, document as baseline exceptions"
                  ),
              SecuritySeverity =
                  case(
                      ImpactInt == 10, "Very High",
                      ImpactInt == 9,  "High",
                      ImpactInt == 8,  "Medium-High",
                      ImpactInt >= 5,  "Medium",
                      "Low Risk"
                  ),
              SecuritySeverityDescription =
                  case(
                      ImpactInt == 10, "If this configuration is not applied, attackers gain a major foothold or common attack vector remains wide open.",
                      ImpactInt == 9,  "Strongly recommended to fix ASAP; commonly exploited by real-world malware and ransomware.",
                      ImpactInt == 8,  "Important baseline security hardening; reduces attack surface and lateral movement.",
                      ImpactInt >= 5,  "Security best practice; helps reduce exposure but less frequently exploited.",
                      "Hardening / hygiene controls; helps, but attackers less likely to target."
                  ),
              SortKey = iff(sortByImpactDesc, todouble(ImpactInt), 0.0)
          | summarize arg_max(TimeGenerated, *) by DeviceId, ConfigurationId
          | where IsCompliant == false
          | lookup CategoryLookup on Category
          | lookup SubCategoryLookup on Subcategory
          | extend
              CategoryDescription    = iff(isnotempty(CategoryDescription), CategoryDescription, ""),
              SubCategoryDescription = iff(isnotempty(SubCategoryDescription), SubCategoryDescription, "");

        // Step 7  Enrich with DeviceInfo and Exposure Graph, compute tier and risk factors
        // RiskFactor_Probability increments for Internet-Exposed and LegacyEndOfSupport
        // RiskFactor_Probability_Detailed and RiskFactor_Probability_DetailedScore are semicolon separated strings
        TVM_Base
        | join kind=leftouter (DeviceInfoLatest) on DeviceId
        | join kind=leftouter (
            EG_Assets
            | where isnotempty(EG_AadDeviceId)
          ) on $left.DI_AadDeviceId == $right.EG_AadDeviceId
        | where EG_IsExcluded == false
        | extend CriticalityTier = toint(EG_CriticalityTier)
        | where isnotempty(CriticalityTier)
        | extend CriticalityTierLevel =
            case(
              CriticalityTier == 3, "Low - tier 3",
              CriticalityTier == 2, "Medium - tier 2",
              CriticalityTier == 1, "High - tier 1",
              CriticalityTier == 0, "Critical - tier 0",
              "Unknown - unmapped"
            )
        | extend OSPlatformNorm = coalesce(DI_OSPlatform, OSPlatform)
        | extend OSVersionNorm  = coalesce(DI_OSVersion, "")
        | extend MacMajor = toint(extract(@"^(\d+)", 1, OSVersionNorm))
        | extend IsLegacyWindows = iff(OSPlatformNorm in~ (LegacyWindowsOSPlatforms), 1, 0)
        | extend IsLegacyMacOS = iff(tolower(OSPlatformNorm) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
        | extend IsLegacyLinux = iff(
            tolower(OSPlatformNorm) has "linux"
            and (OSPlatformNorm has_any (LegacyLinuxMatchers) or OSVersionNorm has_any (LegacyLinuxMatchers)),
            1, 0
          )
        | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
              array_concat(
                iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
              ),
              ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
              "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
              "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )
        | extend RiskFactor_Consequence = 0
        | extend SecurityDomain = SecurityDomain
        | extend
            AssetName  = coalesce(DI_DeviceName, DeviceName),
            AssetLabel = EG_AssetLabel
        | project
            TimeGenerated,
            SecurityDomain,
            AssetName,
            AssetLabel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            LegacyEndOfSupport,
            DeviceId,
            DeviceName           = coalesce(DI_DeviceName, DeviceName),
            OSPlatform           = OSPlatformNorm,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            ConfigurationId,
            ConfigurationName,
            CriticalityTier,
            CriticalityTierLevel,
            Impact               = ImpactInt,
            SecuritySeverity,
            SecuritySeverityDescription,
            RecommendedAction,
            RiskDescription      = KB_RiskDescription,
            ConfigurationDescription = KB_Description,
            RemediationOptions   = KB_Remediation,
            Benchmarks           = KB_Benchmarks,
            EG_IsCustomerFacing,
            EG_IsExcluded,
            IsApplicable,
            IsCompliant,
            DI_MachineGroup,
            DI_AssetValue,
            DI_ExposureLevel,
            DI_AzureResourceId,
            DI_AadDeviceId,
            EG_AssetName,
            EG_AssetLabel,
            EG_CriticalityRuleBased,
            EG_CriticalityRuleNames,
            AssetTags,
            AssetTierByTag,
            EG_AssetProps
        | order by CriticalityTier asc, Impact desc, AssetName asc, ConfigurationId asc

  - ReportName: Device_Recommendations_Detailed_BucketFilter
    ReportPurpose: Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tags, and add a probability score based on Internet-Exposed (EG CustomerFacing) and LegacyEndOfSupport OS detection
    SecurityDomain: Endpoint
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Show non-compliant TVM secure configuration controls for endpoints, enriched with Exposure Graph criticality and tier tags, and add a probability score based on Internet-Exposed (from EG CustomerFacing) and LegacyEndOfSupport OS detection

        // Step 0  Define configuration IDs removed from the Windows Server scope
        // These controls do not make sense for Windows Server devices (in my opinion!)
        // They are excluded only when OSPlatform indicates Windows Server
        let excludeForWindowsServer = dynamic([
          "scid-2090",
          "scid-22"
        ]);

        // Step 1  Define legacy operating systems that should increase probability
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);

        // Step 2  Lookup tables (short standard texts)
        // If a new Category or Subcategory appears, it is kept but the description is blank
        let CategoryLookup = datatable(Category:string, CategoryDescription:string)
        [
          "Security controls", "Endpoint protection and attack-surface policies that block common malware and attacker techniques.",
          "Network",           "Network security policies that limit attack surface and lateral movement.",
          "BitLocker",         "Full-disk encryption to prevent data exposure on lost or stolen devices.",
          "OS",                "Operating system baseline hardening and core protections.",
          "Credentials",       "Controls that prevent credential theft and reuse.",
          "Browser",           "Safe browsing and web threat protections.",
          "Application",       "Application control and exploit protection to restrict unauthorized code execution.",
          "Device",            "General endpoint configuration and health requirements.",
          "Audit",             "Monitoring-focused baselines to validate configuration posture."
        ];

        let SubCategoryLookup = datatable(Subcategory:string, SubCategoryDescription:string)
        [
          "EDR",                        "Defender for Endpoint sensor presence and reporting health.",
          "Attack Surface Reduction",   "Blocks common malware execution paths from email, web and Office content.",
          "Firewall",                   "Enforces inbound/outbound traffic policy and host firewall state.",
          "Antivirus",                  "Ensures Microsoft Defender Antivirus is active and properly configured.",
          "BitLocker",                  "Enforces full-disk encryption and key escrow.",
          "Exploit Guard",              "Hardens OS/apps against memory corruption and exploit chains.",
          "Authentication",             "Strengthens sign-in security and protects credential boundaries.",
          "Remote Access",              "Restricts remote shell/administrative entry points.",
          "TLS/Communication",          "Requires secure protocols and prevents crypto downgrade.",
          "Removable Storage",          "Controls external media to reduce malware risk and data exfiltration."
        ];

        // Step 3  Parameters
        let lookback         = 30d;
        let onlyApplicable   = true;
        let osFilter         = dynamic([]);
        let categoryFilter   = dynamic([]);
        let idFilter         = dynamic([]);
        let nameSearch       = "";
        let sortByImpactDesc = true;
        let SecurityDomain   = "Endpoint";

        // Step 4  DeviceInfo (latest)
        // OSVersion is optional in some schemas so it is pulled using column_ifexists
        let DeviceInfoLatest =
          DeviceInfo
          | where TimeGenerated >= ago(lookback)
          | summarize arg_max(TimeGenerated, *) by DeviceId
          | project
              DeviceId,
              DI_DeviceName      = DeviceName,
              DI_OSPlatform      = OSPlatform,
              DI_OSVersion       = tostring(column_ifexists("OSVersion", "")),
              DI_MachineGroup    = MachineGroup,
              DI_AssetValue      = tostring(AssetValue),
              DI_ExposureLevel   = tostring(ExposureLevel),
              DI_AzureResourceId = tostring(AzureResourceId),
              DI_AadDeviceId     = tostring(AadDeviceId);

        // Step 5  Exposure Graph endpoint assets joined via aadDeviceId
        // AssetTags combines tags found in multiple rawData locations
        // AssetTierByTag contains tags including --tier and --SI, separated with ;
        // Criticality tier prefers EG criticality level and falls back to tier tags when missing
        let EG_Assets =
          ExposureGraphNodes
          | where tostring(NodeProperties.rawData.deviceCategory) == "Endpoint"
          | extend EG_CriticalityLevel = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
              tostring(NodeProperties.criticalityLevel.criticalityLevel)
            ))
          , EG_CriticalityRuleBased = toint(coalesce(
              tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
              tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
              tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
            ))
          , EG_CriticalityRuleNames = coalesce(
              strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
              strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
            )
          | extend EG_AadDeviceId = tostring(coalesce(
              NodeProperties.rawData.aadDeviceId,
              NodeProperties.raw.aadDeviceId,
              NodeProperties.aadDeviceId
            ))
          | extend EG_IsCustomerFacing = tobool(coalesce(
              NodeProperties.rawData.isCustomerFacing,
              NodeProperties.raw.isCustomerFacing
            ))
          | extend EG_IsExcluded = tobool(coalesce(
              NodeProperties.rawData.isExcluded,
              NodeProperties.raw.isExcluded
            ))
          | extend NoderawData = todynamic(NodeProperties).rawData
          | extend
              deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags)),
              deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags)),
              tags              = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
          | extend _AllTags = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tags)
          | extend AssetTags = strcat_array(_AllTags, ";")
          | extend _TierTags = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)
          | extend AssetTierByTag = strcat_array(array_sort_asc(coalesce(_TierTags, dynamic([]))), ";")
          | extend CriticalityTierFromTag =
              case(
                AssetTierByTag has "--tier0--SI", 0,
                AssetTierByTag has "--tier1--SI", 1,
                AssetTierByTag has "--tier2--SI", 2,
                AssetTierByTag has "--tier3--SI", 3,
                int(null)
              )
          | extend EG_CriticalityTier = toint(coalesce(EG_CriticalityLevel, CriticalityTierFromTag, int(null)))
          | project
              EG_AadDeviceId,
              EG_AssetName    = NodeName,
              EG_AssetLabel   = NodeLabel,
              EG_AssetProps   = NodeProperties,
              EG_CriticalityLevel,
              EG_CriticalityRuleBased,
              EG_CriticalityRuleNames,
              EG_CriticalityTier,
              EG_IsCustomerFacing,
              EG_IsExcluded,
              AssetTags,
              AssetTierByTag;

        // Step 6  TVM secure configuration assessment core dataset
        // Latest row per DeviceId and ConfigurationId
        let TVM_Base =
          DeviceTvmSecureConfigurationAssessment
          | where TimeGenerated >= ago(lookback)
          | where (array_length(osFilter) == 0 or OSPlatform in~ (osFilter))
          | where (array_length(idFilter) == 0 or ConfigurationId in~ (idFilter))
          | where (nameSearch == "" or tostring(DeviceName) contains nameSearch)
          | where not (OSPlatform contains "WindowsServer" and ConfigurationId in~ (excludeForWindowsServer))
          | where iff(onlyApplicable, IsApplicable == 1, true)
          | join kind=leftouter (
              DeviceTvmSecureConfigurationAssessmentKB
              | project
                  ConfigurationId,
                  KB_ConfigurationName        = ConfigurationName,
                  KB_ConfigurationCategory    = ConfigurationCategory,
                  KB_ConfigurationSubcategory = ConfigurationSubcategory,
                  KB_Impact                   = toint(ConfigurationImpact),
                  KB_RiskDescription          = tostring(RiskDescription),
                  KB_Description              = tostring(ConfigurationDescription),
                  KB_Remediation              = tostring(RemediationOptions),
                  KB_Benchmarks               = ConfigurationBenchmarks
            ) on ConfigurationId
          | where (array_length(categoryFilter) == 0 or KB_ConfigurationCategory in~ (categoryFilter))
          | extend ImpactInt = toint(coalesce(KB_Impact, toint(ConfigurationImpact)))
          | extend
              Category          = coalesce(KB_ConfigurationCategory, ConfigurationCategory),
              Subcategory       = KB_ConfigurationSubcategory,
              ConfigurationName = coalesce(KB_ConfigurationName, tostring(ConfigurationId)),
              IsCompliant       = tobool(IsCompliant),
              IsApplicable      = tobool(IsApplicable)
          | extend
              RecommendedAction =
                  case(
                      ImpactInt >= 9, "Fix immediately - Security Change Queue / Intune / GPO rollout",
                      ImpactInt == 8, "Schedule within quarterly hardening cycle",
                      ImpactInt >= 5 and ImpactInt < 8, "Fix opportunistically (during upgrades / refresh)",
                      "Monitor, document as baseline exceptions"
                  ),
              SecuritySeverity =
                  case(
                      ImpactInt == 10, "Very High",
                      ImpactInt == 9,  "High",
                      ImpactInt == 8,  "Medium-High",
                      ImpactInt >= 5,  "Medium",
                      "Low Risk"
                  ),
              SecuritySeverityDescription =
                  case(
                      ImpactInt == 10, "If this configuration is not applied, attackers gain a major foothold or common attack vector remains wide open.",
                      ImpactInt == 9,  "Strongly recommended to fix ASAP; commonly exploited by real-world malware and ransomware.",
                      ImpactInt == 8,  "Important baseline security hardening; reduces attack surface and lateral movement.",
                      ImpactInt >= 5,  "Security best practice; helps reduce exposure but less frequently exploited.",
                      "Hardening / hygiene controls; helps, but attackers less likely to target."
                  ),
              SortKey = iff(sortByImpactDesc, todouble(ImpactInt), 0.0)
          | summarize arg_max(TimeGenerated, *) by DeviceId, ConfigurationId
          | where IsCompliant == false
          | lookup CategoryLookup on Category
          | lookup SubCategoryLookup on Subcategory
          | extend
              CategoryDescription    = iff(isnotempty(CategoryDescription), CategoryDescription, ""),
              SubCategoryDescription = iff(isnotempty(SubCategoryDescription), SubCategoryDescription, "");

        // Step 7  Enrich with DeviceInfo and Exposure Graph, compute tiers and risk factors
        // RiskFactor_Probability increments for Internet-Exposed and LegacyEndOfSupport
        // RiskFactor_Probability_Detailed and RiskFactor_Probability_DetailedScore are semicolon separated strings
        TVM_Base
        | join kind=leftouter (DeviceInfoLatest) on DeviceId
        | join kind=leftouter (
            EG_Assets
            | where isnotempty(EG_AadDeviceId)
          ) on $left.DI_AadDeviceId == $right.EG_AadDeviceId
        | where EG_IsExcluded == false

        // Tier logic uses EG criticality first and falls back to tier tags inside EG_Assets
        | extend CriticalityTier = toint(EG_CriticalityTier)
        | where isnotempty(CriticalityTier)
        | extend CriticalityTierLevel =
            case(
              CriticalityTier == 3, "Low - tier 3",
              CriticalityTier == 2, "Medium - tier 2",
              CriticalityTier == 1, "High - tier 1",
              CriticalityTier == 0, "Critical - tier 0",
              "Unknown - unmapped"
            )

        // LegacyEndOfSupport detection is based on DeviceInfo OSPlatform and OSVersion (when present)
        | extend OSPlatformNorm = coalesce(DI_OSPlatform, OSPlatform)
        | extend OSVersionNorm  = coalesce(DI_OSVersion, "")
        | extend MacMajor = toint(extract(@"^(\d+)", 1, OSVersionNorm))
        | extend IsLegacyWindows = iff(OSPlatformNorm in~ (LegacyWindowsOSPlatforms), 1, 0)
        | extend IsLegacyMacOS = iff(tolower(OSPlatformNorm) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
        | extend IsLegacyLinux = iff(
            tolower(OSPlatformNorm) has "linux"
            and (OSPlatformNorm has_any (LegacyLinuxMatchers) or OSVersionNorm has_any (LegacyLinuxMatchers)),
            1, 0
          )
        | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

        // RiskFactor_Probability model
        // Internet-Exposed is derived from Exposure Graph CustomerFacing
        // LegacyEndOfSupport adds an additional point
        | extend RF_P_InternetExposed = iff(EG_IsCustomerFacing == true, 1, 0)
        | extend RF_P_LegacyEoS = iff(LegacyEndOfSupport == 1, 1, 0)
        | extend RiskFactor_Probability = RF_P_InternetExposed + RF_P_LegacyEoS
        | extend RiskFactor_Probability_Detailed =
            strcat_array(
              array_concat(
                iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
              ),
              ";"
            )
        | extend RiskFactor_Probability_DetailedScore =
            strcat(
              "Internet-Exposed=", tostring(RF_P_InternetExposed), ";",
              "LegacyEndOfSupport=", tostring(RF_P_LegacyEoS)
            )

        // Keep consequence defaulted to 0
        | extend RiskFactor_Consequence = 0

        // Normalize output names and apply bucket filter
        | extend SecurityDomain = SecurityDomain
        | extend
            AssetName  = coalesce(DI_DeviceName, DeviceName),
            AssetLabel = EG_AssetLabel
        | extend DeviceKey = iif(isnotempty(DI_AadDeviceId), DI_AadDeviceId, AssetName)
        __BUCKET_FILTER__

        | project
            TimeGenerated,
            SecurityDomain,
            AssetName,
            AssetLabel,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            LegacyEndOfSupport,
            DeviceId,
            DeviceName           = coalesce(DI_DeviceName, DeviceName),
            OSPlatform           = OSPlatformNorm,
            Category,
            CategoryDescription,
            Subcategory,
            SubCategoryDescription,
            ConfigurationId,
            ConfigurationName,
            CriticalityTier,
            CriticalityTierLevel,
            Impact               = ImpactInt,
            SecuritySeverity,
            SecuritySeverityDescription,
            RecommendedAction,
            RiskDescription      = KB_RiskDescription,
            ConfigurationDescription = KB_Description,
            RemediationOptions   = KB_Remediation,
            Benchmarks           = KB_Benchmarks,
            EG_IsCustomerFacing,
            EG_IsExcluded,
            IsApplicable,
            IsCompliant,
            DI_MachineGroup,
            DI_AssetValue,
            DI_ExposureLevel,
            DI_AzureResourceId,
            DI_AadDeviceId,
            EG_AssetName,
            EG_AssetLabel,
            EG_CriticalityRuleBased,
            EG_CriticalityRuleNames,
            AssetTags,
            AssetTierByTag,
            EG_AssetProps
        | order by CriticalityTier asc, Impact desc, AssetName asc, ConfigurationId asc

       
  - ReportName: Azure_Recommendations_Summary
    ReportPurpose: Summarize Azure exposure graph findings per asset and recommendation with tier fallback from tags and probability scoring from all risk factors
    SecurityDomain: Azure
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
      - "AssetCount"
      - "TotalIssues"
      - "ImpactedAssets"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Summarize Azure exposure graph findings per recommendation and criticality tier
        // Tier uses Defender criticality when present and falls back to AssetTierByTag from Azure tags
        // RiskFactor_Probability equals the count of distinct risk factors on the edge and detailed columns show what was counted

        // Step 1  Build asset list for Azure and capture tier from tags with fallback
        // Scope includes assets where environmentName contains Azure
        // Excluded assets are removed early
        // AssetTierByTag prefers the Azure tag key AssetTier when present
        // If AssetTier is missing, fallback scans tag arrays for strings like --tier0--SI
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.environmentName) contains "Azure"
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
                )
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))

            // Normalize rawData and raw for tag reading
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend NodeRaw     = todynamic(todynamic(NodeProperties).raw)

            // Tag bags  Azure tags are often stored as a bag and AssetTier is a key in that bag
            | extend tagsBag1 = todynamic(coalesce(NoderawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(NodeRaw.tags, dynamic({})))

            // Preferred method  AssetTier tag key lookup
            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier,
                tagsBag2.AssetTier,
                tagsBag3.AssetTier,
                tagsBag1["AssetTier"],
                tagsBag2["AssetTier"],
                tagsBag3["AssetTier"]
            ))

            // Fallback method  gather tag arrays and scan for tier markers
            | extend deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")

            // Regex fallback must include a capturing group
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            // Final AssetTierByTag value
            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                AssetTags,
                AssetTierByTag;


        // Step 2  Build finding list
        // Only nodes with a category containing finding are included
        // CVE nodes are excluded from this Azure finding view
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | where NodeLabel !contains "cve"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list
        // Only edges with labels containing affecting are used
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        let AF_edges =
            union
            (
                Edges
                | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            ),
            (
                Edges
                | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            );

        AF_edges
        // Step 5  De-duplicate and merge edge properties
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAny         = any(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            AssetTierByTag       = any(AssetTierByTag),
            AssetTags            = any(AssetTags)
          by AssetNodeId, AssetName, AssetLabel, FindingName
        | where EG_IsExcluded == false


        // Step 6  Build a unified Properties bag for simple lookups
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAny)
            )
        | extend SubCategory = tostring(Properties.raw.securityIssue.securityIssue)


        // Step 7  Risk extraction from graph edge
        | extend RiskLevel = tostring(Properties.edge.rawData.risk.riskLevel)
        | extend RiskFactorsArray = todynamic(Properties.edge.rawData.risk.riskFactors)
        | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)


        // Step 8  Normalize and score risk factors
        // RiskFactor_Probability increments by +1 for each distinct risk factor found
        // Detailed outputs are semicolon strings with stable sorting
        | mv-apply rf = RiskFactorsArray on (
            where isnotempty(trim(" ", tostring(rf)))
            | summarize RiskFactorSet = make_set(tostring(rf))
        )
        | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
        | extend RiskFactor_Probability = array_length(RiskFactorSet)
        | extend RiskFactor_Consequence = 0
        | extend RiskFactor_Probability_Detailed =
            strcat_array(array_sort_asc(RiskFactorSet), ";")
        | mv-apply rf = RiskFactorSet on (
            summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
        )
        | extend RiskFactor_Probability_DetailedScore =
            strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")


        // Step 9  Criticality tier mapping with fallback to AssetTierByTag
        // Prefer Defender CriticalityLevel first
        // If missing, map tier from AssetTierByTag
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - tier"
            )


        // Step 10  Severity and impact normalization
        | extend Severity = tostring(Properties.raw.severity)
        | extend Impact =
            case(
                tolower(Severity) == "low",                   3,
                tolower(Severity) == "medium",                7,
                tolower(Severity) in ("high","critical"),    10,
                999
            )


        // Step 11  Set fields expected by the risk engine
        | extend SecurityDomain    = "Azure"
        | extend ConfigurationId   = "Azure"
        | extend Category          = tostring(FindingLabel)
        | extend ConfigurationName = tostring(FindingName)
        | extend SecuritySeverity  = Severity
        | where isnotempty(SecuritySeverity)


        // Step 12  Summarize at recommendation level
        | summarize
            AssetCount             = dcount(AssetNodeId),
            TotalIssues            = count(),
            AvgImpact              = avg(Impact),
            MaxImpact              = max(Impact),
            ImpactedAssets         = make_set(AssetName),
            SampleFindings         = make_set(FindingName),

            // Keep a representative tag value for the group
            AssetTierByTag         = any(AssetTierByTag),

            RiskFactor_Consequence = max(RiskFactor_Consequence),
            RiskFactor_Probability = max(RiskFactor_Probability),
            RiskFactor_Probability_Detailed      = any(RiskFactor_Probability_Detailed),
            RiskFactor_Probability_DetailedScore = any(RiskFactor_Probability_DetailedScore)
          by SecurityDomain, Category, SubCategory, ConfigurationName, ConfigurationId, CriticalityTier, CriticalityTierLevel, SecuritySeverity


        // Step 13  Final shape and sorting
        | project
            SecurityDomain,
            Category,
            Subcategory = SubCategory,
            ConfigurationName,
            ConfigurationId,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity,
            AssetTierByTag,
            RiskFactor_Consequence,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            AssetCount,
            TotalIssues,
            AvgImpact = round(AvgImpact, 1),
            MaxImpact = toint(ceiling(MaxImpact)),
            ImpactedAssets,
            SampleFindings
        | order by CriticalityTier asc, MaxImpact desc, AvgImpact desc, AssetCount desc, TotalIssues desc

  - ReportName: Azure_Recommendations_Detailed
    ReportPurpose: Summarize Azure exposure graph findings per asset and recommendation with tier fallback from tags and probability scoring from all risk factors
    SecurityDomain: Azure
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskFactor_Probability_Detailed"
      - "RiskFactor_Probability_DetailedScore"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Identify and prioritize Azure security findings from Exposure Graph by asset criticality and finding severity
        // Enrich each row with tier tags and risk factor scoring where RiskFactor_Probability equals the count of distinct risk factors on the edge

        // Step 1  Build Azure asset list with criticality, scoping flags, and tier tags
        // Scope includes only assets where rawData environmentName contains Azure
        // Criticality is read from multiple possible criticality fields for robustness
        // Customer facing and excluded flags are normalized from rawData or raw
        // AssetTierByTag prefers the Azure tag key AssetTier when present
        // If AssetTier is missing, fallback scans tag arrays for strings like --tier0--SI
        let Assets =
            ExposureGraphNodes
            | where tostring(NodeProperties.rawData.environmentName) contains "Azure"
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", ")
                )
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties.rawData.isCustomerFacing,
                NodeProperties.raw.isCustomerFacing
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties.raw.isExcluded
              ))

            // Normalize rawData and raw for tag reading
            | extend NoderawData = todynamic(NodeProperties).rawData
            | extend NodeRaw     = todynamic(todynamic(NodeProperties).raw)

            // Tag bags  Azure tags often stored as a bag and AssetTier is a key
            | extend tagsBag1 = todynamic(coalesce(NoderawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(NodeRaw.tags, dynamic({})))

            // Preferred method  AssetTier tag key lookup
            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier,
                tagsBag2.AssetTier,
                tagsBag3.AssetTier,
                tagsBag1["AssetTier"],
                tagsBag2["AssetTier"],
                tagsBag3["AssetTier"]
            ))

            // Fallback method  gather tag arrays and scan for tier markers
            | extend deviceManualTags  = iff(isnull(NoderawData.deviceManualTags),  dynamic([]), todynamic(NoderawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(NoderawData.deviceDynamicTags), dynamic([]), todynamic(NoderawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(NoderawData.tags.tags),         dynamic([]), todynamic(NoderawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")

            // Regex fallback must include a capturing group
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            // Final AssetTierByTag value
            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                AssetTierByTag,
                AssetTags;


        // Step 2  Build finding list and scope to non-CVE finding nodes
        let Findings =
            ExposureGraphNodes
            | mv-expand Category = Categories
            | where tostring(Category) contains "finding"
            | where NodeLabel !contains "cve"
            | project
                FindingNodeId     = NodeId,
                FindingName       = NodeName,
                FindingLabel      = NodeLabel,
                FindingCategories = Categories,
                FindingProps      = NodeProperties;


        // Step 3  Build edge list used to connect assets to findings
        let Edges =
            ExposureGraphEdges
            | where tostring(EdgeLabel) contains "affecting"
            | extend EdgeProps = column_ifexists("EdgeProperties", dynamic({}))
            | project SourceNodeId, TargetNodeId, EdgeLabel, EdgeProps;


        // Step 4  Relate assets and findings using edges in both directions
        let AF_edges =
            union
            (
                Edges
                | join kind=inner (Assets)   on $left.SourceNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.TargetNodeId == $right.FindingNodeId
            ),
            (
                Edges
                | join kind=inner (Assets)   on $left.TargetNodeId == $right.AssetNodeId
                | join kind=inner (Findings) on $left.SourceNodeId == $right.FindingNodeId
            );

        AF_edges
        // Step 5  De-duplicate and keep one row per AssetName AssetLabel FindingName
        | summarize
            EdgeLabels           = make_set(EdgeLabel),
            EdgePropsAny         = any(EdgeProps),
            FindingLabel         = any(FindingLabel),
            FindingCategories    = any(FindingCategories),
            FindingProps         = any(FindingProps),
            AssetProps           = any(AssetProps),
            CriticalityLevel     = any(CriticalityLevel),
            CriticalityRuleBased = any(CriticalityRuleBased),
            CriticalityRuleNames = any(CriticalityRuleNames),
            EG_IsCustomerFacing  = any(EG_IsCustomerFacing),
            EG_IsExcluded        = any(EG_IsExcluded),
            AssetTierByTag       = any(AssetTierByTag),
            AssetTags            = any(AssetTags)
          by AssetName, AssetLabel, FindingName
        | where EG_IsExcluded == false


        // Step 6  Build unified Properties bag for easier extraction
        | extend Properties =
            bag_merge(
                bag_pack("finding", FindingProps),
                bag_pack("raw", iif(isnull(FindingProps.rawData), dynamic({}), FindingProps.rawData)),
                bag_pack("edge", EdgePropsAny)
            )


        // Step 7  Extract the subcategory used for reporting
        | extend Subcategory = tostring(Properties.raw.securityIssue.securityIssue)


        // Step 8  Extract risk model fields from the edge rawData
        | extend RawCriticality = tostring(Properties.edge.rawData.risk.riskLevel)
        | extend RiskFactorsArray = todynamic(Properties.edge.rawData.risk.riskFactors)
        | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)


        // Step 9  Score risk factors
        | mv-apply rf = RiskFactorsArray on (
            where isnotempty(tostring(rf))
            | summarize RiskFactorSet = make_set(tostring(rf))
        )
        | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
        | extend RiskFactor_Probability = array_length(RiskFactorSet)
        | extend RiskFactor_Consequence = 0
        | extend RiskFactor_Probability_Detailed =
            strcat_array(array_sort_asc(RiskFactorSet), ";")
        | mv-apply rf = RiskFactorSet on (
            summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
        )
        | extend RiskFactor_Probability_DetailedScore =
            strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")


        // Step 10  Normalize severity to an impact score
        | extend Severity = tostring(Properties.raw.severity)
        | extend Impact =
            case(
                tolower(Severity) == "low",                   3,
                tolower(Severity) == "medium",                7,
                tolower(Severity) in ("high","critical"),    10,
                999
            )


        // Step 11  Compute criticality tier
        // Prefer Defender criticality level first
        // If Defender criticality is missing, fallback to tag-based tier detection
        // If both are missing, default tier is 3
        | extend CriticalityTierFromTag =
            case(
                AssetTierByTag has "--tier0--SI" or AssetTierByTag has "tier0", 0,
                AssetTierByTag has "--tier1--SI" or AssetTierByTag has "tier1", 1,
                AssetTierByTag has "--tier2--SI" or AssetTierByTag has "tier2", 2,
                AssetTierByTag has "--tier3--SI" or AssetTierByTag has "tier3", 3,
                int(null)
            )
        | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                CriticalityTier == 3, "Low - tier 3",
                "Unknown - tier"
            )


        // Step 12  Stamp fixed identifiers and apply final scoping filters
        | extend SecurityDomain = "Azure"
        | extend ConfigurationId = "Azure"
        | where isnotempty(Severity)


        // Step 13  Final projection and ordering
        | project
            SecurityDomain,
            AssetName,
            AssetLabel,
            Category              = tostring(FindingLabel),
            Subcategory,
            ConfigurationName     = tostring(FindingName),
            ConfigurationId,
            CriticalityLevel,
            CriticalityRuleBased,
            CriticalityRuleNames,
            AssetTierByTag,
            AssetTags,
            CriticalityTier,
            CriticalityTierLevel,
            SecuritySeverity      = Severity,
            Impact,
            RawCriticality,
            RiskFactors           = RiskFactorsArray,
            RiskFactor_Probability,
            RiskFactor_Probability_Detailed,
            RiskFactor_Probability_DetailedScore,
            RiskFactor_Consequence,
            Properties
        | order by CriticalityTier asc, Impact desc, AssetName asc

  - ReportName: Attack_Paths_Summary_Credential_Based_Lateral_Movement
    ReportPurpose: Identify credential driven attack paths in Exposure Graph and prioritize them by the business impact of the final target.
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Identify credential driven attack paths in Exposure Graph and prioritize them by the business impact of the final target.
        //
        // Important interpretation guard
        // This query prioritizes based on TARGET criticality tier first, then tier escalation, then internet exposure.
        // A tier 2 workstation used as a source does NOT outrank a tier 0 target resource.
        // The source still matters as an amplifier, but the target drives the priority.


        // Step 0  Define legacy operating systems that should increase probability (same as CVE report)
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        // Includes
        // - Defender criticality tier preferred with tag fallback
        // - AssetTierByTag prefers Azure tag bag key AssetTier fallback scans tag arrays for --tierX--SI
        // - LegacyEndOfSupport derived from rawData OS fields when present
        // - RiskFactor scoring count distinct node risk factors plus Internet-Exposed plus LegacyEoS
        // Naming
        // - CustomerFacing terminology is replaced by Internet-Exposed IsInternetExposed
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            // Criticality extraction from multiple possible fields
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            // Internet exposure flag derived from graph property isCustomerFacing renamed
            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            // Exclusion flag
            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            // Normalize rawData and raw for tag and OS reading
            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            // AssetTierByTag preferred bag key AssetTier fallback tag array scan
            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier"], tagsBag2["AssetTier"], tagsBag3["AssetTier"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            // Tag fallback mapping only used when Defender criticality is missing
            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            // Prefer Defender criticality over tag
            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            // LegacyEndOfSupport detection same as CVE report
            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            // Risk factors on nodes count distinct plus Internet-Exposed plus LegacyEoS
            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Find credentials that exist on devices or systems
        let CredentialsOnDevices =
            ExposureGraphEdges
            | where EdgeLabel in ("contains", "defined in", "runs on", "has credentials of")
            | where SourceNodeLabel in (
                "device",
                "computer-account",
                "microsoft.compute/virtualmachines",
                "microsoft.web/sites_webapp",
                "microsoft.storage/storageaccounts",
                "user",
                "serviceprincipal"
            )
            | where TargetNodeLabel in (
                "azure-active-directory-app-secret",
                "user-azure-cli-secret",
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-user-credentials",
                "service-principal-azure-cli-secret",
                "entra-userCookie"
            )
            | project
                SourceDeviceId    = SourceNodeId,
                SourceDeviceName  = SourceNodeName,
                SourceDeviceLabel = SourceNodeLabel,
                CredentialNodeId  = TargetNodeId,
                CredentialName    = TargetNodeName,
                CredentialLabel   = TargetNodeLabel
            | summarize
                SourceDevices          = make_set(SourceDeviceName),
                SourceDeviceTypes      = make_set(SourceDeviceLabel),
                SourceDeviceCount      = dcount(SourceDeviceId),
                FirstSourceDeviceId    = any(SourceDeviceId),
                FirstSourceDeviceName  = any(SourceDeviceName),
                FirstSourceDeviceLabel = any(SourceDeviceLabel)
              by CredentialNodeId, CredentialName, CredentialLabel;


        // Step 3  Hop 1 credential can authenticate as identity
        let Hop1 =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                Hop1_SourceCredentialId = SourceNodeId,
                Hop1_EdgeLabel          = EdgeLabel,
                IntermediateIdentityId  = TargetNodeId,
                IntermediateIdentity    = TargetNodeName,
                IntermediateIdentityLabel = TargetNodeLabel;


        // Step 4  Hop 2 identity can reach target resources
        let Hop2 =
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "runs on", "has permissions to", "has role on")
            | where TargetNodeLabel in (
                "microsoft.compute/virtualmachines",
                "microsoft.compute/virtualmachines/extensions",
                "device",
                "computer-account",
                "microsoft.web/sites_webapp",
                "microsoft.sql/servers",
                "microsoft.storage/storageaccounts",
                "microsoft.keyvault/vaults",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts_openai",
                "microsoft.operationalinsights/workspaces",
                "subscriptions",
                "resourcegroups"
            )
            | project
                Hop2_SourceIdentityId = SourceNodeId,
                Hop2_EdgeLabel        = EdgeLabel,
                FinalTargetId         = TargetNodeId,
                FinalTargetName       = TargetNodeName,
                FinalTargetLabel      = TargetNodeLabel;


        // Step 5  Assemble 2 hop attack paths and de-duplicate
        let Paths =
            CredentialsOnDevices
            | join kind=inner (Hop1) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId
            | join kind=inner (Hop2) on $left.IntermediateIdentityId == $right.Hop2_SourceIdentityId
            | where FirstSourceDeviceId != FinalTargetId
            | summarize
                SourceDevices              = any(SourceDevices),
                SourceDeviceTypes          = any(SourceDeviceTypes),
                SourceDeviceCount          = any(SourceDeviceCount),
                FirstSourceDeviceId        = any(FirstSourceDeviceId),
                FirstSourceDeviceName      = any(FirstSourceDeviceName),
                FirstSourceDeviceLabel     = any(FirstSourceDeviceLabel),
                CredentialName             = any(CredentialName),
                CredentialLabel            = any(CredentialLabel),
                IntermediateIdentityId     = any(IntermediateIdentityId),
                IntermediateIdentity       = any(IntermediateIdentity),
                IntermediateIdentityLabel  = any(IntermediateIdentityLabel),
                Hop1Edge                   = any(Hop1_EdgeLabel),
                Hop2Edge                   = any(Hop2_EdgeLabel),
                FinalTargetName            = any(FinalTargetName),
                FinalTargetLabel           = any(FinalTargetLabel)
              by CredentialNodeId, FinalTargetId;


        // Step 6  Enrich paths with node metadata and keep NodeProperties
        Paths
        | join kind=leftouter (
            Nodes
            | project-rename
                SourceNodeId                     = NodeId,
                SourceNodeName                   = NodeName,
                SourceNodeLabel                  = NodeLabel,
                SourceCriticalityTier            = CriticalityTier,
                SourceCriticalityTierLevel       = CriticalityTierLevel,
                SourceIsInternetExposed          = IsInternetExposed,
                SourceIsExcluded                 = IsExcluded,
                SourceAssetTierByTag             = AssetTierByTag,
                SourceLegacyEndOfSupport         = LegacyEndOfSupport,
                SourceRiskProb                   = RiskFactor_Probability,
                SourceRiskProbDetailed           = RiskFactor_Probability_Detailed,
                SourceRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                SourceNodeProperties             = NodeProperties
        ) on $left.FirstSourceDeviceId == $right.SourceNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                IntermediateNodeId               = NodeId,
                IntermediateNodeName             = NodeName,
                IntermediateNodeLabel            = NodeLabel,
                IntermediateCriticalityTier      = CriticalityTier,
                IntermediateCriticalityTierLevel = CriticalityTierLevel,
                IntermediateIsInternetExposed    = IsInternetExposed,
                IntermediateIsExcluded           = IsExcluded,
                IntermediateAssetTierByTag       = AssetTierByTag,
                IntermediateLegacyEndOfSupport   = LegacyEndOfSupport,
                IntermediateRiskProb             = RiskFactor_Probability,
                IntermediateRiskProbDetailed     = RiskFactor_Probability_Detailed,
                IntermediateRiskProbDetailedScore= RiskFactor_Probability_DetailedScore,
                IntermediateNodeProperties       = NodeProperties
        ) on $left.IntermediateIdentityId == $right.IntermediateNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                     = NodeId,
                TargetNodeName                   = NodeName,
                TargetNodeLabel                  = NodeLabel,
                TargetCriticalityTier            = CriticalityTier,
                TargetCriticalityTierLevel       = CriticalityTierLevel,
                TargetIsInternetExposed          = IsInternetExposed,
                TargetIsExcluded                 = IsExcluded,
                TargetAssetTierByTag             = AssetTierByTag,
                TargetLegacyEndOfSupport         = LegacyEndOfSupport,
                TargetRiskProb                   = RiskFactor_Probability,
                TargetRiskProbDetailed           = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                TargetNodeProperties             = NodeProperties
        ) on $left.FinalTargetId == $right.TargetNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                CredentialNodeId_join        = NodeId,
                CredentialNodeName_join      = NodeName,
                CredentialNodeLabel_join     = NodeLabel,
                CredentialNodeProperties     = NodeProperties
        ) on $left.CredentialNodeId == $right.CredentialNodeId_join


        // Step 7  Attack path prioritization logic
        | extend TierEscalation =
            case(
                isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                    SourceCriticalityTier - TargetCriticalityTier,
                0
            )
        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )
        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
        | extend SourceTierAmplifier =
            case(
                SourceCriticalityTier == 0, 8,
                SourceCriticalityTier == 1, 5,
                SourceCriticalityTier == 2, 2,
                0
            )
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )


        // Step 8  Human readable paths and Internet-Exposed wording
        | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
        | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

        | extend AttackPath =
            strcat(
                FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] -> ",
                CredentialLabel, " [", CredentialName, "] -> ",
                IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                FinalTargetLabel, " [", FinalTargetName, "]"
            )
        | extend AttackPathDetailed =
            strcat(
                "SOURCE ", FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] ",
                "tier ", tostring(SourceCriticalityTier), " ", tostring(SourceCriticalityTierLevel), " ",
                " | ", InternetExposureSource,
                " -> CREDENTIAL ", CredentialLabel, " [", CredentialName, "] ",
                " -> IDENTITY ", IntermediateIdentityLabel, " [", IntermediateIdentity, "] ",
                " -> TARGET ", FinalTargetLabel, " [", FinalTargetName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " ",
                " | ", InternetExposureTarget,
                " | escalation ", tostring(TierEscalation),
                " | ", LateralMovementType
            )

        | project
            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,

            FirstSourceDeviceId,
            FirstSourceDeviceName,
            FirstSourceDeviceLabel,
            IntermediateIdentityId,
            IntermediateIdentity,
            IntermediateIdentityLabel,
            CredentialNodeId,
            CredentialName,
            CredentialLabel,
            FinalTargetId,
            FinalTargetName,
            FinalTargetLabel,

            TargetCriticalityTier,
            TargetCriticalityTierLevel,
            TargetAssetTierByTag,
            TargetIsInternetExposed,
            TargetLegacyEndOfSupport,
            TargetRiskProb,
            TargetRiskProbDetailed,
            TargetRiskProbDetailedScore,

            SourceCriticalityTier,
            SourceCriticalityTierLevel,
            SourceAssetTierByTag,
            SourceIsInternetExposed,
            SourceLegacyEndOfSupport,
            SourceRiskProb,
            SourceRiskProbDetailed,
            SourceRiskProbDetailedScore,

            IntermediateCriticalityTier,
            IntermediateCriticalityTierLevel,
            IntermediateIsInternetExposed,
            IntermediateLegacyEndOfSupport,
            IntermediateRiskProb,
            IntermediateRiskProbDetailed,
            IntermediateRiskProbDetailedScore,

            SourceDeviceCount,
            SourceDevices,
            SourceDeviceTypes,
            Hop1Edge,
            Hop2Edge,

            AttackPath,
            AttackPathDetailed,

            SourceNodeProperties,
            IntermediateNodeProperties,
            TargetNodeProperties,
            CredentialNodeProperties
        | order by AttackPathPriorityScore desc, TierEscalation desc, TargetCriticalityTier asc, FinalTargetName asc
                // ===================== COLLAPSED SUMMARY VERSION =====================
                // Report purpose
                // Collapsed attack-path prioritization view where duplicates caused by many different credentials
                // on the same path are merged into one summarized record.
                //
                // Output contract (columns)
                // SecurityDomain             Azure or Endpoint depending on target asset type
                // Category                   Attack Paths
                // SubCategory                LateralMovement
                // ConfigurationName          LateralMovementType
                // ConfigurationId            CredentialLabel (summarized to ; list if multiple)
                // SecuritySeverity           AttackPathPriority
                // CriticalityTier            TargetCriticalityTier
                // CriticalityTierLevel       TargetCriticalityTierLevel
                // RiskFactor_Consequence     0
                // RiskFactor_Probability     TargetRiskProb
                // AssetCount                 distinct final targets (within the group)
                // TotalIssues                total underlying rows collapsed into the group
                // ImpactedAssets             ; list of distinct source assets

                // Step A  Build a stable key for same attack path ignoring credential IDs
                // If you want to collapse across different intermediate identities too, remove IntermediateIdentityId from PathKey.
                | extend PathKey = strcat(FirstSourceDeviceId, "->", IntermediateIdentityId, "->", FinalTargetId)

                // Step B  Determine domain based on final target asset label
                | extend SecurityDomain =
                    case(
                        FinalTargetLabel in ("device","computer-account","microsoft.compute/virtualmachines"), "Endpoint",
                        "Azure"
                    )

                // Step C  Stamp report taxonomy required by your risk engine
                | extend
                    Category    = "Attack Paths",
                    SubCategory = "LateralMovement",
                    ConfigurationName = tostring(LateralMovementType),
                    SecuritySeverity  = tostring(AttackPathPriority),
                    RiskFactor_Consequence = 0

                // Step D  Collapse - merge duplicate rows (same logical path) then roll up to your requested report grain
                // First collapse to unique path (PathKey) so credential spam doesnt multiply counts.
                | summarize
                    // choose worst/highest priority per path
                    AttackPathPriorityScore_Path = max(AttackPathPriorityScore),
                    AttackPathPriority_Path      = any(AttackPathPriority),

                    // keep the target attributes for the path
                    TargetCriticalityTier_Path      = any(TargetCriticalityTier),
                    TargetCriticalityTierLevel_Path = any(TargetCriticalityTierLevel),
                    TargetRiskProb_Path             = max(TargetRiskProb),

                    // credentials - keep distinct labels as set (later turned into ;)
                    CredentialLabels_Path = make_set(tostring(CredentialLabel)),

                    // impacted sources - keep distinct source names as set (later turned into ;)
                    SourceAssets_Path = make_set(tostring(FirstSourceDeviceName)),

                    // bookkeeping
                    TotalIssues_Path = count()
                  by
                    PathKey,
                    SecurityDomain,
                    Category,
                    SubCategory,
                    ConfigurationName,
                    FinalTargetId

                // Step E  Now summarize to final output grain (your required columns)
                | summarize
                    // ConfigurationId requested as CredentialLabel
                    // If multiple credential types exist in the group, output them as a ; string
                    ConfigurationId = strcat_array(array_sort_asc(make_set(strcat_array(CredentialLabels_Path, ";"))), ";"),

                    // keep severity and target tier info (worst-case ordering where it makes sense)
                    SecuritySeverity = any(AttackPathPriority_Path),
                    CriticalityTier = toint(any(TargetCriticalityTier_Path)),
                    CriticalityTierLevel = tostring(any(TargetCriticalityTierLevel_Path)),

                    RiskFactor_Consequence = 0,
                    RiskFactor_Probability = max(TargetRiskProb_Path),

                    // summary metrics
                    AssetCount   = dcount(FinalTargetId),
                    TotalIssues  = sum(TotalIssues_Path),

                    // impacted assets = all distinct sources across the collapsed paths
                    ImpactedAssets = strcat_array(array_sort_asc(make_set(strcat_array(SourceAssets_Path, ";"))), ";")
                  by
                    SecurityDomain,
                    Category,
                    SubCategory,
                    ConfigurationName

                // Step F  Final projection in the exact order you asked for
                | project
                    SecurityDomain,
                    Category,
                    SubCategory,
                    ConfigurationName,
                    ConfigurationId,
                    SecuritySeverity,
                    CriticalityTier,
                    CriticalityTierLevel,
                    RiskFactor_Consequence,
                    RiskFactor_Probability,
                    AssetCount,
                    TotalIssues,
                    ImpactedAssets

                // Step G  Sorting prioritize highest severity/priority, then most critical targets, then volume
                | order by
                    RiskFactor_Probability desc,
                    CriticalityTier asc,
                    TotalIssues desc,
                    AssetCount desc

  - ReportName: Attack_Paths_Detailed_Credential_Based_Lateral_Movement
    ReportPurpose: Identify credential driven attack paths in Exposure Graph and prioritize them by the business impact of the final target.
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        // Report purpose
        // Identify credential driven attack paths in Exposure Graph and prioritize them by the business impact of the final target.
        //
        // Important interpretation guard
        // This query prioritizes based on TARGET criticality tier first, then tier escalation, then internet exposure.
        // A tier 2 workstation used as a source does NOT outrank a tier 0 target resource.
        // The source still matters as an amplifier, but the target drives the priority.


        // Step 0  Define legacy operating systems that should increase probability (same as CVE report)
        let LegacyWindowsOSPlatforms = dynamic([
          "WindowsServer2008",
          "WindowsServer2008R2",
          "WindowsServer2012",
          "WindowsServer2012R2",
          "Windows7",
          "Windows8",
          "Windows8.1"
        ]);

        let LegacyMacOSMajorVersions = dynamic([10, 11, 12]);

        let LegacyLinuxMatchers = dynamic([
          "CentOS 7",
          "Ubuntu 18.04",
          "Debian 10",
          "RHEL 7",
          "SLES 12"
        ]);


        // Step 1  Build node catalog used to enrich attack paths
        // Includes
        // - Defender criticality tier preferred with tag fallback
        // - AssetTierByTag prefers Azure tag bag key AssetTier fallback scans tag arrays for --tierX--SI
        // - LegacyEndOfSupport derived from rawData OS fields when present
        // - RiskFactor scoring count distinct node risk factors plus Internet-Exposed plus LegacyEoS
        // Naming
        // - CustomerFacing terminology is replaced by Internet-Exposed IsInternetExposed
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories))
            | extend NodeNameNorm  = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))

            // Criticality extraction from multiple possible fields
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel)
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel)
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )

            // Internet exposure flag derived from graph property isCustomerFacing renamed
            | extend IsInternetExposed =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))

            // Exclusion flag
            | extend IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))

            // Normalize rawData and raw for tag and OS reading
            | extend RawData = todynamic(NodeProperties).rawData
            | extend Raw     = todynamic(todynamic(NodeProperties).raw)

            // AssetTierByTag preferred bag key AssetTier fallback tag array scan
            | extend tagsBag1 = todynamic(coalesce(RawData.tags, dynamic({})))
            | extend tagsBag2 = todynamic(coalesce(todynamic(NodeProperties).tags, dynamic({})))
            | extend tagsBag3 = todynamic(coalesce(Raw.tags, dynamic({})))

            | extend AssetTierFromBag = tostring(coalesce(
                tagsBag1.AssetTier, tagsBag2.AssetTier, tagsBag3.AssetTier,
                tagsBag1["AssetTier"], tagsBag2["AssetTier"], tagsBag3["AssetTier"]
            ))

            | extend deviceManualTags  = iff(isnull(RawData.deviceManualTags),  dynamic([]), todynamic(RawData.deviceManualTags))
            | extend deviceDynamicTags = iff(isnull(RawData.deviceDynamicTags), dynamic([]), todynamic(RawData.deviceDynamicTags))
            | extend tagsArray1        = iff(isnull(RawData.tags.tags),         dynamic([]), todynamic(RawData.tags.tags))
            | extend _AllTags          = array_concat(array_concat(deviceManualTags, deviceDynamicTags), tagsArray1)
            | extend AssetTags         = strcat_array(_AllTags, ";")
            | extend _TierTagsFromText = extract_all(@"([^;]*--tier[0-3]--SI[^;]*)", AssetTags)

            | extend AssetTierByTag =
                case(
                    isnotempty(AssetTierFromBag), AssetTierFromBag,
                    array_length(_TierTagsFromText) > 0, strcat_array(array_sort_asc(_TierTagsFromText), ";"),
                    ""
                )

            // Tag fallback mapping only used when Defender criticality is missing
            | extend CriticalityTierFromTag =
                case(
                    AssetTierByTag has "--tier0--SI" or tolower(AssetTierByTag) has "tier0" or AssetTierByTag == "0", 0,
                    AssetTierByTag has "--tier1--SI" or tolower(AssetTierByTag) has "tier1" or AssetTierByTag == "1", 1,
                    AssetTierByTag has "--tier2--SI" or tolower(AssetTierByTag) has "tier2" or AssetTierByTag == "2", 2,
                    AssetTierByTag has "--tier3--SI" or tolower(AssetTierByTag) has "tier3" or AssetTierByTag == "3", 3,
                    int(null)
                )

            // Prefer Defender criticality over tag
            | extend CriticalityTier = toint(coalesce(CriticalityLevel, CriticalityTierFromTag, 3))
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )

            // LegacyEndOfSupport detection same as CVE report
            | extend AssetOSPlatform =
                tostring(coalesce(RawData.osPlatform, RawData.OSPlatform, RawData.platform, RawData.operatingSystem, RawData.os))
            | extend AssetOSVersion =
                tostring(coalesce(RawData.osVersion, RawData.OSVersion, RawData.version, RawData.operatingSystemVersion))
            | extend AssetOSDistribution =
                tostring(coalesce(RawData.osDistribution, RawData.OSDistribution, RawData.distribution))
            | extend MacMajor = toint(extract(@"^(\d+)", 1, AssetOSVersion))

            | extend IsLegacyWindows = iff(AssetOSPlatform in~ (LegacyWindowsOSPlatforms), 1, 0)
            | extend IsLegacyMacOS   = iff(tolower(AssetOSPlatform) has "mac" and MacMajor in~ (LegacyMacOSMajorVersions), 1, 0)
            | extend IsLegacyLinux   = iff(
                    tolower(AssetOSPlatform) has "linux"
                    and (AssetOSDistribution has_any (LegacyLinuxMatchers) or AssetOSVersion has_any (LegacyLinuxMatchers)),
                    1, 0
                )
            | extend LegacyEndOfSupport = iff(IsLegacyWindows == 1 or IsLegacyMacOS == 1 or IsLegacyLinux == 1, 1, 0)

            // Risk factors on nodes count distinct plus Internet-Exposed plus LegacyEoS
            | extend RiskFactorsArray =
                todynamic(coalesce(
                    NodeProperties.rawData.risk.riskFactors,
                    NodeProperties.risk.riskFactors,
                    dynamic([])
                ))
            | extend RiskFactorsArray = iff(isnull(RiskFactorsArray), dynamic([]), RiskFactorsArray)

            | mv-apply rf = RiskFactorsArray on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize RiskFactorSet = make_set(tostring(rf))
            )
            | extend RiskFactorSet = coalesce(RiskFactorSet, dynamic([]))
            | extend RF_P_RiskFactorsCount = array_length(RiskFactorSet)
            | extend RF_P_InternetExposed  = iff(IsInternetExposed == true, 1, 0)
            | extend RF_P_LegacyEoS        = iff(LegacyEndOfSupport == 1, 1, 0)

            | extend RiskFactor_Probability = RF_P_RiskFactorsCount + RF_P_InternetExposed + RF_P_LegacyEoS
            | extend RiskFactor_Consequence = 0

            | extend RiskFactor_Probability_Detailed =
                strcat_array(
                    array_sort_asc(
                        array_concat(
                            RiskFactorSet,
                            iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                            iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                        )
                    ),
                    ";"
                )

            | mv-apply rf = array_concat(
                    RiskFactorSet,
                    iff(RF_P_InternetExposed == 1, dynamic(["Internet-Exposed"]), dynamic([])),
                    iff(RF_P_LegacyEoS == 1, dynamic(["LegacyEndOfSupport"]), dynamic([]))
                ) on (
                where isnotempty(trim(" ", tostring(rf)))
                | summarize ScoreParts = make_set(strcat(tostring(rf), "=1"))
            )
            | extend RiskFactor_Probability_DetailedScore =
                strcat_array(array_sort_asc(coalesce(ScoreParts, dynamic([]))), ";")

            | project
                NodeId,
                NodeName          = NodeNameNorm,
                NodeLabel,
                Categories        = CategoriesStr,
                NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                IsInternetExposed,
                IsExcluded,
                AssetTags,
                AssetTierByTag,
                LegacyEndOfSupport,
                RiskFactorsArray,
                RiskFactor_Probability,
                RiskFactor_Probability_Detailed,
                RiskFactor_Probability_DetailedScore,
                RiskFactor_Consequence;


        // Step 2  Find credentials that exist on devices or systems
        let CredentialsOnDevices =
            ExposureGraphEdges
            | where EdgeLabel in ("contains", "defined in", "runs on", "has credentials of")
            | where SourceNodeLabel in (
                "device",
                "computer-account",
                "microsoft.compute/virtualmachines",
                "microsoft.web/sites_webapp",
                "microsoft.storage/storageaccounts",
                "user",
                "serviceprincipal"
            )
            | where TargetNodeLabel in (
                "azure-active-directory-app-secret",
                "user-azure-cli-secret",
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-user-credentials",
                "service-principal-azure-cli-secret",
                "entra-userCookie"
            )
            | project
                SourceDeviceId    = SourceNodeId,
                SourceDeviceName  = SourceNodeName,
                SourceDeviceLabel = SourceNodeLabel,
                CredentialNodeId  = TargetNodeId,
                CredentialName    = TargetNodeName,
                CredentialLabel   = TargetNodeLabel
            | summarize
                SourceDevices          = make_set(SourceDeviceName),
                SourceDeviceTypes      = make_set(SourceDeviceLabel),
                SourceDeviceCount      = dcount(SourceDeviceId),
                FirstSourceDeviceId    = any(SourceDeviceId),
                FirstSourceDeviceName  = any(SourceDeviceName),
                FirstSourceDeviceLabel = any(SourceDeviceLabel)
              by CredentialNodeId, CredentialName, CredentialLabel;


        // Step 3  Hop 1 credential can authenticate as identity
        let Hop1 =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                Hop1_SourceCredentialId = SourceNodeId,
                Hop1_EdgeLabel          = EdgeLabel,
                IntermediateIdentityId  = TargetNodeId,
                IntermediateIdentity    = TargetNodeName,
                IntermediateIdentityLabel = TargetNodeLabel;


        // Step 4  Hop 2 identity can reach target resources
        let Hop2 =
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "runs on", "has permissions to", "has role on")
            | where TargetNodeLabel in (
                "microsoft.compute/virtualmachines",
                "microsoft.compute/virtualmachines/extensions",
                "device",
                "computer-account",
                "microsoft.web/sites_webapp",
                "microsoft.sql/servers",
                "microsoft.storage/storageaccounts",
                "microsoft.keyvault/vaults",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts_openai",
                "microsoft.operationalinsights/workspaces",
                "subscriptions",
                "resourcegroups"
            )
            | project
                Hop2_SourceIdentityId = SourceNodeId,
                Hop2_EdgeLabel        = EdgeLabel,
                FinalTargetId         = TargetNodeId,
                FinalTargetName       = TargetNodeName,
                FinalTargetLabel      = TargetNodeLabel;


        // Step 5  Assemble 2 hop attack paths and de-duplicate
        let Paths =
            CredentialsOnDevices
            | join kind=inner (Hop1) on $left.CredentialNodeId == $right.Hop1_SourceCredentialId
            | join kind=inner (Hop2) on $left.IntermediateIdentityId == $right.Hop2_SourceIdentityId
            | where FirstSourceDeviceId != FinalTargetId
            | summarize
                SourceDevices              = any(SourceDevices),
                SourceDeviceTypes          = any(SourceDeviceTypes),
                SourceDeviceCount          = any(SourceDeviceCount),
                FirstSourceDeviceId        = any(FirstSourceDeviceId),
                FirstSourceDeviceName      = any(FirstSourceDeviceName),
                FirstSourceDeviceLabel     = any(FirstSourceDeviceLabel),
                CredentialName             = any(CredentialName),
                CredentialLabel            = any(CredentialLabel),
                IntermediateIdentityId     = any(IntermediateIdentityId),
                IntermediateIdentity       = any(IntermediateIdentity),
                IntermediateIdentityLabel  = any(IntermediateIdentityLabel),
                Hop1Edge                   = any(Hop1_EdgeLabel),
                Hop2Edge                   = any(Hop2_EdgeLabel),
                FinalTargetName            = any(FinalTargetName),
                FinalTargetLabel           = any(FinalTargetLabel)
              by CredentialNodeId, FinalTargetId;


        // Step 6  Enrich paths with node metadata and keep NodeProperties
        Paths
        | join kind=leftouter (
            Nodes
            | project-rename
                SourceNodeId                     = NodeId,
                SourceNodeName                   = NodeName,
                SourceNodeLabel                  = NodeLabel,
                SourceCriticalityTier            = CriticalityTier,
                SourceCriticalityTierLevel       = CriticalityTierLevel,
                SourceIsInternetExposed          = IsInternetExposed,
                SourceIsExcluded                 = IsExcluded,
                SourceAssetTierByTag             = AssetTierByTag,
                SourceLegacyEndOfSupport         = LegacyEndOfSupport,
                SourceRiskProb                   = RiskFactor_Probability,
                SourceRiskProbDetailed           = RiskFactor_Probability_Detailed,
                SourceRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                SourceNodeProperties             = NodeProperties
        ) on $left.FirstSourceDeviceId == $right.SourceNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                IntermediateNodeId               = NodeId,
                IntermediateNodeName             = NodeName,
                IntermediateNodeLabel            = NodeLabel,
                IntermediateCriticalityTier      = CriticalityTier,
                IntermediateCriticalityTierLevel = CriticalityTierLevel,
                IntermediateIsInternetExposed    = IsInternetExposed,
                IntermediateIsExcluded           = IsExcluded,
                IntermediateAssetTierByTag       = AssetTierByTag,
                IntermediateLegacyEndOfSupport   = LegacyEndOfSupport,
                IntermediateRiskProb             = RiskFactor_Probability,
                IntermediateRiskProbDetailed     = RiskFactor_Probability_Detailed,
                IntermediateRiskProbDetailedScore= RiskFactor_Probability_DetailedScore,
                IntermediateNodeProperties       = NodeProperties
        ) on $left.IntermediateIdentityId == $right.IntermediateNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                TargetNodeId                     = NodeId,
                TargetNodeName                   = NodeName,
                TargetNodeLabel                  = NodeLabel,
                TargetCriticalityTier            = CriticalityTier,
                TargetCriticalityTierLevel       = CriticalityTierLevel,
                TargetIsInternetExposed          = IsInternetExposed,
                TargetIsExcluded                 = IsExcluded,
                TargetAssetTierByTag             = AssetTierByTag,
                TargetLegacyEndOfSupport         = LegacyEndOfSupport,
                TargetRiskProb                   = RiskFactor_Probability,
                TargetRiskProbDetailed           = RiskFactor_Probability_Detailed,
                TargetRiskProbDetailedScore      = RiskFactor_Probability_DetailedScore,
                TargetNodeProperties             = NodeProperties
        ) on $left.FinalTargetId == $right.TargetNodeId

        | join kind=leftouter (
            Nodes
            | project-rename
                CredentialNodeId_join        = NodeId,
                CredentialNodeName_join      = NodeName,
                CredentialNodeLabel_join     = NodeLabel,
                CredentialNodeProperties     = NodeProperties
        ) on $left.CredentialNodeId == $right.CredentialNodeId_join


        // Step 7  Attack path prioritization logic
        | extend TierEscalation =
            case(
                isnotempty(SourceCriticalityTier) and isnotempty(TargetCriticalityTier) and SourceCriticalityTier > TargetCriticalityTier,
                    SourceCriticalityTier - TargetCriticalityTier,
                0
            )
        | extend IsLateralMovement = TierEscalation > 0
        | extend LateralMovementType =
            case(
                TierEscalation >= 3, "Privilege escalation large tier jump",
                TierEscalation == 2, "Privilege escalation two tiers",
                TierEscalation == 1, "Privilege escalation one tier",
                "Direct access same tier"
            )

        | extend TargetTierWeight =
            case(
                TargetCriticalityTier == 0, 100,
                TargetCriticalityTier == 1, 60,
                TargetCriticalityTier == 2, 30,
                10
            )
        | extend EscalationWeight = TierEscalation * 10
        | extend ExposureWeight   = iff(TargetIsInternetExposed == true, 8, 0) + iff(SourceIsInternetExposed == true, 3, 0)
        | extend SourceTierAmplifier =
            case(
                SourceCriticalityTier == 0, 8,
                SourceCriticalityTier == 1, 5,
                SourceCriticalityTier == 2, 2,
                0
            )
        | extend AttackPathPriorityScore = TargetTierWeight + EscalationWeight + ExposureWeight + SourceTierAmplifier

        | extend AttackPathPriority =
            case(
                AttackPathPriorityScore >= 120, "Critical",
                AttackPathPriorityScore >= 90,  "Very High",
                AttackPathPriorityScore >= 60,  "High",
                AttackPathPriorityScore >= 30,  "Medium-High",
                AttackPathPriorityScore >= 15,  "Medium",
                "Low"
            )


        // Step 8  Human readable paths and Internet-Exposed wording
        | extend InternetExposureTarget = iff(TargetIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")
        | extend InternetExposureSource = iff(SourceIsInternetExposed == true, "Internet-Exposed", "Not Internet-Exposed")

        | extend AttackPath =
            strcat(
                FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] -> ",
                CredentialLabel, " [", CredentialName, "] -> ",
                IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                FinalTargetLabel, " [", FinalTargetName, "]"
            )
        | extend AttackPathDetailed =
            strcat(
                "SOURCE ", FirstSourceDeviceLabel, " [", FirstSourceDeviceName, "] ",
                "tier ", tostring(SourceCriticalityTier), " ", tostring(SourceCriticalityTierLevel), " ",
                " | ", InternetExposureSource,
                " -> CREDENTIAL ", CredentialLabel, " [", CredentialName, "] ",
                " -> IDENTITY ", IntermediateIdentityLabel, " [", IntermediateIdentity, "] ",
                " -> TARGET ", FinalTargetLabel, " [", FinalTargetName, "] ",
                "tier ", tostring(TargetCriticalityTier), " ", tostring(TargetCriticalityTierLevel), " ",
                " | ", InternetExposureTarget,
                " | escalation ", tostring(TierEscalation),
                " | ", LateralMovementType
            )

        | project
            AttackPathPriority,
            AttackPathPriorityScore,
            TierEscalation,
            IsLateralMovement,
            LateralMovementType,

            FirstSourceDeviceId,
            FirstSourceDeviceName,
            FirstSourceDeviceLabel,
            IntermediateIdentityId,
            IntermediateIdentity,
            IntermediateIdentityLabel,
            CredentialNodeId,
            CredentialName,
            CredentialLabel,
            FinalTargetId,
            FinalTargetName,
            FinalTargetLabel,

            TargetCriticalityTier,
            TargetCriticalityTierLevel,
            TargetAssetTierByTag,
            TargetIsInternetExposed,
            TargetLegacyEndOfSupport,
            TargetRiskProb,
            TargetRiskProbDetailed,
            TargetRiskProbDetailedScore,

            SourceCriticalityTier,
            SourceCriticalityTierLevel,
            SourceAssetTierByTag,
            SourceIsInternetExposed,
            SourceLegacyEndOfSupport,
            SourceRiskProb,
            SourceRiskProbDetailed,
            SourceRiskProbDetailedScore,

            IntermediateCriticalityTier,
            IntermediateCriticalityTierLevel,
            IntermediateIsInternetExposed,
            IntermediateLegacyEndOfSupport,
            IntermediateRiskProb,
            IntermediateRiskProbDetailed,
            IntermediateRiskProbDetailedScore,

            SourceDeviceCount,
            SourceDevices,
            SourceDeviceTypes,
            Hop1Edge,
            Hop2Edge,

            AttackPath,
            AttackPathDetailed,

            SourceNodeProperties,
            IntermediateNodeProperties,
            TargetNodeProperties,
            CredentialNodeProperties
        | order by AttackPathPriorityScore desc, TierEscalation desc, TargetCriticalityTier asc, FinalTargetName asc

  - ReportName: Attack_Paths_Detailed_Github_to_Azure_Resources
    ReportPurpose: Attack Paths - Github to Azure resources.  GitHub -> Secret -> Azure Resource. Key Detection -> Supply chain compromise
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories)),
                     LabelStr      = tolower(tostring(NodeLabel))
            | extend NodeNameNorm = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )
            | extend EG_IsCustomerFacing =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))
            | extend EG_IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))
            | extend RiskFactors =
                todynamic(coalesce(
                    tostring(NodeProperties.rawData.risk.riskFactors),
                    tostring(NodeProperties.risk.riskFactors),
                    "[]"
                ))
            | extend RawCriticality =
                tostring(coalesce(
                    NodeProperties.rawData.criticality,
                    NodeProperties.criticality,
                    ""
                ))
            | extend RiskFactor_Probability =
                iff(
                    EG_IsCustomerFacing == true
                    or tolower(RawCriticality) in ("critical", "very high")
                    or tostring(RiskFactors) has "Exposure to the Internet",
                    1, 0
                )
            | extend IsEntryPoint =
                        (CategoriesStr has "ip_address")
                     or (CategoriesStr has "device")
                     or (CategoriesStr has "virtual_machine")
                     or (CategoriesStr has "computer"),
                     IsAzureResource =
                        (CategoriesStr has "environmentazure")
                     or (CategoriesStr has "environmentcloud")
            | extend CriticalityTier =
                case(
                    CriticalityLevel == 0, 0,
                    CriticalityLevel == 1, 1,
                    CriticalityLevel == 2, 2,
                    3
                )
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                IsEntryPoint,
                IsAzureResource,
                RiskFactor_Probability,
                RawCriticality,
                RiskFactors;

        // Normalize labels to avoid "microsoft. sql" / "microsoft. compute" typos breaking filters
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };

        // Find credentials in GitHub workflows/repositories
        let GitHubCredentials =
            ExposureGraphEdges
            | where EdgeLabel in ("contains", "defined in")
            | extend SourceNodeLabelNorm = NormalizeLabel(SourceNodeLabel),
                     TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where SourceNodeLabelNorm in ("githubworkflow", "githubrepository")
            | where TargetNodeLabelNorm in (
                "azure-active-directory-app-secret",
                "user-azure-cli-secret",
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-user-credentials",
                "service-principal-azure-cli-secret",
                "azure-app-configuration-key"
            )
            | project
                SourceGitHubNodeId    = SourceNodeId,
                SourceGitHubNodeName  = SourceNodeName,
                SourceGitHubNodeLabel = SourceNodeLabel,
                CredentialNodeId      = TargetNodeId,
                CredentialNodeName    = TargetNodeName,
                CredentialNodeLabel   = TargetNodeLabel
            | summarize
                GitHubSources         = make_set(SourceGitHubNodeName),
                GitHubSourceTypes     = make_set(SourceGitHubNodeLabel),
                GitHubSourceCount     = dcount(SourceGitHubNodeId),
                FirstGitHubSource     = any(SourceGitHubNodeId),
                FirstGitHubSourceName = any(SourceGitHubNodeName),
                FirstGitHubSourceLabel = any(SourceGitHubNodeLabel)
              by CredentialNodeId, CredentialNodeName, CredentialNodeLabel;

        // Main attack path query
        GitHubCredentials
        | join kind=inner (
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
        ) on $left.CredentialNodeId == $right.SourceNodeId
        | join kind=inner (
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "has permissions to", "has role on")
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.compute/virtualmachines",
                "microsoft.storage/storageaccounts",
                "microsoft.keyvault/vaults",
                "microsoft.sql/servers",
                "microsoft.sql/servers/databases",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts_openai",
                "subscriptions",
                "resourcegroups",
                "blobcontainer"
            )
        ) on $left.TargetNodeId == $right.SourceNodeId

        // Optional avoid GitHub source == target asset scenarios (usually not needed but safe)
        | where FirstGitHubSource != TargetNodeId1

        | summarize
            GitHubSources          = any(GitHubSources),
            GitHubSourceTypes      = any(GitHubSourceTypes),
            GitHubSourceCount      = any(GitHubSourceCount),
            FirstGitHubSource      = any(FirstGitHubSource),
            FirstGitHubSourceName  = any(FirstGitHubSourceName),
            FirstGitHubSourceLabel = any(FirstGitHubSourceLabel),
            CredentialNodeName     = any(CredentialNodeName),
            CredentialNodeLabel    = any(CredentialNodeLabel),
            IntermediateIdentity   = any(TargetNodeName),
            IntermediateIdentityLabel = any(TargetNodeLabel),
            EdgeLabel              = any(EdgeLabel1),
            TargetAsset            = any(TargetNodeId1),
            TargetAssetName        = any(TargetNodeName1),
            TargetAssetLabel       = any(TargetNodeLabel1)
          by CredentialNodeId, TargetNodeId1

        | join kind=leftouter (Nodes) on $left.FirstGitHubSource == $right.AssetNodeId
        | join kind=leftouter (Nodes) on $left.TargetAsset == $right.AssetNodeId

        | extend
            SourceIsCustomerFacing = true, // GitHub is internet-facing by default
            SourceCriticalityTier  = 3,    // GitHub workflow/repo is treated as low trust
            TargetCriticality      = CriticalityTier1,
            TargetCriticalityLevel = CriticalityTierLevel1,
            TargetIsCustomerFacing = EG_IsCustomerFacing1,
            TargetCriticalityRuleBased = CriticalityRuleBased1,
            TargetCriticalityRuleNames = CriticalityRuleNames1,
            TargetRiskProbability  = RiskFactor_Probability1

        | extend TierEscalation =
            case(
                SourceCriticalityTier > TargetCriticality, SourceCriticalityTier - TargetCriticality,
                0
            )

        | extend SecuritySeverityScore =
            case(
                TierEscalation >= 3 and TargetCriticality == 0, 10,
                TierEscalation >= 2 and TargetCriticality == 0, 9,
                TierEscalation >= 1 and TargetCriticality == 0, 8,
                TierEscalation >= 2 and TargetCriticality == 1, 8,
                TierEscalation >= 1 and TargetCriticality == 1, 7,
                TargetCriticality == 0, 7,
                TargetCriticality == 1, 6,
                TargetCriticality == 2, 4,
                2
            )
        | extend SecuritySeverityLevel =
            case(
                SecuritySeverityScore >= 9, "Critical",
                SecuritySeverityScore >= 7, "Very High",
                SecuritySeverityScore >= 5, "High",
                SecuritySeverityScore >= 3, "Medium-High",
                "Medium"
            )

        | extend SecurityDomain = "Supply Chain"
        | extend Category = "AttackPath_GitHubToAzure"
        | extend Subcategory =
            case(
                TierEscalation >= 3, strcat("GitHub to Tier ", TargetCriticality, " - Critical Supply Chain Risk"),
                TierEscalation >= 2, strcat("GitHub to Tier ", TargetCriticality, " - High Supply Chain Risk"),
                TierEscalation >= 1, strcat("GitHub to Tier ", TargetCriticality, " - Moderate Supply Chain Risk"),
                "GitHub to Azure - Direct Access"
            )

        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName  = IntermediateIdentity,
            AssetLabel = IntermediateIdentityLabel,
            ConfigurationName = FirstGitHubSourceName,
            ConfigurationId   = CredentialNodeLabel,
            TierEscalation,
            SourceGitHub = FirstGitHubSourceName,
            SourceGitHubType = FirstGitHubSourceLabel,
            TotalGitHubSourcesWithCredential = GitHubSourceCount,
            AllGitHubSources = GitHubSources,
            CredentialType = CredentialNodeLabel,
            CredentialNode = CredentialNodeName,
            IntermediateIdentity,
            IntermediateIdentityType = IntermediateIdentityLabel,
            FinalTarget = TargetAssetName,
            FinalTargetType = TargetAssetLabel,
            CriticalityTier = TargetCriticality,
            CriticalityTierLevel = TargetCriticalityLevel,
            EdgeLabel,
            CriticalityRuleBased = TargetCriticalityRuleBased,
            CriticalityRuleNames = TargetCriticalityRuleNames,
            IsCustomerFacing = TargetIsCustomerFacing,
            RiskProbability = TargetRiskProbability,
            SecuritySeverity = SecuritySeverityLevel,
            SecurityScore = SecuritySeverityScore,
            AttackPath =
                strcat(
                    FirstGitHubSourceLabel, " [", FirstGitHubSourceName, "] -> ",
                    CredentialNodeLabel, " -> ",
                    IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                    TargetAssetLabel, " [", TargetAssetName, "]"
                ),
            AttackPathDetailed =
                strcat(
                    "SOURCE: ", FirstGitHubSourceLabel, " [", FirstGitHubSourceName, "] (Internet-Facing) ",
                    iff(GitHubSourceCount > 1, strcat("+ ", GitHubSourceCount - 1, " other GitHub source(s)"), ""),
                    " -> ",
                    "CREDENTIAL: ", CredentialNodeLabel, " -> ",
                    "IDENTITY: ", IntermediateIdentityLabel, " [", IntermediateIdentity, "] -> ",
                    "TARGET: ", TargetAssetLabel, " [", TargetAssetName, "] (", TargetCriticalityLevel, ")"
                )
        | order by SecurityScore desc, TierEscalation desc, CriticalityTier asc

  - ReportName: Attack_Paths_Detailed_Public_IP_to_VM_with_CVE_Exploitation
    ReportPurpose: Attack Paths with focus on Public IP to VM with CVE Exploitation. Public IP -> Vulnerable VM/Device. Key detection -> Internet-exposed vulnerabilities
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories)),
                     LabelStr      = tolower(tostring(NodeLabel))
            | extend NodeNameNorm = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )
            | extend EG_IsCustomerFacing =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))
            | extend EG_IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))
            | extend RiskFactors =
                todynamic(coalesce(
                    tostring(NodeProperties.rawData.risk.riskFactors),
                    tostring(NodeProperties.risk.riskFactors),
                    "[]"
                ))
            | extend RawCriticality =
                tostring(coalesce(
                    NodeProperties.rawData.criticality,
                    NodeProperties.criticality,
                    ""
                ))
            | extend RiskFactor_Probability =
                iff(
                    EG_IsCustomerFacing == true
                    or tolower(RawCriticality) in ("critical", "very high")
                    or tostring(RiskFactors) has "Exposure to the Internet",
                    1, 0
                )
            | extend CVESeverity =
                tostring(coalesce(
                    NodeProperties.rawData.severity,
                    NodeProperties.rawData.Severity,
                    NodeProperties.rawData.cvssScore,
                    ""
                ))
            | extend IsEntryPoint =
                        (CategoriesStr has "ip_address")
                     or (CategoriesStr has "device")
                     or (CategoriesStr has "virtual_machine")
                     or (CategoriesStr has "computer"),
                     IsAzureResource =
                        (CategoriesStr has "environmentazure")
                     or (CategoriesStr has "environmentcloud")
            | extend CriticalityTier =
                case(
                    CriticalityLevel == 0, 0,
                    CriticalityLevel == 1, 1,
                    CriticalityLevel == 2, 2,
                    3
                )
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                IsEntryPoint,
                IsAzureResource,
                RiskFactor_Probability,
                RawCriticality,
                RiskFactors,
                CVESeverity;

        // Helper to avoid label typos like "microsoft. compute/..." or spaces
        let NormalizeLabel = (s:string) { tolower(trim(" ", replace_string(s, " ", ""))) };

        // Find Public IPs connected to resources
        let PublicIPConnections =
            ExposureGraphEdges
            | where SourceNodeLabel == "microsoft.network/publicipaddresses"
            | where EdgeLabel in ("routes traffic to", "contains")
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.network/networkinterfaces",
                "microsoft.compute/virtualmachines",
                "device"
            )
            | project
                PublicIPNodeId            = SourceNodeId,
                PublicIPNodeName          = SourceNodeName,
                ExposedResourceNodeId     = TargetNodeId,
                ExposedResourceNodeName   = TargetNodeName,
                ExposedResourceNodeLabel  = TargetNodeLabel
            | summarize
                PublicIPs         = make_set(PublicIPNodeName),
                PublicIPCount     = dcount(PublicIPNodeId),
                FirstPublicIP     = any(PublicIPNodeId),
                FirstPublicIPName = any(PublicIPNodeName)
              by ExposedResourceNodeId, ExposedResourceNodeName, ExposedResourceNodeLabel;

        // Find CVEs affecting resources
        let CVEsAffectingResources =
            ExposureGraphEdges
            | where SourceNodeLabel == "Cve"
            | where EdgeLabel == "affecting"
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where TargetNodeLabelNorm in (
                "microsoft.compute/virtualmachines",
                "device",
                "computer-account"
            )
            | project
                CVENodeId                = SourceNodeId,
                CVENodeName              = SourceNodeName,
                AffectedResourceNodeId   = TargetNodeId,
                AffectedResourceNodeName = TargetNodeName,
                AffectedResourceNodeLabel = TargetNodeLabel
            | summarize
                CVEs         = make_set(CVENodeName),
                CVECount     = dcount(CVENodeId),
                FirstCVE     = any(CVENodeId),
                FirstCVEName = any(CVENodeName)
              by AffectedResourceNodeId, AffectedResourceNodeName, AffectedResourceNodeLabel;

        // Join Public IPs with CVEs
        PublicIPConnections
        | join kind=inner CVEsAffectingResources on $left.ExposedResourceNodeId == $right.AffectedResourceNodeId
        | summarize
            PublicIPs         = any(PublicIPs),
            PublicIPCount     = any(PublicIPCount),
            FirstPublicIPName = any(FirstPublicIPName),
            CVEs              = any(CVEs),
            CVECount          = any(CVECount),
            FirstCVEName      = any(FirstCVEName),
            FirstCVE          = any(FirstCVE)
          by ExposedResourceNodeId, ExposedResourceNodeName, ExposedResourceNodeLabel

        // Enrich exposed resource (target asset) info
        | join kind=leftouter (Nodes) on $left.ExposedResourceNodeId == $right.AssetNodeId

        // Enrich CVE node info (for severity)
        | join kind=leftouter (Nodes) on $left.FirstCVE == $right.AssetNodeId

        | extend
            TargetCriticality          = CriticalityTier,          // from exposed resource join
            TargetCriticalityLevel     = CriticalityTierLevel,
            TargetIsCustomerFacing     = EG_IsCustomerFacing,
            TargetCriticalityRuleBased = CriticalityRuleBased,
            TargetCriticalityRuleNames = CriticalityRuleNames,
            TargetRiskProbability      = RiskFactor_Probability,
            CVESev                     = CVESeverity1              // from CVE join

        | extend CVESeverityScore =
            case(
                tolower(CVESev) has "critical", 5,
                tolower(CVESev) has "high", 4,
                tolower(CVESev) has "medium", 3,
                tolower(CVESev) has "low", 2,
                1
            )

        | extend SecuritySeverityScore =
            case(
                TargetCriticality == 0 and CVESeverityScore >= 4, 10,
                TargetCriticality == 0 and CVESeverityScore >= 3, 9,
                TargetCriticality == 1 and CVESeverityScore >= 4, 8,
                TargetCriticality == 1 and CVESeverityScore >= 3, 7,
                TargetCriticality == 2 and CVESeverityScore >= 4, 6,
                CVESeverityScore >= 4, 5,
                CVESeverityScore >= 3, 4,
                3
            )

        | extend SecuritySeverityLevel =
            case(
                SecuritySeverityScore >= 9, "Critical",
                SecuritySeverityScore >= 7, "Very High",
                SecuritySeverityScore >= 5, "High",
                SecuritySeverityScore >= 3, "Medium-High",
                "Medium"
            )

        | extend SecurityDomain = "Internet-Exposed Assets"
        | extend Category = "AttackPath_PublicIPWithCVE"
        | extend Subcategory =
            case(
                TargetCriticality == 0 and CVESeverityScore >= 4, "Tier 0 - Internet-Exposed with Critical CVE",
                TargetCriticality == 0, "Tier 0 - Internet-Exposed with Vulnerability",
                TargetCriticality == 1 and CVESeverityScore >= 4, "Tier 1 - Internet-Exposed with Critical CVE",
                TargetCriticality == 1, "Tier 1 - Internet-Exposed with Vulnerability",
                CVESeverityScore >= 4, "Internet-Exposed with Critical CVE",
                "Internet-Exposed with Vulnerability"
            )

        | order by SecuritySeverityScore desc, TargetCriticality asc, CVESeverityScore desc

        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName = ExposedResourceNodeName,
            AssetLabel = ExposedResourceNodeLabel,
            ConfigurationName = FirstPublicIPName,
            ConfigurationId = FirstCVEName,
            PublicIPAddress = FirstPublicIPName,
            TotalPublicIPs = PublicIPCount,
            AllPublicIPs = PublicIPs,
            CVE = FirstCVEName,
            TotalCVEs = CVECount,
            AllCVEs = CVEs,
            CVESeverity = CVESev,
            ExposedResource = ExposedResourceNodeName,
            ExposedResourceType = ExposedResourceNodeLabel,
            CriticalityTier = TargetCriticality,
            CriticalityTierLevel = TargetCriticalityLevel,
            CriticalityRuleBased = TargetCriticalityRuleBased,
            CriticalityRuleNames = TargetCriticalityRuleNames,
            IsCustomerFacing = TargetIsCustomerFacing,
            RiskProbability = TargetRiskProbability,
            SecuritySeverity = SecuritySeverityLevel,
            SecurityScore = SecuritySeverityScore,
            AttackPath =
                strcat(
                    "Public IP [", FirstPublicIPName, "] -> ",
                    ExposedResourceNodeLabel, " [", ExposedResourceNodeName, "] <- ",
                    "CVE [", FirstCVEName, "]"
                ),
            AttackPathDetailed =
                strcat(
                    "PUBLIC IP: [", FirstPublicIPName, "] ",
                    iff(PublicIPCount > 1, strcat("+ ", PublicIPCount - 1, " other IP(s)"), ""),
                    " -> ",
                    "EXPOSED: ", ExposedResourceNodeLabel, " [", ExposedResourceNodeName, "] (", TargetCriticalityLevel, ") <- ",
                    "CVE: [", FirstCVEName, "] (", CVESev, ") ",
                    iff(CVECount > 1, strcat("+ ", CVECount - 1, " other CVE(s)"), "")
                );

  - ReportName: Attack_Paths_Detailed_Identity_Group_Membership_to_Privileged_Resources
    ReportPurpose: Attack Paths based on Identity Group Membership to Privileged Resources. Identity -> Group -> Privileged Resource. Key Detection -> Group-based attacks
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories)), 
                     LabelStr = tolower(tostring(NodeLabel))
            | extend NodeNameNorm = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties. criticalityLevel.criticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties. criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties. criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )
            | extend EG_IsCustomerFacing = tobool(coalesce(
                NodeProperties. rawData.isCustomerFacing,
                NodeProperties.raw. isCustomerFacing,
                false
              ))
            | extend EG_IsExcluded = tobool(coalesce(
                NodeProperties.rawData.isExcluded,
                NodeProperties. raw.isExcluded,
                false
              ))
            | extend RiskFactors = todynamic(coalesce(
                tostring(NodeProperties.rawData.risk.riskFactors),
                tostring(NodeProperties.risk.riskFactors),
                "[]"
              ))
            | extend RawCriticality = tostring(coalesce(
                NodeProperties.rawData.criticality,
                NodeProperties.criticality,
                ""
              ))
            | extend RiskFactor_Probability =
                iff(
                    EG_IsCustomerFacing == true
                    or tolower(RawCriticality) in ("critical","very high")
                    or tostring(RiskFactors) has "Exposure to the Internet",
                    1, 0
                )
            | extend IsEntryPoint = (CategoriesStr has "ip_address") or 
                                   (CategoriesStr has "device") or 
                                   (CategoriesStr has "virtual_machine") or 
                                   (CategoriesStr has "computer"),
                     IsAzureResource = (CategoriesStr has "environmentazure") or 
                                      (CategoriesStr has "environmentcloud")
            | extend CriticalityTier = case(
                    CriticalityLevel == 0, 0,
                    CriticalityLevel == 1, 1,
                    CriticalityLevel == 2, 2,
                    3
                )
            | extend CriticalityTierLevel = case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                IsEntryPoint,
                IsAzureResource,
                RiskFactor_Probability,
                RawCriticality,
                RiskFactors;
        // Find identities in groups
        let IdentityGroupMembership = 
            ExposureGraphEdges
            | where EdgeLabel == "member of"
            | where SourceNodeLabel in ("user", "serviceprincipal", "managedidentity")
            | where TargetNodeLabel == "group"
            | project IdentityNodeId = SourceNodeId,
                      IdentityNodeName = SourceNodeName,
                      IdentityNodeLabel = SourceNodeLabel,
                      GroupNodeId = TargetNodeId,
                      GroupNodeName = TargetNodeName
            | summarize 
                Identities = make_set(IdentityNodeName),
                IdentityTypes = make_set(IdentityNodeLabel),
                IdentityCount = dcount(IdentityNodeId),
                FirstIdentity = any(IdentityNodeId),
                FirstIdentityName = any(IdentityNodeName),
                FirstIdentityLabel = any(IdentityNodeLabel)
              by GroupNodeId, GroupNodeName;
        // Main attack path query
        IdentityGroupMembership
        | join kind=inner (
            ExposureGraphEdges
            | where EdgeLabel in ("has role on", "has permissions to")
            | where TargetNodeLabel in (
                "subscriptions",
                "resourcegroups",
                "microsoft.keyvault/vaults",
                "microsoft.storage/storageaccounts",
                "microsoft.sql/servers",
                "microsoft.compute/virtualmachines",
                "microsoft.cognitiveservices/accounts"
            )
        ) on $left.GroupNodeId == $right.SourceNodeId
        | summarize 
            Identities = any(Identities),
            IdentityTypes = any(IdentityTypes),
            IdentityCount = any(IdentityCount),
            FirstIdentity = any(FirstIdentity),
            FirstIdentityName = any(FirstIdentityName),
            FirstIdentityLabel = any(FirstIdentityLabel),
            GroupNodeName = any(GroupNodeName),
            EdgeLabel = any(EdgeLabel),
            TargetAsset = any(TargetNodeId),
            TargetAssetName = any(TargetNodeName),
            TargetAssetLabel = any(TargetNodeLabel)
          by GroupNodeId, TargetNodeId
        | join kind=leftouter (Nodes) on $left.FirstIdentity == $right.AssetNodeId
        | join kind=leftouter (Nodes) on $left.TargetAsset == $right. AssetNodeId
        | extend SourceCriticality = CriticalityTier,
                 SourceCriticalityLevel = CriticalityTierLevel,
                 SourceIsCustomerFacing = EG_IsCustomerFacing,
                 TargetCriticality = CriticalityTier1,
                 TargetCriticalityLevel = CriticalityTierLevel1,
                 TargetIsCustomerFacing = EG_IsCustomerFacing1,
                 TargetCriticalityRuleBased = CriticalityRuleBased1,
                 TargetCriticalityRuleNames = CriticalityRuleNames1,
                 TargetRiskProbability = RiskFactor_Probability1
        | extend TierEscalation = case(
                SourceCriticality > TargetCriticality, SourceCriticality - TargetCriticality,
                0
            )
        | extend SecuritySeverityScore = case(
                TierEscalation >= 3 and TargetCriticality == 0, 9,
                TierEscalation >= 2 and TargetCriticality == 0, 8,
                TierEscalation >= 1 and TargetCriticality == 0, 7,
                TargetCriticality == 0, 7,
                TierEscalation >= 2 and TargetCriticality == 1, 6,
                TierEscalation >= 1 and TargetCriticality == 1, 5,
                TargetCriticality == 1, 5,
                TargetCriticality == 2, 3,
                2
            )
        | extend SecuritySeverityLevel = case(
                SecuritySeverityScore >= 8, "Critical",
                SecuritySeverityScore >= 6, "Very High",
                SecuritySeverityScore >= 4, "High",
                SecuritySeverityScore >= 2, "Medium-High",
                "Medium"
            )
        | extend SecurityDomain = "Azure"
        | extend Category = "AttackPath_GroupMembershipPrivilege"
        | extend Subcategory = case(
                TierEscalation >= 3, strcat("Tier ", SourceCriticality, " to Tier ", TargetCriticality, " - Group-Based Privilege Escalation"),
                TierEscalation >= 2, strcat("Tier ", SourceCriticality, " to Tier ", TargetCriticality, " - Group-Based Escalation"),
                TierEscalation >= 1, strcat("Tier ", SourceCriticality, " to Tier ", TargetCriticality, " - Group Privilege"),
                "Group-Based Access to Privileged Resource"
            )
        | project 
            SecurityDomain,
            Category,
            Subcategory,
            AssetName = GroupNodeName,
            AssetLabel = "group",
            ConfigurationName = FirstIdentityName,
            ConfigurationId = FirstIdentityLabel,
            TierEscalation,
            SourceIdentity = FirstIdentityName,
            SourceIdentityType = FirstIdentityLabel,
            SourceIdentityCriticality = SourceCriticalityLevel,
            TotalIdentitiesInGroup = IdentityCount,
            AllIdentities = Identities,
            GroupName = GroupNodeName,
            EdgeLabel,
            FinalTarget = TargetAssetName,
            FinalTargetType = TargetAssetLabel,
            CriticalityTier = TargetCriticality,
            CriticalityTierLevel = TargetCriticalityLevel,
            CriticalityRuleBased = TargetCriticalityRuleBased,
            CriticalityRuleNames = TargetCriticalityRuleNames,
            IsCustomerFacing = TargetIsCustomerFacing,
            RiskProbability = TargetRiskProbability,
            SecuritySeverity = SecuritySeverityLevel,
            SecurityScore = SecuritySeverityScore,
            AttackPath = strcat(
                FirstIdentityLabel, " [", FirstIdentityName, "] -> ",
                "Group [", GroupNodeName, "] -> ",
                TargetAssetLabel, " [", TargetAssetName, "]"
            ),
            AttackPathDetailed = strcat(
                "IDENTITY: ", FirstIdentityLabel, " [", FirstIdentityName, "] (", SourceCriticalityLevel, ") ",
                iff(IdentityCount > 1, strcat("+ ", IdentityCount - 1, " other identity/ies"), ""), " -> ",
                "GROUP: [", GroupNodeName, "] -> ",
                "TARGET: ", TargetAssetLabel, " [", TargetAssetName, "] (", TargetCriticalityLevel, ")"
            )
        | order by SecurityScore desc, TierEscalation desc, CriticalityTier asc

  - ReportName: Attack_Paths_Detailed_Data_Sensitivity_to_Exposed_Credentials
    ReportPurpose: Attack Paths with Data Sensitivity to Exposed Credentials. Sensitive Data -> Storage -> Exposed Credential. Key detection -> Data exfiltration risk
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories)),
                     LabelStr      = tolower(tostring(NodeLabel))
            | extend NodeNameNorm = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )
            | extend EG_IsCustomerFacing =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))
            | extend EG_IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))
            | extend RiskFactors =
                todynamic(coalesce(
                    tostring(NodeProperties.rawData.risk.riskFactors),
                    tostring(NodeProperties.risk.riskFactors),
                    "[]"
                ))
            | extend RawCriticality =
                tostring(coalesce(
                    NodeProperties.rawData.criticality,
                    NodeProperties.criticality,
                    ""
                ))
            | extend RiskFactor_Probability =
                iff(
                    EG_IsCustomerFacing == true
                    or tolower(RawCriticality) in ("critical", "very high")
                    or tostring(RiskFactors) has "Exposure to the Internet",
                    1, 0
                )
            | extend CriticalityTier =
                case(
                    CriticalityLevel == 0, 0,
                    CriticalityLevel == 1, 1,
                    CriticalityLevel == 2, 2,
                    3
                )
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                RiskFactor_Probability;

        let NormalizeLabel = (s:string) { tolower(trim(' ', replace_string(s, " ", ""))) };

        // Data location allowlist (normalized)
        let DataLocationLabels =
            dynamic([
                "blobcontainer",
                "microsoft.storage/storageaccounts",
                "microsoft.sql/servers/databases",
                "microsoft.sql/servers",
                "microsoft.storage/storageaccounts/blobservices/containers",
                "microsoft.storage/storageaccounts/fileservices/shares"
            ]);

        // Credential allowlist (normalized)
        let CredentialLabels =
            dynamic([
                "azure-storage-shared-access-signature",
                "azure-storage-connection-string",
                "azure-database-connection-string",
                "azure-active-directory-app-secret",
                "service-principal-azure-cli-secret",
                "user-azure-cli-secret",
                "azure-active-directory-user-credentials",
                "entra-usercookie"
            ]);

        // Find sensitive data locations
        let SensitiveDataLocations =
            ExposureGraphEdges
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where SourceNodeLabel == "dataSensitivityScan"
            | where EdgeLabel in ("defined in", "contains")
            | where TargetNodeLabelNorm in (DataLocationLabels)
            | project
                SensitiveDataNodeId   = SourceNodeId,
                SensitiveDataNodeName = SourceNodeName,
                DataLocationNodeId    = TargetNodeId,
                DataLocationNodeName  = TargetNodeName,
                DataLocationNodeLabel = TargetNodeLabel;

        // Identity -> data location access edges (broadened)
        let IdentityAccessToData =
            ExposureGraphEdges
            | extend TargetNodeLabelNorm = NormalizeLabel(TargetNodeLabel)
            | where EdgeLabel in ("has permissions to", "has role on", "can authenticate to", "has access to", "can access")
            | where TargetNodeLabelNorm in (DataLocationLabels)
            | project
                IdentityNodeId    = SourceNodeId,
                IdentityNodeName  = SourceNodeName,
                IdentityNodeLabel = SourceNodeLabel,
                DataLocationNodeId = TargetNodeId;

        // Credential exposure edges (support both directions)
        let ExposedCredentialsToIdentity =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            | project
                CredentialNodeId    = SourceNodeId,
                CredentialNodeName  = SourceNodeName,
                CredentialNodeLabel = SourceNodeLabel,
                IdentityNodeId      = TargetNodeId;

        let IdentityToExposedCredentials =
            ExposureGraphEdges
            | where EdgeLabel in ("has credentials of", "uses credential", "uses credentials", "authenticated by")
            | project
                IdentityNodeId      = SourceNodeId,
                CredentialNodeId    = TargetNodeId,
                CredentialNodeName  = TargetNodeName,
                CredentialNodeLabel = TargetNodeLabel;

        // Union both forms and then filter credential types
        let ExposedCreds =
            union isfuzzy=true ExposedCredentialsToIdentity, IdentityToExposedCredentials
            | extend CredentialNodeLabelNorm = NormalizeLabel(CredentialNodeLabel)
            | where CredentialNodeLabelNorm in (CredentialLabels);

        // Build the attack path sensitive data -> data location <- identity <- exposed credential
        IdentityAccessToData
        | join kind=inner SensitiveDataLocations on DataLocationNodeId
        | join kind=inner ExposedCreds on IdentityNodeId
        | summarize
            SensitiveDataItems        = make_set(SensitiveDataNodeName),
            SensitiveDataCount        = dcount(SensitiveDataNodeId),
            ExposedCredentials        = make_set(CredentialNodeName),
            ExposedCredentialTypes    = make_set(CredentialNodeLabel),
            ExposedCredentialCount    = dcount(CredentialNodeId),
            FirstCredentialName       = any(CredentialNodeName),
            FirstCredentialLabel      = any(CredentialNodeLabel),
            IdentityName              = any(IdentityNodeName),
            IdentityLabel             = any(IdentityNodeLabel)
          by DataLocationNodeId, DataLocationNodeName, DataLocationNodeLabel
        | join kind=leftouter (Nodes) on $left.DataLocationNodeId == $right.AssetNodeId
        | extend
            TargetCriticality         = CriticalityTier,
            TargetCriticalityLevel    = CriticalityTierLevel,
            TargetIsCustomerFacing    = EG_IsCustomerFacing,
            TargetCriticalityRuleBased = CriticalityRuleBased,
            TargetCriticalityRuleNames = CriticalityRuleNames,
            TargetRiskProbability     = RiskFactor_Probability
        | extend SecuritySeverityScore =
            case(
                ExposedCredentialCount >= 3 and TargetCriticality == 0, 10,
                ExposedCredentialCount >= 2 and TargetCriticality == 0, 9,
                ExposedCredentialCount >= 1 and TargetCriticality == 0, 8,
                ExposedCredentialCount >= 3 and TargetCriticality == 1, 8,
                ExposedCredentialCount >= 2 and TargetCriticality == 1, 7,
                ExposedCredentialCount >= 1 and TargetCriticality == 1, 6,
                ExposedCredentialCount >= 2, 5,
                4
            )
        | extend SecuritySeverityLevel =
            case(
                SecuritySeverityScore >= 9, "Critical",
                SecuritySeverityScore >= 7, "Very High",
                SecuritySeverityScore >= 5, "High",
                SecuritySeverityScore >= 3, "Medium-High",
                "Medium"
            )
        | extend SecurityDomain = "Data Protection"
        | extend Category = "AttackPath_SensitiveDataExposure"
        | extend Subcategory =
            case(
                ExposedCredentialCount >= 3 and TargetCriticality <= 1, "Critical Data - Multiple Exposed Credentials",
                ExposedCredentialCount >= 2 and TargetCriticality <= 1, "Critical Data - Exposed Credentials",
                ExposedCredentialCount >= 1 and TargetCriticality <= 1, "Critical Data - Single Exposed Credential",
                ExposedCredentialCount >= 2, "Sensitive Data - Multiple Exposed Credentials",
                "Sensitive Data - Exposed Credential"
            )
        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName = DataLocationNodeName,
            AssetLabel = DataLocationNodeLabel,
            ConfigurationName = FirstCredentialName,
            ConfigurationId = FirstCredentialLabel,
            SensitiveDataLocation = DataLocationNodeName,
            SensitiveDataLocationType = DataLocationNodeLabel,
            TotalSensitiveDataItems = SensitiveDataCount,
            AllSensitiveDataItems = SensitiveDataItems,
            ExposedCredential = FirstCredentialName,
            ExposedCredentialType = FirstCredentialLabel,
            TotalExposedCredentials = ExposedCredentialCount,
            AllExposedCredentials = ExposedCredentials,
            IdentityWithAccess = IdentityName,
            IdentityType = IdentityLabel,
            CriticalityTier = TargetCriticality,
            CriticalityTierLevel = TargetCriticalityLevel,
            CriticalityRuleBased = TargetCriticalityRuleBased,
            CriticalityRuleNames = TargetCriticalityRuleNames,
            IsCustomerFacing = TargetIsCustomerFacing,
            RiskProbability = TargetRiskProbability,
            SecuritySeverity = SecuritySeverityLevel,
            SecurityScore = SecuritySeverityScore,
            AttackPath =
                strcat(
                    "Sensitive Data -> ",
                    DataLocationNodeLabel, " [", DataLocationNodeName, "] <- ",
                    "Identity [", IdentityName, "] <- ",
                    FirstCredentialLabel, " [", FirstCredentialName, "]"
                ),
            AttackPathDetailed =
                strcat(
                    "SENSITIVE DATA: ", SensitiveDataCount, " item(s) in ",
                    DataLocationNodeLabel, " [", DataLocationNodeName, "] (", TargetCriticalityLevel, ") <- ",
                    "IDENTITY: [", IdentityName, "] <- ",
                    "EXPOSED CREDENTIAL: ", FirstCredentialLabel, " [", FirstCredentialName, "] ",
                    iff(ExposedCredentialCount > 1, strcat("+ ", ExposedCredentialCount - 1, " other credential(s)"), "")
                )
        | order by SecurityScore desc, CriticalityTier asc, TotalExposedCredentials desc

  - ReportName: Attack_Paths_Detailed_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure 
    ReportPurpose: Attack Paths with Device with high severity vulnerabilities allows lateral movement
    SecurityDomain: SecurityDomain
    CategoryInputName: Category
    SubcategoryInputName: Subcategory
    ConfigurationIdInputName: ConfigurationId
    SecuritySeverityInputName: SecuritySeverity
    CriticalityTierLevelInputName: CriticalityTierLevel
    RiskConsequenceScoreOutputName: RiskConsequenceScore
    RiskProbabilityScoreOutputName: RiskProbablityScore
    RiskScoreOutputName: RiskScoreTotal
    CriticalityTierLevelScope:
      - "Critical - tier 0"
      - "High - tier 1"
      - "Medium - tier 2"
      - "Low - tier 3"
    SecuritySeverityScope:
      - "Very High"
      - "High"
      - "Medium-High"
      - "Medium"
      - "Low"
    OutputPropertyOrder:
      - "SecurityDomain"
      - "Category"
      - "Subcategory"
      - "AssetName"
      - "AssetLabel"
      - "ConfigurationName"
      - "ConfigurationId"
      - "Impact"
      - "SecuritySeverity"
      - "CriticalityTier"
      - "CriticalityTierLevel"
      - "RiskFactor_Consequence"
      - "RiskFactor_Probability"
      - "RiskConsequenceScore"
      - "RiskProbablityScore"
      - "RiskScoreTotal"
    SortBy:
      - "RiskScoreTotal"
    ReportQuery:
      - |
        let Nodes =
            ExposureGraphNodes
            | extend CategoriesStr = tolower(tostring(Categories)),
                     LabelStr      = tolower(tostring(NodeLabel))
            | extend NodeNameNorm = coalesce(NodeName, tostring(EntityIds[0].id), tostring(NodeId))
            | extend CriticalityLevel =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].criticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.criticalityLevel),
                    tostring(NodeProperties.criticalityLevel.criticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleBased =
                toint(coalesce(
                    tostring(NodeProperties.criticalityLevelProps[0].ruleBasedCriticalityLevel),
                    tostring(NodeProperties.rawData.criticalityLevel.ruleBasedCriticalityLevel),
                    tostring(NodeProperties.criticalityLevel.ruleBasedCriticalityLevel),
                    "999"
                ))
            | extend CriticalityRuleNames =
                coalesce(
                    strcat_array(NodeProperties.criticalityLevelProps[0].ruleNames, ", "),
                    strcat_array(NodeProperties.rawData.criticalityLevel.ruleNames, ", "),
                    ""
                )
            | extend EG_IsCustomerFacing =
                tobool(coalesce(
                    NodeProperties.rawData.isCustomerFacing,
                    NodeProperties.raw.isCustomerFacing,
                    false
                ))
            | extend EG_IsExcluded =
                tobool(coalesce(
                    NodeProperties.rawData.isExcluded,
                    NodeProperties.raw.isExcluded,
                    false
                ))
            | extend RiskFactors =
                todynamic(coalesce(
                    tostring(NodeProperties.rawData.risk.riskFactors),
                    tostring(NodeProperties.risk.riskFactors),
                    "[]"
                ))
            | extend RawCriticality =
                tostring(coalesce(
                    NodeProperties.rawData.criticality,
                    NodeProperties.criticality,
                    ""
                ))
            | extend CVESeverity =
                tostring(coalesce(
                    NodeProperties.rawData.severity,
                    NodeProperties.rawData.Severity,
                    NodeProperties.rawData.cvssScore,
                    ""
                ))
            | extend RiskFactor_Probability =
                iff(
                    EG_IsCustomerFacing == true
                    or tolower(RawCriticality) in ("critical", "very high")
                    or tostring(RiskFactors) has "Exposure to the Internet",
                    1, 0
                )
            | extend IsEntryPoint =
                        (CategoriesStr has "ip_address")
                     or (CategoriesStr has "device")
                     or (CategoriesStr has "virtual_machine")
                     or (CategoriesStr has "computer"),
                     IsAzureResource =
                        (CategoriesStr has "environmentazure")
                     or (CategoriesStr has "environmentcloud")
            // Tier mapping (per your definition)
            | extend CriticalityTier =
                case(
                    CriticalityLevel == 0, 0,
                    CriticalityLevel == 1, 1,
                    CriticalityLevel == 2, 2,
                    3
                )
            | extend CriticalityTierLevel =
                case(
                    CriticalityTier == 0, "Critical - tier 0",
                    CriticalityTier == 1, "High - tier 1",
                    CriticalityTier == 2, "Medium - tier 2",
                    "Low - tier 3"
                )
            | project
                AssetNodeId = NodeId,
                AssetName   = NodeName,
                AssetLabel  = NodeLabel,
                AssetProps  = NodeProperties,
                CriticalityLevel,
                CriticalityTier,
                CriticalityTierLevel,
                CriticalityRuleBased,
                CriticalityRuleNames,
                EG_IsCustomerFacing,
                EG_IsExcluded,
                IsEntryPoint,
                IsAzureResource,
                RiskFactor_Probability,
                RawCriticality,
                RiskFactors,
                CVESeverity;

        // Step 1 Find devices/computers with CVEs (vulnerabilities)
        let DevicesWithCVEs =
            ExposureGraphEdges
            | where SourceNodeLabel == "Cve"
            | where EdgeLabel == "affecting"
            | where TargetNodeLabel in ("device", "computer-account", "microsoft.compute/virtualmachines")
            // Join to the CVE node (SourceNodeId) to get CVESeverity from node properties
            | join kind=leftouter (Nodes) on $left.SourceNodeId == $right.AssetNodeId
            | summarize
                CVEs             = make_set(SourceNodeName),
                CVESeverities    = make_set(CVESeverity),
                CVECount         = dcount(SourceNodeId),
                HighSeverityCVEs = countif(
                                       tolower(CVESeverity) has "critical"
                                    or tolower(CVESeverity) has "high"
                                    or tolower(CVESeverity) has "medium"
                                  ),
                FirstCVE         = any(SourceNodeName),
                FirstCVESeverity = any(CVESeverity)
              by DeviceNodeId    = TargetNodeId,
                 DeviceNodeName  = TargetNodeName,
                 DeviceNodeLabel = TargetNodeLabel;

        // Step 2 Find ANY credentials/secrets/identities on those vulnerable devices
        let CredentialsOnVulnerableDevices =
            DevicesWithCVEs
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("contains", "defined in", "runs on", "has credentials of", "frequently logged in by")
                | where TargetNodeLabel in (
                    "user",
                    "serviceprincipal",
                    "managedidentity",
                    "entra-userCookie",
                    "azure-active-directory-app-secret",
                    "user-azure-cli-secret",
                    "azure-storage-shared-access-signature",
                    "azure-storage-connection-string",
                    "azure-database-connection-string",
                    "azure-app-configuration-key",
                    "azure-active-directory-user-credentials",
                    "service-principal-azure-cli-secret"
                )
            ) on $left.DeviceNodeId == $right.SourceNodeId
            | project
                DeviceNodeId, DeviceNodeName, DeviceNodeLabel,
                CVEs, CVESeverities, CVECount, HighSeverityCVEs, FirstCVE, FirstCVESeverity,
                CredentialNodeId    = TargetNodeId,
                CredentialNodeName  = TargetNodeName,
                CredentialNodeLabel = TargetNodeLabel;

        // Step 3 Find what identities these credentials can authenticate as
        let CredentialToIdentity =
            CredentialsOnVulnerableDevices
            | join kind=inner (
                ExposureGraphEdges
                | where EdgeLabel in ("has credentials of", "can authenticate as", "can authenticate to")
            ) on $left.CredentialNodeId == $right.SourceNodeId
            | project
                DeviceNodeId, DeviceNodeName, DeviceNodeLabel,
                CVEs, CVESeverities, CVECount, HighSeverityCVEs, FirstCVE, FirstCVESeverity,
                CredentialNodeId, CredentialNodeName, CredentialNodeLabel,
                IdentityNodeId    = TargetNodeId,
                IdentityNodeName  = TargetNodeName,
                IdentityNodeLabel = TargetNodeLabel;

        // Step 4 Find what Azure resources these identities can access
        CredentialToIdentity
        | join kind=inner (
            ExposureGraphEdges
            | where EdgeLabel in ("can authenticate to", "has permissions to", "has role on")
            | where TargetNodeLabel in (
                "microsoft.keyvault/vaults",
                "microsoft.storage/storageaccounts",
                "microsoft.sql/servers",
                "microsoft.sql/servers/databases",
                "microsoft.compute/virtualmachines",
                "microsoft.compute/virtualmachines/extensions",
                "microsoft.cognitiveservices/accounts",
                "microsoft.cognitiveservices/accounts/deployments",
                "microsoft.cognitiveservices/accounts_openai",
                "microsoft.operationalinsights/workspaces",
                "microsoft.web/sites_webapp",
                "microsoft.web/serverfarms",
                "microsoft.logic/workflows",
                "microsoft.network/virtualnetworks",
                "microsoft.network/virtualnetworks/subnets",
                "microsoft.network/networksecuritygroups",
                "subscriptions",
                "resourcegroups",
                "BlobContainer",
                "device",
                "computer-account"
            )
        ) on $left.IdentityNodeId == $right.SourceNodeId

        | where DeviceNodeId != TargetNodeId

        | summarize
            CVEs                = any(CVEs),
            CVESeverities       = any(CVESeverities),
            CVECount            = any(CVECount),
            HighSeverityCVEs    = any(HighSeverityCVEs),
            FirstCVE            = any(FirstCVE),
            FirstCVESeverity    = any(FirstCVESeverity),
            CredentialNodeName  = any(CredentialNodeName),
            CredentialNodeLabel = any(CredentialNodeLabel),
            IdentityNodeName    = any(IdentityNodeName),
            IdentityNodeLabel   = any(IdentityNodeLabel),
            EdgeLabel           = any(EdgeLabel)
          by DeviceNodeId, DeviceNodeName, DeviceNodeLabel, TargetNodeId, TargetNodeName, TargetNodeLabel

        | join kind=leftouter (Nodes) on $left.DeviceNodeId == $right.AssetNodeId
        | join kind=leftouter (Nodes) on $left.TargetNodeId == $right.AssetNodeId

        | extend
            SourceDeviceCriticality      = CriticalityTier,
            SourceDeviceCriticalityLevel = CriticalityTierLevel,
            TargetCriticality            = CriticalityTier1,
            TargetCriticalityLevel       = CriticalityTierLevel1,
            TargetIsCustomerFacing       = EG_IsCustomerFacing1,
            TargetCriticalityRuleBased   = CriticalityRuleBased1,
            TargetCriticalityRuleNames   = CriticalityRuleNames1,
            TargetRiskProbability        = RiskFactor_Probability1

        | extend TierEscalation =
            case(
                SourceDeviceCriticality > TargetCriticality, SourceDeviceCriticality - TargetCriticality,
                0
            )

        | extend TargetTypeFriendly =
            case(
                TargetNodeLabel == "microsoft.keyvault/vaults", "Key vault",
                TargetNodeLabel == "microsoft.storage/storageaccounts", "Storage account",
                TargetNodeLabel == "microsoft.sql/servers", "SQL server",
                TargetNodeLabel == "microsoft.sql/servers/databases", "SQL database",
                TargetNodeLabel == "microsoft.compute/virtualmachines", "Virtual machine",
                TargetNodeLabel == "microsoft.compute/virtualmachines/extensions", "VM extension",
                TargetNodeLabel == "microsoft.cognitiveservices/accounts", "Azure AI service",
                TargetNodeLabel == "microsoft.cognitiveservices/accounts_openai", "Azure OpenAI",
                TargetNodeLabel == "microsoft.cognitiveservices/accounts/deployments", "Azure AI deployment",
                TargetNodeLabel == "microsoft.operationalinsights/workspaces", "Log Analytics workspace",
                TargetNodeLabel == "microsoft.web/sites_webapp", "Web App",
                TargetNodeLabel == "microsoft.web/serverfarms", "App Service plan",
                TargetNodeLabel == "microsoft.logic/workflows", "Logic App",
                TargetNodeLabel == "microsoft.network/virtualnetworks", "Virtual network",
                TargetNodeLabel == "microsoft.network/networksecuritygroups", "Network Security Group",
                TargetNodeLabel == "subscriptions", "Subscription",
                TargetNodeLabel == "resourcegroups", "Resource group",
                TargetNodeLabel == "BlobContainer", "Blob container",
                TargetNodeLabel == "device", "Device",
                TargetNodeLabel == "computer-account", "Computer account",
                TargetNodeLabel
            )

        | extend EntryPointTypeFriendly =
            case(
                DeviceNodeLabel == "device", "Device",
                DeviceNodeLabel == "computer-account", "Computer account",
                DeviceNodeLabel == "microsoft.compute/virtualmachines", "Virtual machine",
                DeviceNodeLabel
            )

        | extend AttackPathName =
            case(
                HighSeverityCVEs > 0 and TargetCriticalityLevel in ("Critical - tier 0", "High - tier 1") and TargetNodeLabel == "microsoft.keyvault/vaults",
                "Device with high severity vulnerabilities allows lateral movement to Critical Azure Key Vault",

                HighSeverityCVEs > 0 and TargetNodeLabel == "microsoft.keyvault/vaults",
                "Device with high severity vulnerabilities allows lateral movement to Azure Key Vault",

                HighSeverityCVEs > 0 and TargetNodeLabel == "microsoft.storage/storageaccounts",
                "Device with high severity vulnerabilities allows lateral movement to Azure storage account",

                HighSeverityCVEs > 0 and TargetNodeLabel == "microsoft.cognitiveservices/accounts",
                "Device with high severity vulnerabilities allows lateral movement to Azure AI service",

                HighSeverityCVEs > 0 and TargetNodeLabel == "microsoft.cognitiveservices/accounts_openai",
                "Device with high severity vulnerabilities allows lateral movement to Azure OpenAI",

                HighSeverityCVEs > 0 and TargetNodeLabel == "subscriptions",
                "Device with high severity vulnerabilities allows lateral movement to Azure subscription",

                HighSeverityCVEs > 0 and TargetNodeLabel == "microsoft.sql/servers/databases",
                "Device with high severity vulnerabilities allows lateral movement to Azure SQL database",

                HighSeverityCVEs > 0 and TargetNodeLabel == "microsoft.web/sites_webapp",
                "Device with high severity vulnerabilities allows lateral movement to Azure Web App",

                HighSeverityCVEs > 0 and TargetNodeLabel == "microsoft.logic/workflows",
                "Device with high severity vulnerabilities allows lateral movement to Azure Logic App",

                strcat("Device with vulnerabilities allows lateral movement to ", TargetTypeFriendly)
            )

        | extend RiskLevel =
            case(
                TargetCriticalityLevel in ("Critical - tier 0", "High - tier 1") and HighSeverityCVEs >= 3, "High",
                TargetCriticalityLevel in ("Critical - tier 0", "High - tier 1") and HighSeverityCVEs >= 1, "Medium",
                HighSeverityCVEs >= 5, "Medium",
                "Low"
            )

        | extend PathType = "Hybrid"

        | extend SecuritySeverityScore =
            case(
                TierEscalation >= 3 and TargetCriticality == 0, 10,
                TierEscalation >= 2 and TargetCriticality == 0, 9,
                TierEscalation >= 1 and TargetCriticality == 0, 8,
                HighSeverityCVEs >= 5 and TargetCriticality <= 1, 8,
                HighSeverityCVEs >= 3 and TargetCriticality <= 1, 7,
                TargetCriticality == 0, 7,
                TierEscalation >= 2 and TargetCriticality == 1, 7,
                TierEscalation >= 1 and TargetCriticality == 1, 6,
                TargetCriticality == 1, 5,
                HighSeverityCVEs >= 3, 5,
                4
            )
        | extend SecuritySeverityLevel =
            case(
                SecuritySeverityScore >= 9, "Critical",
                SecuritySeverityScore >= 7, "Very High",
                SecuritySeverityScore >= 5, "High",
                SecuritySeverityScore >= 3, "Medium-High",
                "Medium"
            )

        | extend SecurityDomain = "Endpoint"
        | extend Category = "AttackPath_VulnerableDeviceToAzure"
        | extend Subcategory =
            case(
                TierEscalation >= 3, strcat("CVE-Based Escalation: Tier ", SourceDeviceCriticality, " to Tier ", TargetCriticality),
                TierEscalation >= 2, strcat("CVE-Based Escalation: Tier ", SourceDeviceCriticality, " to Tier ", TargetCriticality),
                TierEscalation >= 1, strcat("CVE-Based Movement: Tier ", SourceDeviceCriticality, " to Tier ", TargetCriticality),
                strcat("Vulnerable Device to ", TargetTypeFriendly)
            )

        | extend RiskFactors = "Lateral movement, Vulnerabilities"

        //
        // FIX CriticalityTier + CriticalityTierLevel should be derived from TargetCriticalityLevel (tier 0-3 mapping)
        //
        | extend CriticalityTier =
            case(
                TargetCriticalityLevel == "Critical - tier 0", 0,
                TargetCriticalityLevel == "High - tier 1", 1,
                TargetCriticalityLevel == "Medium - tier 2", 2,
                3
            )
        | extend CriticalityTierLevel =
            case(
                CriticalityTier == 0, "Critical - tier 0",
                CriticalityTier == 1, "High - tier 1",
                CriticalityTier == 2, "Medium - tier 2",
                "Low - tier 3"
            )

        | project
            SecurityDomain,
            Category,
            Subcategory,
            AssetName = DeviceNodeName,
            AssetLabel = EntryPointTypeFriendly,
            ConfigurationName = "CVE",
            ConfigurationId = FirstCVE,
            AttackPathName,
            EntryPoint = DeviceNodeName,
            EntryPointType = EntryPointTypeFriendly,
            Target = TargetNodeName,
            TargetType = TargetTypeFriendly,
            TargetCriticality =
                case(
                TargetCriticality == 0, "Critical",
                TargetCriticality == 1, "High",
                TargetCriticality == 2, "Medium",
                "Low"
            ),
            Type = PathType,
            RiskLevel,
            RiskFactors,
            SourceDeviceCriticality = SourceDeviceCriticalityLevel,
            TargetCriticalityDetailed = TargetCriticalityLevel,
            TierEscalation,
            CVECount,
            HighSeverityCVEs,
            FirstCVE,
            FirstCVESeverity,
            AllCVEs = CVEs,
            CredentialType = CredentialNodeLabel,
            CredentialNode = CredentialNodeName,
            IntermediateIdentity = IdentityNodeName,
            IntermediateIdentityType = IdentityNodeLabel,
            SecuritySeverity = SecuritySeverityLevel,
            SecurityScore = SecuritySeverityScore,
            CriticalityTier,
            CriticalityTierLevel,
            CriticalityRuleBased = TargetCriticalityRuleBased,
            CriticalityRuleNames = TargetCriticalityRuleNames,
            IsCustomerFacing = TargetIsCustomerFacing,
            AttackPathDetailed =
                strcat(
                    "ENTRY: ", EntryPointTypeFriendly, " [", DeviceNodeName, "] with ", HighSeverityCVEs, " high-severity CVE(s) -> ",
                    "CREDENTIAL: ", CredentialNodeLabel, " [", CredentialNodeName, "] -> ",
                    "IDENTITY: ", IdentityNodeLabel, " [", IdentityNodeName, "] -> ",
                    "TARGET: ", TargetTypeFriendly, " [", TargetNodeName, "] (", TargetCriticalityLevel, ")"
                )
        | order by SecurityScore desc, TierEscalation desc, CVECount desc, HighSeverityCVEs desc


ReportTemplates:
  - ReportName: RiskAnalysis_Detailed_Bucket_8
    ReportPurpose: Overview
    ReportsIncluded:
      - Name: Device_Recommendations_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 8
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Device_Missing_CVEs_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 8
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Azure_Recommendations_Detailed
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"

  - ReportName: RiskAnalysis_Detailed_Bucket_2
    ReportPurpose: Overview
    ReportsIncluded:
      - Name: Device_Recommendations_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 2
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Device_Missing_CVEs_Detailed_BucketFilter
        UseQueryBucketing: true
        DefaultBucketCount: 2
        BucketPlaceholderToken: "__BUCKET_FILTER__"
      - Name: Azure_Recommendations_Detailed
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
  
  - ReportName: RiskAnalysis_Summary
    ReportPurpose: Overview
    ReportsIncluded:
      - Name: Device_Recommendations_Summary
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Device_Missing_CVEs_Summary
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Azure_Recommendations_Summary
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Summary_Credential_Based_Lateral_Movement
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"

  - ReportName: AttackPaths_Detailed
    ReportPurpose: Attack Paths
    ReportsIncluded:
      - Name: Attack_Paths_Detailed_Credential_Based_Lateral_Movement
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Github_to_Azure_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Public_IP_to_VM_with_CVE_Exploitation
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Identity_Group_Membership_to_Privileged_Resources
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Data_Sensitivity_to_Exposed_Credentials
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"
      - Name: Attack_Paths_Detailed_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"

  - ReportName: AttackPaths_Detailed_Test
    ReportPurpose: Attack Paths
    ReportsIncluded:
      - Name: Attack_Paths_Detailed_Device_with_high_severity_vulnerabilities_allows_lateral_movement_Azure
        UseQueryBucketing: false
        DefaultBucketCount: 0
        BucketPlaceholderToken: "N/A"

